
ElectricBike.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000038ca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00800060  000038ca  0000395e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000030  008000b2  008000b2  000039b0  2**0
                  ALLOC
  3 .stab         000048a8  00000000  00000000  000039b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000024d3  00000000  00000000  00008258  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000030  00000000  00000000  0000a72b  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 01 	jmp	0x312	; 0x312 <__ctors_end>
       4:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       8:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      10:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      14:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      18:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      1c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      20:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      24:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      28:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      2c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      30:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      34:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      38:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      3c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      40:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      44:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      48:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      4c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      50:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      54:	e8 08       	sbc	r14, r8
      56:	f2 0a       	sbc	r15, r18
      58:	f2 0a       	sbc	r15, r18
      5a:	f2 0a       	sbc	r15, r18
      5c:	f2 0a       	sbc	r15, r18
      5e:	f2 0a       	sbc	r15, r18
      60:	f2 0a       	sbc	r15, r18
      62:	cb 09       	sbc	r28, r11
      64:	f2 0a       	sbc	r15, r18
      66:	a9 0a       	sbc	r10, r25
      68:	f2 0a       	sbc	r15, r18
      6a:	f2 0a       	sbc	r15, r18
      6c:	f2 0a       	sbc	r15, r18
      6e:	f2 0a       	sbc	r15, r18
      70:	f2 0a       	sbc	r15, r18
      72:	f2 0a       	sbc	r15, r18
      74:	f2 0a       	sbc	r15, r18
      76:	f2 0a       	sbc	r15, r18
      78:	f2 0a       	sbc	r15, r18
      7a:	f2 0a       	sbc	r15, r18
      7c:	f2 0a       	sbc	r15, r18
      7e:	f1 09       	sbc	r31, r1
      80:	17 0a       	sbc	r1, r23
      82:	33 09       	sbc	r19, r3
      84:	f2 0a       	sbc	r15, r18
      86:	0d 09       	sbc	r16, r13
      88:	3d 0a       	sbc	r3, r29
      8a:	f2 0a       	sbc	r15, r18
      8c:	f2 0a       	sbc	r15, r18
      8e:	f2 0a       	sbc	r15, r18
      90:	f2 0a       	sbc	r15, r18
      92:	f2 0a       	sbc	r15, r18
      94:	f2 0a       	sbc	r15, r18
      96:	f2 0a       	sbc	r15, r18
      98:	f2 0a       	sbc	r15, r18
      9a:	f2 0a       	sbc	r15, r18
      9c:	f2 0a       	sbc	r15, r18
      9e:	f2 0a       	sbc	r15, r18
      a0:	f2 0a       	sbc	r15, r18
      a2:	f2 0a       	sbc	r15, r18
      a4:	f2 0a       	sbc	r15, r18
      a6:	f2 0a       	sbc	r15, r18
      a8:	f2 0a       	sbc	r15, r18
      aa:	f2 0a       	sbc	r15, r18
      ac:	f2 0a       	sbc	r15, r18
      ae:	f2 0a       	sbc	r15, r18
      b0:	f2 0a       	sbc	r15, r18
      b2:	f2 0a       	sbc	r15, r18
      b4:	f2 0a       	sbc	r15, r18
      b6:	f2 0a       	sbc	r15, r18
      b8:	f2 0a       	sbc	r15, r18
      ba:	f2 0a       	sbc	r15, r18
      bc:	f2 0a       	sbc	r15, r18
      be:	f2 0a       	sbc	r15, r18
      c0:	61 0a       	sbc	r6, r17
      c2:	f2 0a       	sbc	r15, r18
      c4:	85 0a       	sbc	r8, r21
      c6:	f2 0a       	sbc	r15, r18
      c8:	f2 0a       	sbc	r15, r18
      ca:	f2 0a       	sbc	r15, r18
      cc:	f2 0a       	sbc	r15, r18
      ce:	f2 0a       	sbc	r15, r18
      d0:	f2 0a       	sbc	r15, r18
      d2:	f2 0a       	sbc	r15, r18
      d4:	f2 0a       	sbc	r15, r18
      d6:	f2 0a       	sbc	r15, r18
      d8:	f2 0a       	sbc	r15, r18
      da:	f2 0a       	sbc	r15, r18
      dc:	f2 0a       	sbc	r15, r18
      de:	f2 0a       	sbc	r15, r18
      e0:	f2 0a       	sbc	r15, r18
      e2:	f2 0a       	sbc	r15, r18
      e4:	f2 0a       	sbc	r15, r18
      e6:	f2 0a       	sbc	r15, r18
      e8:	f2 0a       	sbc	r15, r18
      ea:	f2 0a       	sbc	r15, r18
      ec:	f2 0a       	sbc	r15, r18
      ee:	f2 0a       	sbc	r15, r18
      f0:	f2 0a       	sbc	r15, r18
      f2:	f2 0a       	sbc	r15, r18
      f4:	f2 0a       	sbc	r15, r18
      f6:	f2 0a       	sbc	r15, r18
      f8:	f2 0a       	sbc	r15, r18
      fa:	f2 0a       	sbc	r15, r18
      fc:	f2 0a       	sbc	r15, r18
      fe:	f2 0a       	sbc	r15, r18
     100:	7f 09       	sbc	r23, r15
     102:	59 09       	sbc	r21, r9
     104:	a5 09       	sbc	r26, r5
     106:	0f 11       	cpse	r16, r15
     108:	44 11       	cpse	r20, r4
     10a:	44 11       	cpse	r20, r4
     10c:	44 11       	cpse	r20, r4
     10e:	44 11       	cpse	r20, r4
     110:	44 11       	cpse	r20, r4
     112:	44 11       	cpse	r20, r4
     114:	bd 0e       	add	r11, r29
     116:	44 11       	cpse	r20, r4
     118:	59 0f       	add	r21, r25
     11a:	44 11       	cpse	r20, r4
     11c:	44 11       	cpse	r20, r4
     11e:	44 11       	cpse	r20, r4
     120:	44 11       	cpse	r20, r4
     122:	44 11       	cpse	r20, r4
     124:	44 11       	cpse	r20, r4
     126:	44 11       	cpse	r20, r4
     128:	44 11       	cpse	r20, r4
     12a:	44 11       	cpse	r20, r4
     12c:	44 11       	cpse	r20, r4
     12e:	44 11       	cpse	r20, r4
     130:	d8 0e       	add	r13, r24
     132:	f3 0e       	add	r15, r19
     134:	51 0e       	add	r5, r17
     136:	44 11       	cpse	r20, r4
     138:	36 0e       	add	r3, r22
     13a:	0e 0f       	add	r16, r30
     13c:	44 11       	cpse	r20, r4
     13e:	44 11       	cpse	r20, r4
     140:	d1 10       	cpse	r13, r1
     142:	72 0f       	add	r23, r18
     144:	db 0f       	add	r29, r27
     146:	44 11       	cpse	r20, r4
     148:	29 11       	cpse	r18, r9
     14a:	44 11       	cpse	r20, r4
     14c:	44 11       	cpse	r20, r4
     14e:	44 11       	cpse	r20, r4
     150:	44 11       	cpse	r20, r4
     152:	44 11       	cpse	r20, r4
     154:	44 11       	cpse	r20, r4
     156:	44 11       	cpse	r20, r4
     158:	44 11       	cpse	r20, r4
     15a:	44 11       	cpse	r20, r4
     15c:	44 11       	cpse	r20, r4
     15e:	44 11       	cpse	r20, r4
     160:	44 11       	cpse	r20, r4
     162:	f8 10       	cpse	r15, r8
     164:	44 11       	cpse	r20, r4
     166:	4a 10       	cpse	r4, r10
     168:	44 11       	cpse	r20, r4
     16a:	44 11       	cpse	r20, r4
     16c:	8b 10       	cpse	r8, r11
     16e:	44 11       	cpse	r20, r4
     170:	44 11       	cpse	r20, r4
     172:	27 0f       	add	r18, r23
     174:	44 11       	cpse	r20, r4
     176:	40 0f       	add	r20, r16
     178:	44 11       	cpse	r20, r4
     17a:	44 11       	cpse	r20, r4
     17c:	44 11       	cpse	r20, r4
     17e:	44 11       	cpse	r20, r4
     180:	ad 10       	cpse	r10, r13
     182:	72 0f       	add	r23, r18
     184:	97 0f       	add	r25, r23
     186:	44 11       	cpse	r20, r4
     188:	29 11       	cpse	r18, r9
     18a:	44 11       	cpse	r20, r4
     18c:	44 11       	cpse	r20, r4
     18e:	44 11       	cpse	r20, r4
     190:	44 11       	cpse	r20, r4
     192:	44 11       	cpse	r20, r4
     194:	44 11       	cpse	r20, r4
     196:	44 11       	cpse	r20, r4
     198:	44 11       	cpse	r20, r4
     19a:	44 11       	cpse	r20, r4
     19c:	44 11       	cpse	r20, r4
     19e:	44 11       	cpse	r20, r4
     1a0:	44 11       	cpse	r20, r4
     1a2:	f8 10       	cpse	r15, r8
     1a4:	44 11       	cpse	r20, r4
     1a6:	2b 10       	cpse	r2, r11
     1a8:	44 11       	cpse	r20, r4
     1aa:	44 11       	cpse	r20, r4
     1ac:	6c 10       	cpse	r6, r12
     1ae:	44 11       	cpse	r20, r4
     1b0:	44 11       	cpse	r20, r4
     1b2:	87 0e       	add	r8, r23
     1b4:	6c 0e       	add	r6, r28
     1b6:	a2 0e       	add	r10, r18
     1b8:	0f 13       	cpse	r16, r31
     1ba:	18 13       	cpse	r17, r24
     1bc:	18 13       	cpse	r17, r24
     1be:	18 13       	cpse	r17, r24
     1c0:	18 13       	cpse	r17, r24
     1c2:	18 13       	cpse	r17, r24
     1c4:	18 13       	cpse	r17, r24
     1c6:	d7 11       	cpse	r29, r7
     1c8:	18 13       	cpse	r17, r24
     1ca:	ef 11       	cpse	r30, r15
     1cc:	18 13       	cpse	r17, r24
     1ce:	18 13       	cpse	r17, r24
     1d0:	18 13       	cpse	r17, r24
     1d2:	18 13       	cpse	r17, r24
     1d4:	18 13       	cpse	r17, r24
     1d6:	18 13       	cpse	r17, r24
     1d8:	18 13       	cpse	r17, r24
     1da:	18 13       	cpse	r17, r24
     1dc:	18 13       	cpse	r17, r24
     1de:	18 13       	cpse	r17, r24
     1e0:	18 13       	cpse	r17, r24
     1e2:	dc 11       	cpse	r29, r12
     1e4:	e1 11       	cpse	r30, r1
     1e6:	c3 11       	cpse	r28, r3
     1e8:	18 13       	cpse	r17, r24
     1ea:	be 11       	cpse	r27, r14
     1ec:	e6 11       	cpse	r30, r6
     1ee:	18 13       	cpse	r17, r24
     1f0:	18 13       	cpse	r17, r24
     1f2:	de 12       	cpse	r13, r30
     1f4:	f2 11       	cpse	r31, r2
     1f6:	28 12       	cpse	r2, r24
     1f8:	18 13       	cpse	r17, r24
     1fa:	13 13       	cpse	r17, r19
     1fc:	18 13       	cpse	r17, r24
     1fe:	18 13       	cpse	r17, r24
     200:	18 13       	cpse	r17, r24
     202:	18 13       	cpse	r17, r24
     204:	18 13       	cpse	r17, r24
     206:	18 13       	cpse	r17, r24
     208:	18 13       	cpse	r17, r24
     20a:	18 13       	cpse	r17, r24
     20c:	18 13       	cpse	r17, r24
     20e:	18 13       	cpse	r17, r24
     210:	18 13       	cpse	r17, r24
     212:	18 13       	cpse	r17, r24
     214:	fe 12       	cpse	r15, r30
     216:	18 13       	cpse	r17, r24
     218:	73 12       	cpse	r7, r19
     21a:	18 13       	cpse	r17, r24
     21c:	18 13       	cpse	r17, r24
     21e:	a6 12       	cpse	r10, r22
     220:	18 13       	cpse	r17, r24
     222:	18 13       	cpse	r17, r24
     224:	e9 11       	cpse	r30, r9
     226:	18 13       	cpse	r17, r24
     228:	ec 11       	cpse	r30, r12
     22a:	18 13       	cpse	r17, r24
     22c:	18 13       	cpse	r17, r24
     22e:	18 13       	cpse	r17, r24
     230:	18 13       	cpse	r17, r24
     232:	c1 12       	cpse	r12, r17
     234:	f2 11       	cpse	r31, r2
     236:	01 12       	cpse	r0, r17
     238:	18 13       	cpse	r17, r24
     23a:	13 13       	cpse	r17, r19
     23c:	18 13       	cpse	r17, r24
     23e:	18 13       	cpse	r17, r24
     240:	18 13       	cpse	r17, r24
     242:	18 13       	cpse	r17, r24
     244:	18 13       	cpse	r17, r24
     246:	18 13       	cpse	r17, r24
     248:	18 13       	cpse	r17, r24
     24a:	18 13       	cpse	r17, r24
     24c:	18 13       	cpse	r17, r24
     24e:	18 13       	cpse	r17, r24
     250:	18 13       	cpse	r17, r24
     252:	18 13       	cpse	r17, r24
     254:	fe 12       	cpse	r15, r30
     256:	18 13       	cpse	r17, r24
     258:	5b 12       	cpse	r5, r27
     25a:	18 13       	cpse	r17, r24
     25c:	18 13       	cpse	r17, r24
     25e:	8e 12       	cpse	r8, r30
     260:	18 13       	cpse	r17, r24
     262:	18 13       	cpse	r17, r24
     264:	cd 11       	cpse	r28, r13
     266:	c8 11       	cpse	r28, r8
     268:	d2 11       	cpse	r29, r2
     26a:	08 1a       	sub	r0, r24
     26c:	10 1a       	sub	r1, r16
     26e:	10 1a       	sub	r1, r16
     270:	10 1a       	sub	r1, r16
     272:	10 1a       	sub	r1, r16
     274:	10 1a       	sub	r1, r16
     276:	10 1a       	sub	r1, r16
     278:	10 1a       	sub	r1, r16
     27a:	10 1a       	sub	r1, r16
     27c:	10 1a       	sub	r1, r16
     27e:	10 1a       	sub	r1, r16
     280:	10 1a       	sub	r1, r16
     282:	10 1a       	sub	r1, r16
     284:	10 1a       	sub	r1, r16
     286:	10 1a       	sub	r1, r16
     288:	10 1a       	sub	r1, r16
     28a:	10 1a       	sub	r1, r16
     28c:	10 1a       	sub	r1, r16
     28e:	10 1a       	sub	r1, r16
     290:	10 1a       	sub	r1, r16
     292:	10 1a       	sub	r1, r16
     294:	10 1a       	sub	r1, r16
     296:	10 1a       	sub	r1, r16
     298:	10 1a       	sub	r1, r16
     29a:	10 1a       	sub	r1, r16
     29c:	10 1a       	sub	r1, r16
     29e:	10 1a       	sub	r1, r16
     2a0:	10 1a       	sub	r1, r16
     2a2:	10 1a       	sub	r1, r16
     2a4:	be 19       	sub	r27, r14
     2a6:	d2 18       	sub	r13, r2
     2a8:	08 19       	sub	r16, r8
     2aa:	10 1a       	sub	r1, r16
     2ac:	de 19       	sub	r29, r14
     2ae:	10 1a       	sub	r1, r16
     2b0:	10 1a       	sub	r1, r16
     2b2:	10 1a       	sub	r1, r16
     2b4:	10 1a       	sub	r1, r16
     2b6:	10 1a       	sub	r1, r16
     2b8:	10 1a       	sub	r1, r16
     2ba:	10 1a       	sub	r1, r16
     2bc:	10 1a       	sub	r1, r16
     2be:	10 1a       	sub	r1, r16
     2c0:	10 1a       	sub	r1, r16
     2c2:	10 1a       	sub	r1, r16
     2c4:	10 1a       	sub	r1, r16
     2c6:	f7 19       	sub	r31, r7
     2c8:	10 1a       	sub	r1, r16
     2ca:	53 19       	sub	r21, r3
     2cc:	10 1a       	sub	r1, r16
     2ce:	10 1a       	sub	r1, r16
     2d0:	86 19       	sub	r24, r6
     2d2:	10 1a       	sub	r1, r16
     2d4:	10 1a       	sub	r1, r16
     2d6:	10 1a       	sub	r1, r16
     2d8:	10 1a       	sub	r1, r16
     2da:	10 1a       	sub	r1, r16
     2dc:	10 1a       	sub	r1, r16
     2de:	10 1a       	sub	r1, r16
     2e0:	10 1a       	sub	r1, r16
     2e2:	10 1a       	sub	r1, r16
     2e4:	a1 19       	sub	r26, r1
     2e6:	d2 18       	sub	r13, r2
     2e8:	e1 18       	sub	r14, r1
     2ea:	10 1a       	sub	r1, r16
     2ec:	de 19       	sub	r29, r14
     2ee:	10 1a       	sub	r1, r16
     2f0:	10 1a       	sub	r1, r16
     2f2:	10 1a       	sub	r1, r16
     2f4:	10 1a       	sub	r1, r16
     2f6:	10 1a       	sub	r1, r16
     2f8:	10 1a       	sub	r1, r16
     2fa:	10 1a       	sub	r1, r16
     2fc:	10 1a       	sub	r1, r16
     2fe:	10 1a       	sub	r1, r16
     300:	10 1a       	sub	r1, r16
     302:	10 1a       	sub	r1, r16
     304:	10 1a       	sub	r1, r16
     306:	f7 19       	sub	r31, r7
     308:	10 1a       	sub	r1, r16
     30a:	3b 19       	sub	r19, r11
     30c:	10 1a       	sub	r1, r16
     30e:	10 1a       	sub	r1, r16
     310:	6e 19       	sub	r22, r14

00000312 <__ctors_end>:
     312:	11 24       	eor	r1, r1
     314:	1f be       	out	0x3f, r1	; 63
     316:	cf e5       	ldi	r28, 0x5F	; 95
     318:	d8 e0       	ldi	r29, 0x08	; 8
     31a:	de bf       	out	0x3e, r29	; 62
     31c:	cd bf       	out	0x3d, r28	; 61

0000031e <__do_copy_data>:
     31e:	10 e0       	ldi	r17, 0x00	; 0
     320:	a0 e6       	ldi	r26, 0x60	; 96
     322:	b0 e0       	ldi	r27, 0x00	; 0
     324:	ea ec       	ldi	r30, 0xCA	; 202
     326:	f8 e3       	ldi	r31, 0x38	; 56
     328:	02 c0       	rjmp	.+4      	; 0x32e <__do_copy_data+0x10>
     32a:	05 90       	lpm	r0, Z+
     32c:	0d 92       	st	X+, r0
     32e:	a2 3b       	cpi	r26, 0xB2	; 178
     330:	b1 07       	cpc	r27, r17
     332:	d9 f7       	brne	.-10     	; 0x32a <__do_copy_data+0xc>

00000334 <__do_clear_bss>:
     334:	20 e0       	ldi	r18, 0x00	; 0
     336:	a2 eb       	ldi	r26, 0xB2	; 178
     338:	b0 e0       	ldi	r27, 0x00	; 0
     33a:	01 c0       	rjmp	.+2      	; 0x33e <.do_clear_bss_start>

0000033c <.do_clear_bss_loop>:
     33c:	1d 92       	st	X+, r1

0000033e <.do_clear_bss_start>:
     33e:	a2 3e       	cpi	r26, 0xE2	; 226
     340:	b2 07       	cpc	r27, r18
     342:	e1 f7       	brne	.-8      	; 0x33c <.do_clear_bss_loop>
     344:	0e 94 a8 01 	call	0x350	; 0x350 <main>
     348:	0c 94 63 1c 	jmp	0x38c6	; 0x38c6 <_exit>

0000034c <__bad_interrupt>:
     34c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000350 <main>:

/* DECLARATIONS FUNCTIONS */


/* MAIN PROGRAM */
int main() {
     350:	8f 92       	push	r8
     352:	af 92       	push	r10
     354:	cf 92       	push	r12
     356:	ef 92       	push	r14
     358:	0f 93       	push	r16
     35a:	cf 93       	push	r28
     35c:	df 93       	push	r29
     35e:	cd b7       	in	r28, 0x3d	; 61
     360:	de b7       	in	r29, 0x3e	; 62
	LCD_SetUp(PA_0, PA_1, PA_2, P_NC, P_NC, P_NC, P_NC, PA_3, PA_4, PA_5, PA_6);
     362:	86 e0       	ldi	r24, 0x06	; 6
     364:	8f 93       	push	r24
     366:	85 e0       	ldi	r24, 0x05	; 5
     368:	8f 93       	push	r24
     36a:	68 94       	set
     36c:	88 24       	eor	r8, r8
     36e:	82 f8       	bld	r8, 2
     370:	0f 2e       	mov	r0, r31
     372:	f3 e0       	ldi	r31, 0x03	; 3
     374:	af 2e       	mov	r10, r31
     376:	f0 2d       	mov	r31, r0
     378:	cc 24       	eor	r12, r12
     37a:	ca 94       	dec	r12
     37c:	ee 24       	eor	r14, r14
     37e:	ea 94       	dec	r14
     380:	0f ef       	ldi	r16, 0xFF	; 255
     382:	2f ef       	ldi	r18, 0xFF	; 255
     384:	42 e0       	ldi	r20, 0x02	; 2
     386:	61 e0       	ldi	r22, 0x01	; 1
     388:	80 e0       	ldi	r24, 0x00	; 0
     38a:	0e 94 1b 07 	call	0xe36	; 0xe36 <LCD_SetUp>
     38e:	0f 90       	pop	r0
     390:	0f 90       	pop	r0
	LCD_Init(2, 16);
     392:	60 e1       	ldi	r22, 0x10	; 16
     394:	82 e0       	ldi	r24, 0x02	; 2
     396:	0e 94 a1 07 	call	0xf42	; 0xf42 <LCD_Init>
	LCD_Printf("DUPA");
     39a:	84 e6       	ldi	r24, 0x64	; 100
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	89 2f       	mov	r24, r25
     3a0:	8f 93       	push	r24
     3a2:	84 e6       	ldi	r24, 0x64	; 100
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	8f 93       	push	r24
     3a8:	0e 94 5d 11 	call	0x22ba	; 0x22ba <LCD_Printf>
     3ac:	0f 90       	pop	r0
     3ae:	0f 90       	pop	r0

	return (0);
     3b0:	80 e0       	ldi	r24, 0x00	; 0
     3b2:	90 e0       	ldi	r25, 0x00	; 0
}
     3b4:	df 91       	pop	r29
     3b6:	cf 91       	pop	r28
     3b8:	0f 91       	pop	r16
     3ba:	ef 90       	pop	r14
     3bc:	cf 90       	pop	r12
     3be:	af 90       	pop	r10
     3c0:	8f 90       	pop	r8
     3c2:	08 95       	ret

000003c4 <DELAY_us>:
         It generates a delay of approximate 1us for each count,
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
     3c4:	cf 93       	push	r28
     3c6:	df 93       	push	r29
     3c8:	cd b7       	in	r28, 0x3d	; 61
     3ca:	de b7       	in	r29, 0x3e	; 62
     3cc:	a3 97       	sbiw	r28, 0x23	; 35
     3ce:	0f b6       	in	r0, 0x3f	; 63
     3d0:	f8 94       	cli
     3d2:	de bf       	out	0x3e, r29	; 62
     3d4:	0f be       	out	0x3f, r0	; 63
     3d6:	cd bf       	out	0x3d, r28	; 61
     3d8:	9b a3       	std	Y+35, r25	; 0x23
     3da:	8a a3       	std	Y+34, r24	; 0x22
    while (us_count != 0) 
     3dc:	f8 c0       	rjmp	.+496    	; 0x5ce <DELAY_us+0x20a>
     3de:	80 e0       	ldi	r24, 0x00	; 0
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	a0 e8       	ldi	r26, 0x80	; 128
     3e4:	bf e3       	ldi	r27, 0x3F	; 63
     3e6:	89 83       	std	Y+1, r24	; 0x01
     3e8:	9a 83       	std	Y+2, r25	; 0x02
     3ea:	ab 83       	std	Y+3, r26	; 0x03
     3ec:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
     3ee:	29 e8       	ldi	r18, 0x89	; 137
     3f0:	38 e8       	ldi	r19, 0x88	; 136
     3f2:	48 e0       	ldi	r20, 0x08	; 8
     3f4:	5f e3       	ldi	r21, 0x3F	; 63
     3f6:	69 81       	ldd	r22, Y+1	; 0x01
     3f8:	7a 81       	ldd	r23, Y+2	; 0x02
     3fa:	8b 81       	ldd	r24, Y+3	; 0x03
     3fc:	9c 81       	ldd	r25, Y+4	; 0x04
     3fe:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     402:	dc 01       	movw	r26, r24
     404:	cb 01       	movw	r24, r22
     406:	8d 83       	std	Y+5, r24	; 0x05
     408:	9e 83       	std	Y+6, r25	; 0x06
     40a:	af 83       	std	Y+7, r26	; 0x07
     40c:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
     40e:	2d ec       	ldi	r18, 0xCD	; 205
     410:	3c ec       	ldi	r19, 0xCC	; 204
     412:	4c ec       	ldi	r20, 0xCC	; 204
     414:	5e e3       	ldi	r21, 0x3E	; 62
     416:	69 81       	ldd	r22, Y+1	; 0x01
     418:	7a 81       	ldd	r23, Y+2	; 0x02
     41a:	8b 81       	ldd	r24, Y+3	; 0x03
     41c:	9c 81       	ldd	r25, Y+4	; 0x04
     41e:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     422:	dc 01       	movw	r26, r24
     424:	cb 01       	movw	r24, r22
     426:	89 87       	std	Y+9, r24	; 0x09
     428:	9a 87       	std	Y+10, r25	; 0x0a
     42a:	ab 87       	std	Y+11, r26	; 0x0b
     42c:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
     42e:	20 e0       	ldi	r18, 0x00	; 0
     430:	30 e0       	ldi	r19, 0x00	; 0
     432:	40 e8       	ldi	r20, 0x80	; 128
     434:	5f e3       	ldi	r21, 0x3F	; 63
     436:	6d 81       	ldd	r22, Y+5	; 0x05
     438:	7e 81       	ldd	r23, Y+6	; 0x06
     43a:	8f 81       	ldd	r24, Y+7	; 0x07
     43c:	98 85       	ldd	r25, Y+8	; 0x08
     43e:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__cmpsf2>
     442:	88 23       	and	r24, r24
     444:	1c f4       	brge	.+6      	; 0x44c <DELAY_us+0x88>
		__ticks = 1;
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	8d 87       	std	Y+13, r24	; 0x0d
     44a:	b6 c0       	rjmp	.+364    	; 0x5b8 <DELAY_us+0x1f4>
	else if (__tmp2 > 65535)
     44c:	20 e0       	ldi	r18, 0x00	; 0
     44e:	3f ef       	ldi	r19, 0xFF	; 255
     450:	4f e7       	ldi	r20, 0x7F	; 127
     452:	57 e4       	ldi	r21, 0x47	; 71
     454:	69 85       	ldd	r22, Y+9	; 0x09
     456:	7a 85       	ldd	r23, Y+10	; 0x0a
     458:	8b 85       	ldd	r24, Y+11	; 0x0b
     45a:	9c 85       	ldd	r25, Y+12	; 0x0c
     45c:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     460:	18 16       	cp	r1, r24
     462:	0c f0       	brlt	.+2      	; 0x466 <DELAY_us+0xa2>
     464:	7f c0       	rjmp	.+254    	; 0x564 <DELAY_us+0x1a0>
	{
		_delay_ms(__us / 1000.0);
     466:	20 e0       	ldi	r18, 0x00	; 0
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	4a e7       	ldi	r20, 0x7A	; 122
     46c:	54 e4       	ldi	r21, 0x44	; 68
     46e:	69 81       	ldd	r22, Y+1	; 0x01
     470:	7a 81       	ldd	r23, Y+2	; 0x02
     472:	8b 81       	ldd	r24, Y+3	; 0x03
     474:	9c 81       	ldd	r25, Y+4	; 0x04
     476:	0e 94 b6 1a 	call	0x356c	; 0x356c <__divsf3>
     47a:	dc 01       	movw	r26, r24
     47c:	cb 01       	movw	r24, r22
     47e:	8e 87       	std	Y+14, r24	; 0x0e
     480:	9f 87       	std	Y+15, r25	; 0x0f
     482:	a8 8b       	std	Y+16, r26	; 0x10
     484:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     486:	20 e0       	ldi	r18, 0x00	; 0
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	48 ec       	ldi	r20, 0xC8	; 200
     48c:	53 e4       	ldi	r21, 0x43	; 67
     48e:	6e 85       	ldd	r22, Y+14	; 0x0e
     490:	7f 85       	ldd	r23, Y+15	; 0x0f
     492:	88 89       	ldd	r24, Y+16	; 0x10
     494:	99 89       	ldd	r25, Y+17	; 0x11
     496:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     49a:	dc 01       	movw	r26, r24
     49c:	cb 01       	movw	r24, r22
     49e:	8a 8b       	std	Y+18, r24	; 0x12
     4a0:	9b 8b       	std	Y+19, r25	; 0x13
     4a2:	ac 8b       	std	Y+20, r26	; 0x14
     4a4:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
     4a6:	20 e0       	ldi	r18, 0x00	; 0
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	40 e8       	ldi	r20, 0x80	; 128
     4ac:	5f e3       	ldi	r21, 0x3F	; 63
     4ae:	6a 89       	ldd	r22, Y+18	; 0x12
     4b0:	7b 89       	ldd	r23, Y+19	; 0x13
     4b2:	8c 89       	ldd	r24, Y+20	; 0x14
     4b4:	9d 89       	ldd	r25, Y+21	; 0x15
     4b6:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__cmpsf2>
     4ba:	88 23       	and	r24, r24
     4bc:	2c f4       	brge	.+10     	; 0x4c8 <DELAY_us+0x104>
		__ticks = 1;
     4be:	81 e0       	ldi	r24, 0x01	; 1
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	9f 8b       	std	Y+23, r25	; 0x17
     4c4:	8e 8b       	std	Y+22, r24	; 0x16
     4c6:	41 c0       	rjmp	.+130    	; 0x54a <DELAY_us+0x186>
	else if (__tmp > 65535)
     4c8:	20 e0       	ldi	r18, 0x00	; 0
     4ca:	3f ef       	ldi	r19, 0xFF	; 255
     4cc:	4f e7       	ldi	r20, 0x7F	; 127
     4ce:	57 e4       	ldi	r21, 0x47	; 71
     4d0:	6a 89       	ldd	r22, Y+18	; 0x12
     4d2:	7b 89       	ldd	r23, Y+19	; 0x13
     4d4:	8c 89       	ldd	r24, Y+20	; 0x14
     4d6:	9d 89       	ldd	r25, Y+21	; 0x15
     4d8:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     4dc:	18 16       	cp	r1, r24
     4de:	5c f5       	brge	.+86     	; 0x536 <DELAY_us+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     4e0:	20 e0       	ldi	r18, 0x00	; 0
     4e2:	30 e0       	ldi	r19, 0x00	; 0
     4e4:	40 e2       	ldi	r20, 0x20	; 32
     4e6:	51 e4       	ldi	r21, 0x41	; 65
     4e8:	6e 85       	ldd	r22, Y+14	; 0x0e
     4ea:	7f 85       	ldd	r23, Y+15	; 0x0f
     4ec:	88 89       	ldd	r24, Y+16	; 0x10
     4ee:	99 89       	ldd	r25, Y+17	; 0x11
     4f0:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     4f4:	dc 01       	movw	r26, r24
     4f6:	cb 01       	movw	r24, r22
     4f8:	bc 01       	movw	r22, r24
     4fa:	cd 01       	movw	r24, r26
     4fc:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     500:	dc 01       	movw	r26, r24
     502:	cb 01       	movw	r24, r22
     504:	9f 8b       	std	Y+23, r25	; 0x17
     506:	8e 8b       	std	Y+22, r24	; 0x16
     508:	0f c0       	rjmp	.+30     	; 0x528 <DELAY_us+0x164>
     50a:	88 e2       	ldi	r24, 0x28	; 40
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	99 8f       	std	Y+25, r25	; 0x19
     510:	88 8f       	std	Y+24, r24	; 0x18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     512:	88 8d       	ldd	r24, Y+24	; 0x18
     514:	99 8d       	ldd	r25, Y+25	; 0x19
     516:	01 97       	sbiw	r24, 0x01	; 1
     518:	f1 f7       	brne	.-4      	; 0x516 <DELAY_us+0x152>
     51a:	99 8f       	std	Y+25, r25	; 0x19
     51c:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     51e:	8e 89       	ldd	r24, Y+22	; 0x16
     520:	9f 89       	ldd	r25, Y+23	; 0x17
     522:	01 97       	sbiw	r24, 0x01	; 1
     524:	9f 8b       	std	Y+23, r25	; 0x17
     526:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     528:	8e 89       	ldd	r24, Y+22	; 0x16
     52a:	9f 89       	ldd	r25, Y+23	; 0x17
     52c:	00 97       	sbiw	r24, 0x00	; 0
     52e:	69 f7       	brne	.-38     	; 0x50a <DELAY_us+0x146>
     530:	89 a1       	ldd	r24, Y+33	; 0x21
     532:	8d 87       	std	Y+13, r24	; 0x0d
     534:	41 c0       	rjmp	.+130    	; 0x5b8 <DELAY_us+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     536:	6a 89       	ldd	r22, Y+18	; 0x12
     538:	7b 89       	ldd	r23, Y+19	; 0x13
     53a:	8c 89       	ldd	r24, Y+20	; 0x14
     53c:	9d 89       	ldd	r25, Y+21	; 0x15
     53e:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     542:	dc 01       	movw	r26, r24
     544:	cb 01       	movw	r24, r22
     546:	9f 8b       	std	Y+23, r25	; 0x17
     548:	8e 8b       	std	Y+22, r24	; 0x16
     54a:	8e 89       	ldd	r24, Y+22	; 0x16
     54c:	9f 89       	ldd	r25, Y+23	; 0x17
     54e:	9b 8f       	std	Y+27, r25	; 0x1b
     550:	8a 8f       	std	Y+26, r24	; 0x1a
     552:	8a 8d       	ldd	r24, Y+26	; 0x1a
     554:	9b 8d       	ldd	r25, Y+27	; 0x1b
     556:	01 97       	sbiw	r24, 0x01	; 1
     558:	f1 f7       	brne	.-4      	; 0x556 <DELAY_us+0x192>
     55a:	9b 8f       	std	Y+27, r25	; 0x1b
     55c:	8a 8f       	std	Y+26, r24	; 0x1a
     55e:	89 a1       	ldd	r24, Y+33	; 0x21
     560:	8d 87       	std	Y+13, r24	; 0x0d
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <DELAY_us+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	4f e7       	ldi	r20, 0x7F	; 127
     56a:	53 e4       	ldi	r21, 0x43	; 67
     56c:	6d 81       	ldd	r22, Y+5	; 0x05
     56e:	7e 81       	ldd	r23, Y+6	; 0x06
     570:	8f 81       	ldd	r24, Y+7	; 0x07
     572:	98 85       	ldd	r25, Y+8	; 0x08
     574:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     578:	18 16       	cp	r1, r24
     57a:	ac f4       	brge	.+42     	; 0x5a6 <DELAY_us+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
     57c:	69 85       	ldd	r22, Y+9	; 0x09
     57e:	7a 85       	ldd	r23, Y+10	; 0x0a
     580:	8b 85       	ldd	r24, Y+11	; 0x0b
     582:	9c 85       	ldd	r25, Y+12	; 0x0c
     584:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     588:	dc 01       	movw	r26, r24
     58a:	cb 01       	movw	r24, r22
     58c:	9d 8f       	std	Y+29, r25	; 0x1d
     58e:	8c 8f       	std	Y+28, r24	; 0x1c
     590:	8c 8d       	ldd	r24, Y+28	; 0x1c
     592:	9d 8d       	ldd	r25, Y+29	; 0x1d
     594:	9f 8f       	std	Y+31, r25	; 0x1f
     596:	8e 8f       	std	Y+30, r24	; 0x1e
     598:	8e 8d       	ldd	r24, Y+30	; 0x1e
     59a:	9f 8d       	ldd	r25, Y+31	; 0x1f
     59c:	01 97       	sbiw	r24, 0x01	; 1
     59e:	f1 f7       	brne	.-4      	; 0x59c <DELAY_us+0x1d8>
     5a0:	9f 8f       	std	Y+31, r25	; 0x1f
     5a2:	8e 8f       	std	Y+30, r24	; 0x1e
     5a4:	0f c0       	rjmp	.+30     	; 0x5c4 <DELAY_us+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     5a6:	6d 81       	ldd	r22, Y+5	; 0x05
     5a8:	7e 81       	ldd	r23, Y+6	; 0x06
     5aa:	8f 81       	ldd	r24, Y+7	; 0x07
     5ac:	98 85       	ldd	r25, Y+8	; 0x08
     5ae:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     5b2:	dc 01       	movw	r26, r24
     5b4:	cb 01       	movw	r24, r22
     5b6:	8d 87       	std	Y+13, r24	; 0x0d
     5b8:	8d 85       	ldd	r24, Y+13	; 0x0d
     5ba:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     5bc:	88 a1       	ldd	r24, Y+32	; 0x20
     5be:	8a 95       	dec	r24
     5c0:	f1 f7       	brne	.-4      	; 0x5be <DELAY_us+0x1fa>
     5c2:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1);
		us_count--;
     5c4:	8a a1       	ldd	r24, Y+34	; 0x22
     5c6:	9b a1       	ldd	r25, Y+35	; 0x23
     5c8:	01 97       	sbiw	r24, 0x01	; 1
     5ca:	9b a3       	std	Y+35, r25	; 0x23
     5cc:	8a a3       	std	Y+34, r24	; 0x22
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
     5ce:	8a a1       	ldd	r24, Y+34	; 0x22
     5d0:	9b a1       	ldd	r25, Y+35	; 0x23
     5d2:	00 97       	sbiw	r24, 0x00	; 0
     5d4:	09 f0       	breq	.+2      	; 0x5d8 <DELAY_us+0x214>
     5d6:	03 cf       	rjmp	.-506    	; 0x3de <DELAY_us+0x1a>
    {
        _delay_us(1);
		us_count--;
    }
}
     5d8:	a3 96       	adiw	r28, 0x23	; 35
     5da:	0f b6       	in	r0, 0x3f	; 63
     5dc:	f8 94       	cli
     5de:	de bf       	out	0x3e, r29	; 62
     5e0:	0f be       	out	0x3f, r0	; 63
     5e2:	cd bf       	out	0x3d, r28	; 61
     5e4:	df 91       	pop	r29
     5e6:	cf 91       	pop	r28
     5e8:	08 95       	ret

000005ea <DELAY_ms>:
     This function is used generate delay in ms.
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	cd b7       	in	r28, 0x3d	; 61
     5f0:	de b7       	in	r29, 0x3e	; 62
     5f2:	a3 97       	sbiw	r28, 0x23	; 35
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	9b a3       	std	Y+35, r25	; 0x23
     600:	8a a3       	std	Y+34, r24	; 0x22
    while (ms_count != 0) 
     602:	f8 c0       	rjmp	.+496    	; 0x7f4 <DELAY_ms+0x20a>
     604:	80 e0       	ldi	r24, 0x00	; 0
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	aa e7       	ldi	r26, 0x7A	; 122
     60a:	b4 e4       	ldi	r27, 0x44	; 68
     60c:	89 83       	std	Y+1, r24	; 0x01
     60e:	9a 83       	std	Y+2, r25	; 0x02
     610:	ab 83       	std	Y+3, r26	; 0x03
     612:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
     614:	29 e8       	ldi	r18, 0x89	; 137
     616:	38 e8       	ldi	r19, 0x88	; 136
     618:	48 e0       	ldi	r20, 0x08	; 8
     61a:	5f e3       	ldi	r21, 0x3F	; 63
     61c:	69 81       	ldd	r22, Y+1	; 0x01
     61e:	7a 81       	ldd	r23, Y+2	; 0x02
     620:	8b 81       	ldd	r24, Y+3	; 0x03
     622:	9c 81       	ldd	r25, Y+4	; 0x04
     624:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     628:	dc 01       	movw	r26, r24
     62a:	cb 01       	movw	r24, r22
     62c:	8d 83       	std	Y+5, r24	; 0x05
     62e:	9e 83       	std	Y+6, r25	; 0x06
     630:	af 83       	std	Y+7, r26	; 0x07
     632:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
     634:	2d ec       	ldi	r18, 0xCD	; 205
     636:	3c ec       	ldi	r19, 0xCC	; 204
     638:	4c ec       	ldi	r20, 0xCC	; 204
     63a:	5e e3       	ldi	r21, 0x3E	; 62
     63c:	69 81       	ldd	r22, Y+1	; 0x01
     63e:	7a 81       	ldd	r23, Y+2	; 0x02
     640:	8b 81       	ldd	r24, Y+3	; 0x03
     642:	9c 81       	ldd	r25, Y+4	; 0x04
     644:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     648:	dc 01       	movw	r26, r24
     64a:	cb 01       	movw	r24, r22
     64c:	89 87       	std	Y+9, r24	; 0x09
     64e:	9a 87       	std	Y+10, r25	; 0x0a
     650:	ab 87       	std	Y+11, r26	; 0x0b
     652:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	40 e8       	ldi	r20, 0x80	; 128
     65a:	5f e3       	ldi	r21, 0x3F	; 63
     65c:	6d 81       	ldd	r22, Y+5	; 0x05
     65e:	7e 81       	ldd	r23, Y+6	; 0x06
     660:	8f 81       	ldd	r24, Y+7	; 0x07
     662:	98 85       	ldd	r25, Y+8	; 0x08
     664:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__cmpsf2>
     668:	88 23       	and	r24, r24
     66a:	1c f4       	brge	.+6      	; 0x672 <DELAY_ms+0x88>
		__ticks = 1;
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	8d 87       	std	Y+13, r24	; 0x0d
     670:	b6 c0       	rjmp	.+364    	; 0x7de <DELAY_ms+0x1f4>
	else if (__tmp2 > 65535)
     672:	20 e0       	ldi	r18, 0x00	; 0
     674:	3f ef       	ldi	r19, 0xFF	; 255
     676:	4f e7       	ldi	r20, 0x7F	; 127
     678:	57 e4       	ldi	r21, 0x47	; 71
     67a:	69 85       	ldd	r22, Y+9	; 0x09
     67c:	7a 85       	ldd	r23, Y+10	; 0x0a
     67e:	8b 85       	ldd	r24, Y+11	; 0x0b
     680:	9c 85       	ldd	r25, Y+12	; 0x0c
     682:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     686:	18 16       	cp	r1, r24
     688:	0c f0       	brlt	.+2      	; 0x68c <DELAY_ms+0xa2>
     68a:	7f c0       	rjmp	.+254    	; 0x78a <DELAY_ms+0x1a0>
	{
		_delay_ms(__us / 1000.0);
     68c:	20 e0       	ldi	r18, 0x00	; 0
     68e:	30 e0       	ldi	r19, 0x00	; 0
     690:	4a e7       	ldi	r20, 0x7A	; 122
     692:	54 e4       	ldi	r21, 0x44	; 68
     694:	69 81       	ldd	r22, Y+1	; 0x01
     696:	7a 81       	ldd	r23, Y+2	; 0x02
     698:	8b 81       	ldd	r24, Y+3	; 0x03
     69a:	9c 81       	ldd	r25, Y+4	; 0x04
     69c:	0e 94 b6 1a 	call	0x356c	; 0x356c <__divsf3>
     6a0:	dc 01       	movw	r26, r24
     6a2:	cb 01       	movw	r24, r22
     6a4:	8e 87       	std	Y+14, r24	; 0x0e
     6a6:	9f 87       	std	Y+15, r25	; 0x0f
     6a8:	a8 8b       	std	Y+16, r26	; 0x10
     6aa:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	48 ec       	ldi	r20, 0xC8	; 200
     6b2:	53 e4       	ldi	r21, 0x43	; 67
     6b4:	6e 85       	ldd	r22, Y+14	; 0x0e
     6b6:	7f 85       	ldd	r23, Y+15	; 0x0f
     6b8:	88 89       	ldd	r24, Y+16	; 0x10
     6ba:	99 89       	ldd	r25, Y+17	; 0x11
     6bc:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     6c0:	dc 01       	movw	r26, r24
     6c2:	cb 01       	movw	r24, r22
     6c4:	8a 8b       	std	Y+18, r24	; 0x12
     6c6:	9b 8b       	std	Y+19, r25	; 0x13
     6c8:	ac 8b       	std	Y+20, r26	; 0x14
     6ca:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
     6cc:	20 e0       	ldi	r18, 0x00	; 0
     6ce:	30 e0       	ldi	r19, 0x00	; 0
     6d0:	40 e8       	ldi	r20, 0x80	; 128
     6d2:	5f e3       	ldi	r21, 0x3F	; 63
     6d4:	6a 89       	ldd	r22, Y+18	; 0x12
     6d6:	7b 89       	ldd	r23, Y+19	; 0x13
     6d8:	8c 89       	ldd	r24, Y+20	; 0x14
     6da:	9d 89       	ldd	r25, Y+21	; 0x15
     6dc:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__cmpsf2>
     6e0:	88 23       	and	r24, r24
     6e2:	2c f4       	brge	.+10     	; 0x6ee <DELAY_ms+0x104>
		__ticks = 1;
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	9f 8b       	std	Y+23, r25	; 0x17
     6ea:	8e 8b       	std	Y+22, r24	; 0x16
     6ec:	41 c0       	rjmp	.+130    	; 0x770 <DELAY_ms+0x186>
	else if (__tmp > 65535)
     6ee:	20 e0       	ldi	r18, 0x00	; 0
     6f0:	3f ef       	ldi	r19, 0xFF	; 255
     6f2:	4f e7       	ldi	r20, 0x7F	; 127
     6f4:	57 e4       	ldi	r21, 0x47	; 71
     6f6:	6a 89       	ldd	r22, Y+18	; 0x12
     6f8:	7b 89       	ldd	r23, Y+19	; 0x13
     6fa:	8c 89       	ldd	r24, Y+20	; 0x14
     6fc:	9d 89       	ldd	r25, Y+21	; 0x15
     6fe:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     702:	18 16       	cp	r1, r24
     704:	5c f5       	brge	.+86     	; 0x75c <DELAY_ms+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     706:	20 e0       	ldi	r18, 0x00	; 0
     708:	30 e0       	ldi	r19, 0x00	; 0
     70a:	40 e2       	ldi	r20, 0x20	; 32
     70c:	51 e4       	ldi	r21, 0x41	; 65
     70e:	6e 85       	ldd	r22, Y+14	; 0x0e
     710:	7f 85       	ldd	r23, Y+15	; 0x0f
     712:	88 89       	ldd	r24, Y+16	; 0x10
     714:	99 89       	ldd	r25, Y+17	; 0x11
     716:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
     71a:	dc 01       	movw	r26, r24
     71c:	cb 01       	movw	r24, r22
     71e:	bc 01       	movw	r22, r24
     720:	cd 01       	movw	r24, r26
     722:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     726:	dc 01       	movw	r26, r24
     728:	cb 01       	movw	r24, r22
     72a:	9f 8b       	std	Y+23, r25	; 0x17
     72c:	8e 8b       	std	Y+22, r24	; 0x16
     72e:	0f c0       	rjmp	.+30     	; 0x74e <DELAY_ms+0x164>
     730:	88 e2       	ldi	r24, 0x28	; 40
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	99 8f       	std	Y+25, r25	; 0x19
     736:	88 8f       	std	Y+24, r24	; 0x18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     738:	88 8d       	ldd	r24, Y+24	; 0x18
     73a:	99 8d       	ldd	r25, Y+25	; 0x19
     73c:	01 97       	sbiw	r24, 0x01	; 1
     73e:	f1 f7       	brne	.-4      	; 0x73c <DELAY_ms+0x152>
     740:	99 8f       	std	Y+25, r25	; 0x19
     742:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     744:	8e 89       	ldd	r24, Y+22	; 0x16
     746:	9f 89       	ldd	r25, Y+23	; 0x17
     748:	01 97       	sbiw	r24, 0x01	; 1
     74a:	9f 8b       	std	Y+23, r25	; 0x17
     74c:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     74e:	8e 89       	ldd	r24, Y+22	; 0x16
     750:	9f 89       	ldd	r25, Y+23	; 0x17
     752:	00 97       	sbiw	r24, 0x00	; 0
     754:	69 f7       	brne	.-38     	; 0x730 <DELAY_ms+0x146>
     756:	89 a1       	ldd	r24, Y+33	; 0x21
     758:	8d 87       	std	Y+13, r24	; 0x0d
     75a:	41 c0       	rjmp	.+130    	; 0x7de <DELAY_ms+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     75c:	6a 89       	ldd	r22, Y+18	; 0x12
     75e:	7b 89       	ldd	r23, Y+19	; 0x13
     760:	8c 89       	ldd	r24, Y+20	; 0x14
     762:	9d 89       	ldd	r25, Y+21	; 0x15
     764:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     768:	dc 01       	movw	r26, r24
     76a:	cb 01       	movw	r24, r22
     76c:	9f 8b       	std	Y+23, r25	; 0x17
     76e:	8e 8b       	std	Y+22, r24	; 0x16
     770:	8e 89       	ldd	r24, Y+22	; 0x16
     772:	9f 89       	ldd	r25, Y+23	; 0x17
     774:	9b 8f       	std	Y+27, r25	; 0x1b
     776:	8a 8f       	std	Y+26, r24	; 0x1a
     778:	8a 8d       	ldd	r24, Y+26	; 0x1a
     77a:	9b 8d       	ldd	r25, Y+27	; 0x1b
     77c:	01 97       	sbiw	r24, 0x01	; 1
     77e:	f1 f7       	brne	.-4      	; 0x77c <DELAY_ms+0x192>
     780:	9b 8f       	std	Y+27, r25	; 0x1b
     782:	8a 8f       	std	Y+26, r24	; 0x1a
     784:	89 a1       	ldd	r24, Y+33	; 0x21
     786:	8d 87       	std	Y+13, r24	; 0x0d
     788:	2a c0       	rjmp	.+84     	; 0x7de <DELAY_ms+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
     78a:	20 e0       	ldi	r18, 0x00	; 0
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	4f e7       	ldi	r20, 0x7F	; 127
     790:	53 e4       	ldi	r21, 0x43	; 67
     792:	6d 81       	ldd	r22, Y+5	; 0x05
     794:	7e 81       	ldd	r23, Y+6	; 0x06
     796:	8f 81       	ldd	r24, Y+7	; 0x07
     798:	98 85       	ldd	r25, Y+8	; 0x08
     79a:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
     79e:	18 16       	cp	r1, r24
     7a0:	ac f4       	brge	.+42     	; 0x7cc <DELAY_ms+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
     7a2:	69 85       	ldd	r22, Y+9	; 0x09
     7a4:	7a 85       	ldd	r23, Y+10	; 0x0a
     7a6:	8b 85       	ldd	r24, Y+11	; 0x0b
     7a8:	9c 85       	ldd	r25, Y+12	; 0x0c
     7aa:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     7ae:	dc 01       	movw	r26, r24
     7b0:	cb 01       	movw	r24, r22
     7b2:	9d 8f       	std	Y+29, r25	; 0x1d
     7b4:	8c 8f       	std	Y+28, r24	; 0x1c
     7b6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7b8:	9d 8d       	ldd	r25, Y+29	; 0x1d
     7ba:	9f 8f       	std	Y+31, r25	; 0x1f
     7bc:	8e 8f       	std	Y+30, r24	; 0x1e
     7be:	8e 8d       	ldd	r24, Y+30	; 0x1e
     7c0:	9f 8d       	ldd	r25, Y+31	; 0x1f
     7c2:	01 97       	sbiw	r24, 0x01	; 1
     7c4:	f1 f7       	brne	.-4      	; 0x7c2 <DELAY_ms+0x1d8>
     7c6:	9f 8f       	std	Y+31, r25	; 0x1f
     7c8:	8e 8f       	std	Y+30, r24	; 0x1e
     7ca:	0f c0       	rjmp	.+30     	; 0x7ea <DELAY_ms+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     7cc:	6d 81       	ldd	r22, Y+5	; 0x05
     7ce:	7e 81       	ldd	r23, Y+6	; 0x06
     7d0:	8f 81       	ldd	r24, Y+7	; 0x07
     7d2:	98 85       	ldd	r25, Y+8	; 0x08
     7d4:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     7d8:	dc 01       	movw	r26, r24
     7da:	cb 01       	movw	r24, r22
     7dc:	8d 87       	std	Y+13, r24	; 0x0d
     7de:	8d 85       	ldd	r24, Y+13	; 0x0d
     7e0:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     7e2:	88 a1       	ldd	r24, Y+32	; 0x20
     7e4:	8a 95       	dec	r24
     7e6:	f1 f7       	brne	.-4      	; 0x7e4 <DELAY_ms+0x1fa>
     7e8:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
     7ea:	8a a1       	ldd	r24, Y+34	; 0x22
     7ec:	9b a1       	ldd	r25, Y+35	; 0x23
     7ee:	01 97       	sbiw	r24, 0x01	; 1
     7f0:	9b a3       	std	Y+35, r25	; 0x23
     7f2:	8a a3       	std	Y+34, r24	; 0x22
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
     7f4:	8a a1       	ldd	r24, Y+34	; 0x22
     7f6:	9b a1       	ldd	r25, Y+35	; 0x23
     7f8:	00 97       	sbiw	r24, 0x00	; 0
     7fa:	09 f0       	breq	.+2      	; 0x7fe <DELAY_ms+0x214>
     7fc:	03 cf       	rjmp	.-506    	; 0x604 <DELAY_ms+0x1a>
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
    }
}
     7fe:	a3 96       	adiw	r28, 0x23	; 35
     800:	0f b6       	in	r0, 0x3f	; 63
     802:	f8 94       	cli
     804:	de bf       	out	0x3e, r29	; 62
     806:	0f be       	out	0x3f, r0	; 63
     808:	cd bf       	out	0x3d, r28	; 61
     80a:	df 91       	pop	r29
     80c:	cf 91       	pop	r28
     80e:	08 95       	ret

00000810 <EEPROM_WriteByte>:

 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t v_eepromAddress_u16, uint8_t v_eepromData_u8)
{
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	00 d0       	rcall	.+0      	; 0x816 <EEPROM_WriteByte+0x6>
     816:	1f 92       	push	r1
     818:	cd b7       	in	r28, 0x3d	; 61
     81a:	de b7       	in	r29, 0x3e	; 62
     81c:	9a 83       	std	Y+2, r25	; 0x02
     81e:	89 83       	std	Y+1, r24	; 0x01
     820:	6b 83       	std	Y+3, r22	; 0x03
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
     822:	00 00       	nop
     824:	8c e3       	ldi	r24, 0x3C	; 60
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	fc 01       	movw	r30, r24
     82a:	80 81       	ld	r24, Z
     82c:	88 2f       	mov	r24, r24
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	82 70       	andi	r24, 0x02	; 2
     832:	99 27       	eor	r25, r25
     834:	00 97       	sbiw	r24, 0x00	; 0
     836:	b1 f7       	brne	.-20     	; 0x824 <EEPROM_WriteByte+0x14>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = v_eepromAddress_u16;  //Load the eeprom address and data
     838:	8e e3       	ldi	r24, 0x3E	; 62
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	29 81       	ldd	r18, Y+1	; 0x01
     83e:	3a 81       	ldd	r19, Y+2	; 0x02
     840:	fc 01       	movw	r30, r24
     842:	31 83       	std	Z+1, r19	; 0x01
     844:	20 83       	st	Z, r18
	EEDR = v_eepromData_u8;
     846:	8d e3       	ldi	r24, 0x3D	; 61
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	2b 81       	ldd	r18, Y+3	; 0x03
     84c:	fc 01       	movw	r30, r24
     84e:	20 83       	st	Z, r18

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
     850:	8c e3       	ldi	r24, 0x3C	; 60
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	2c e3       	ldi	r18, 0x3C	; 60
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	f9 01       	movw	r30, r18
     85a:	20 81       	ld	r18, Z
     85c:	24 60       	ori	r18, 0x04	; 4
     85e:	fc 01       	movw	r30, r24
     860:	20 83       	st	Z, r18
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
     862:	8c e3       	ldi	r24, 0x3C	; 60
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	2c e3       	ldi	r18, 0x3C	; 60
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	f9 01       	movw	r30, r18
     86c:	20 81       	ld	r18, Z
     86e:	22 60       	ori	r18, 0x02	; 2
     870:	fc 01       	movw	r30, r24
     872:	20 83       	st	Z, r18
}
     874:	0f 90       	pop	r0
     876:	0f 90       	pop	r0
     878:	0f 90       	pop	r0
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	08 95       	ret

00000880 <EEPROM_ReadByte>:
 * Return value	: uint8_t: data read from Eeprom.

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t v_eepromAddress_u16)
{
     880:	cf 93       	push	r28
     882:	df 93       	push	r29
     884:	00 d0       	rcall	.+0      	; 0x886 <EEPROM_ReadByte+0x6>
     886:	cd b7       	in	r28, 0x3d	; 61
     888:	de b7       	in	r29, 0x3e	; 62
     88a:	9a 83       	std	Y+2, r25	; 0x02
     88c:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
     88e:	00 00       	nop
     890:	8c e3       	ldi	r24, 0x3C	; 60
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	fc 01       	movw	r30, r24
     896:	80 81       	ld	r24, Z
     898:	88 2f       	mov	r24, r24
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	82 70       	andi	r24, 0x02	; 2
     89e:	99 27       	eor	r25, r25
     8a0:	00 97       	sbiw	r24, 0x00	; 0
     8a2:	b1 f7       	brne	.-20     	; 0x890 <EEPROM_ReadByte+0x10>

	EEAR = v_eepromAddress_u16;    //Load the address from where the data needs to be read.
     8a4:	8e e3       	ldi	r24, 0x3E	; 62
     8a6:	90 e0       	ldi	r25, 0x00	; 0
     8a8:	29 81       	ldd	r18, Y+1	; 0x01
     8aa:	3a 81       	ldd	r19, Y+2	; 0x02
     8ac:	fc 01       	movw	r30, r24
     8ae:	31 83       	std	Z+1, r19	; 0x01
     8b0:	20 83       	st	Z, r18
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
     8b2:	8c e3       	ldi	r24, 0x3C	; 60
     8b4:	90 e0       	ldi	r25, 0x00	; 0
     8b6:	2c e3       	ldi	r18, 0x3C	; 60
     8b8:	30 e0       	ldi	r19, 0x00	; 0
     8ba:	f9 01       	movw	r30, r18
     8bc:	20 81       	ld	r18, Z
     8be:	21 60       	ori	r18, 0x01	; 1
     8c0:	fc 01       	movw	r30, r24
     8c2:	20 83       	st	Z, r18

	return EEDR;             // Return data from data register
     8c4:	8d e3       	ldi	r24, 0x3D	; 61
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	fc 01       	movw	r30, r24
     8ca:	80 81       	ld	r24, Z
}
     8cc:	0f 90       	pop	r0
     8ce:	0f 90       	pop	r0
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <EEPROM_WriteString>:

   NOTE: Null char is also written into the eeprom.
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_WriteString == 1)
void EEPROM_WriteString(uint16_t v_eepromAddress_u16, uint8_t *ptr_stringPointer_u8)
{
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	00 d0       	rcall	.+0      	; 0x8dc <EEPROM_WriteString+0x6>
     8dc:	00 d0       	rcall	.+0      	; 0x8de <EEPROM_WriteString+0x8>
     8de:	cd b7       	in	r28, 0x3d	; 61
     8e0:	de b7       	in	r29, 0x3e	; 62
     8e2:	9a 83       	std	Y+2, r25	; 0x02
     8e4:	89 83       	std	Y+1, r24	; 0x01
     8e6:	7c 83       	std	Y+4, r23	; 0x04
     8e8:	6b 83       	std	Y+3, r22	; 0x03
	do
	{
		EEPROM_WriteByte(v_eepromAddress_u16,*ptr_stringPointer_u8); //Write a byte from RAM to EEPROM
     8ea:	8b 81       	ldd	r24, Y+3	; 0x03
     8ec:	9c 81       	ldd	r25, Y+4	; 0x04
     8ee:	fc 01       	movw	r30, r24
     8f0:	20 81       	ld	r18, Z
     8f2:	89 81       	ldd	r24, Y+1	; 0x01
     8f4:	9a 81       	ldd	r25, Y+2	; 0x02
     8f6:	62 2f       	mov	r22, r18
     8f8:	0e 94 08 04 	call	0x810	; 0x810 <EEPROM_WriteByte>
		ptr_stringPointer_u8++;								//Increment the RAM Address
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	01 96       	adiw	r24, 0x01	; 1
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
		v_eepromAddress_u16++;								//Increment the Eeprom Address
     906:	89 81       	ldd	r24, Y+1	; 0x01
     908:	9a 81       	ldd	r25, Y+2	; 0x02
     90a:	01 96       	adiw	r24, 0x01	; 1
     90c:	9a 83       	std	Y+2, r25	; 0x02
     90e:	89 83       	std	Y+1, r24	; 0x01
	}while(*(ptr_stringPointer_u8-1) !=0);
     910:	8b 81       	ldd	r24, Y+3	; 0x03
     912:	9c 81       	ldd	r25, Y+4	; 0x04
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	fc 01       	movw	r30, r24
     918:	80 81       	ld	r24, Z
     91a:	88 23       	and	r24, r24
     91c:	31 f7       	brne	.-52     	; 0x8ea <EEPROM_WriteString+0x14>
}
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	0f 90       	pop	r0
     924:	0f 90       	pop	r0
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <EEPROM_ReadString>:
 * description:This function is used to Read a String from specified EEPROM_address.
           The string read from eeprom will be copied to specified buffer along with NULL character
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_ReadString == 1)
void EEPROM_ReadString(uint16_t v_eepromAddress_u16, uint8_t *ptr_destStringAddress_u8)
{
     92c:	cf 93       	push	r28
     92e:	df 93       	push	r29
     930:	00 d0       	rcall	.+0      	; 0x932 <EEPROM_ReadString+0x6>
     932:	00 d0       	rcall	.+0      	; 0x934 <EEPROM_ReadString+0x8>
     934:	1f 92       	push	r1
     936:	cd b7       	in	r28, 0x3d	; 61
     938:	de b7       	in	r29, 0x3e	; 62
     93a:	9b 83       	std	Y+3, r25	; 0x03
     93c:	8a 83       	std	Y+2, r24	; 0x02
     93e:	7d 83       	std	Y+5, r23	; 0x05
     940:	6c 83       	std	Y+4, r22	; 0x04
	char eeprom_data;

	do
	{
		eeprom_data = EEPROM_ReadByte(v_eepromAddress_u16); //Read a byte from EEPROM to RAM
     942:	8a 81       	ldd	r24, Y+2	; 0x02
     944:	9b 81       	ldd	r25, Y+3	; 0x03
     946:	0e 94 40 04 	call	0x880	; 0x880 <EEPROM_ReadByte>
     94a:	89 83       	std	Y+1, r24	; 0x01
		*ptr_destStringAddress_u8 = eeprom_data;			 //Copy the data into String Buffer
     94c:	8c 81       	ldd	r24, Y+4	; 0x04
     94e:	9d 81       	ldd	r25, Y+5	; 0x05
     950:	29 81       	ldd	r18, Y+1	; 0x01
     952:	fc 01       	movw	r30, r24
     954:	20 83       	st	Z, r18
		ptr_destStringAddress_u8++;						 //Increment the RAM Address
     956:	8c 81       	ldd	r24, Y+4	; 0x04
     958:	9d 81       	ldd	r25, Y+5	; 0x05
     95a:	01 96       	adiw	r24, 0x01	; 1
     95c:	9d 83       	std	Y+5, r25	; 0x05
     95e:	8c 83       	std	Y+4, r24	; 0x04
		v_eepromAddress_u16++;							 //Increment the Eeprom Address
     960:	8a 81       	ldd	r24, Y+2	; 0x02
     962:	9b 81       	ldd	r25, Y+3	; 0x03
     964:	01 96       	adiw	r24, 0x01	; 1
     966:	9b 83       	std	Y+3, r25	; 0x03
     968:	8a 83       	std	Y+2, r24	; 0x02
	}while(eeprom_data!=0);
     96a:	89 81       	ldd	r24, Y+1	; 0x01
     96c:	88 23       	and	r24, r24
     96e:	49 f7       	brne	.-46     	; 0x942 <EEPROM_ReadString+0x16>
}
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	0f 90       	pop	r0
     976:	0f 90       	pop	r0
     978:	0f 90       	pop	r0
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	08 95       	ret

00000980 <GPIO_PinDirection>:
 * Return value    : none

 * description :This function sets the specified direction as INPUT/OUTPUT.  
 ***************************************************************************************************/
void GPIO_PinDirection(gpioPins_et enm_pinNumber, uint8_t v_pinDirn_u8)
{
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	00 d0       	rcall	.+0      	; 0x986 <GPIO_PinDirection+0x6>
     986:	1f 92       	push	r1
     988:	cd b7       	in	r28, 0x3d	; 61
     98a:	de b7       	in	r29, 0x3e	; 62
     98c:	8a 83       	std	Y+2, r24	; 0x02
     98e:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     990:	8a 81       	ldd	r24, Y+2	; 0x02
     992:	86 95       	lsr	r24
     994:	86 95       	lsr	r24
     996:	86 95       	lsr	r24
     998:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     99a:	8a 81       	ldd	r24, Y+2	; 0x02
     99c:	87 70       	andi	r24, 0x07	; 7
     99e:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
     9a0:	89 81       	ldd	r24, Y+1	; 0x01
     9a2:	88 2f       	mov	r24, r24
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	81 30       	cpi	r24, 0x01	; 1
     9a8:	91 05       	cpc	r25, r1
     9aa:	09 f4       	brne	.+2      	; 0x9ae <GPIO_PinDirection+0x2e>
     9ac:	3f c0       	rjmp	.+126    	; 0xa2c <GPIO_PinDirection+0xac>
     9ae:	82 30       	cpi	r24, 0x02	; 2
     9b0:	91 05       	cpc	r25, r1
     9b2:	1c f4       	brge	.+6      	; 0x9ba <GPIO_PinDirection+0x3a>
     9b4:	00 97       	sbiw	r24, 0x00	; 0
     9b6:	51 f0       	breq	.+20     	; 0x9cc <GPIO_PinDirection+0x4c>
     9b8:	c9 c0       	rjmp	.+402    	; 0xb4c <GPIO_PinDirection+0x1cc>
     9ba:	82 30       	cpi	r24, 0x02	; 2
     9bc:	91 05       	cpc	r25, r1
     9be:	09 f4       	brne	.+2      	; 0x9c2 <GPIO_PinDirection+0x42>
     9c0:	65 c0       	rjmp	.+202    	; 0xa8c <GPIO_PinDirection+0x10c>
     9c2:	83 30       	cpi	r24, 0x03	; 3
     9c4:	91 05       	cpc	r25, r1
     9c6:	09 f4       	brne	.+2      	; 0x9ca <GPIO_PinDirection+0x4a>
     9c8:	91 c0       	rjmp	.+290    	; 0xaec <GPIO_PinDirection+0x16c>
     9ca:	c0 c0       	rjmp	.+384    	; 0xb4c <GPIO_PinDirection+0x1cc>
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	88 23       	and	r24, r24
     9d0:	b1 f0       	breq	.+44     	; 0x9fe <GPIO_PinDirection+0x7e>
     9d2:	8a e3       	ldi	r24, 0x3A	; 58
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	2a e3       	ldi	r18, 0x3A	; 58
     9d8:	30 e0       	ldi	r19, 0x00	; 0
     9da:	f9 01       	movw	r30, r18
     9dc:	20 81       	ld	r18, Z
     9de:	62 2f       	mov	r22, r18
     9e0:	2a 81       	ldd	r18, Y+2	; 0x02
     9e2:	42 2f       	mov	r20, r18
     9e4:	50 e0       	ldi	r21, 0x00	; 0
     9e6:	21 e0       	ldi	r18, 0x01	; 1
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	04 2e       	mov	r0, r20
     9ec:	02 c0       	rjmp	.+4      	; 0x9f2 <GPIO_PinDirection+0x72>
     9ee:	22 0f       	add	r18, r18
     9f0:	33 1f       	adc	r19, r19
     9f2:	0a 94       	dec	r0
     9f4:	e2 f7       	brpl	.-8      	; 0x9ee <GPIO_PinDirection+0x6e>
     9f6:	26 2b       	or	r18, r22
     9f8:	fc 01       	movw	r30, r24
     9fa:	20 83       	st	Z, r18
        break;
     9fc:	a7 c0       	rjmp	.+334    	; 0xb4c <GPIO_PinDirection+0x1cc>
        set the direction as specified*/
    switch(v_portNumber_u8)
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
     9fe:	8a e3       	ldi	r24, 0x3A	; 58
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	2a e3       	ldi	r18, 0x3A	; 58
     a04:	30 e0       	ldi	r19, 0x00	; 0
     a06:	f9 01       	movw	r30, r18
     a08:	20 81       	ld	r18, Z
     a0a:	62 2f       	mov	r22, r18
     a0c:	2a 81       	ldd	r18, Y+2	; 0x02
     a0e:	42 2f       	mov	r20, r18
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	21 e0       	ldi	r18, 0x01	; 1
     a14:	30 e0       	ldi	r19, 0x00	; 0
     a16:	04 2e       	mov	r0, r20
     a18:	02 c0       	rjmp	.+4      	; 0xa1e <GPIO_PinDirection+0x9e>
     a1a:	22 0f       	add	r18, r18
     a1c:	33 1f       	adc	r19, r19
     a1e:	0a 94       	dec	r0
     a20:	e2 f7       	brpl	.-8      	; 0xa1a <GPIO_PinDirection+0x9a>
     a22:	20 95       	com	r18
     a24:	26 23       	and	r18, r22
     a26:	fc 01       	movw	r30, r24
     a28:	20 83       	st	Z, r18
        break;
     a2a:	90 c0       	rjmp	.+288    	; 0xb4c <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     a2c:	8b 81       	ldd	r24, Y+3	; 0x03
     a2e:	88 23       	and	r24, r24
     a30:	b1 f0       	breq	.+44     	; 0xa5e <GPIO_PinDirection+0xde>
     a32:	87 e3       	ldi	r24, 0x37	; 55
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	27 e3       	ldi	r18, 0x37	; 55
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	f9 01       	movw	r30, r18
     a3c:	20 81       	ld	r18, Z
     a3e:	62 2f       	mov	r22, r18
     a40:	2a 81       	ldd	r18, Y+2	; 0x02
     a42:	42 2f       	mov	r20, r18
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	21 e0       	ldi	r18, 0x01	; 1
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	04 2e       	mov	r0, r20
     a4c:	02 c0       	rjmp	.+4      	; 0xa52 <GPIO_PinDirection+0xd2>
     a4e:	22 0f       	add	r18, r18
     a50:	33 1f       	adc	r19, r19
     a52:	0a 94       	dec	r0
     a54:	e2 f7       	brpl	.-8      	; 0xa4e <GPIO_PinDirection+0xce>
     a56:	26 2b       	or	r18, r22
     a58:	fc 01       	movw	r30, r24
     a5a:	20 83       	st	Z, r18
        break;
     a5c:	77 c0       	rjmp	.+238    	; 0xb4c <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     a5e:	87 e3       	ldi	r24, 0x37	; 55
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	27 e3       	ldi	r18, 0x37	; 55
     a64:	30 e0       	ldi	r19, 0x00	; 0
     a66:	f9 01       	movw	r30, r18
     a68:	20 81       	ld	r18, Z
     a6a:	62 2f       	mov	r22, r18
     a6c:	2a 81       	ldd	r18, Y+2	; 0x02
     a6e:	42 2f       	mov	r20, r18
     a70:	50 e0       	ldi	r21, 0x00	; 0
     a72:	21 e0       	ldi	r18, 0x01	; 1
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	04 2e       	mov	r0, r20
     a78:	02 c0       	rjmp	.+4      	; 0xa7e <GPIO_PinDirection+0xfe>
     a7a:	22 0f       	add	r18, r18
     a7c:	33 1f       	adc	r19, r19
     a7e:	0a 94       	dec	r0
     a80:	e2 f7       	brpl	.-8      	; 0xa7a <GPIO_PinDirection+0xfa>
     a82:	20 95       	com	r18
     a84:	26 23       	and	r18, r22
     a86:	fc 01       	movw	r30, r24
     a88:	20 83       	st	Z, r18
        break;
     a8a:	60 c0       	rjmp	.+192    	; 0xb4c <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     a8c:	8b 81       	ldd	r24, Y+3	; 0x03
     a8e:	88 23       	and	r24, r24
     a90:	b1 f0       	breq	.+44     	; 0xabe <GPIO_PinDirection+0x13e>
     a92:	84 e3       	ldi	r24, 0x34	; 52
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	24 e3       	ldi	r18, 0x34	; 52
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	f9 01       	movw	r30, r18
     a9c:	20 81       	ld	r18, Z
     a9e:	62 2f       	mov	r22, r18
     aa0:	2a 81       	ldd	r18, Y+2	; 0x02
     aa2:	42 2f       	mov	r20, r18
     aa4:	50 e0       	ldi	r21, 0x00	; 0
     aa6:	21 e0       	ldi	r18, 0x01	; 1
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	04 2e       	mov	r0, r20
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <GPIO_PinDirection+0x132>
     aae:	22 0f       	add	r18, r18
     ab0:	33 1f       	adc	r19, r19
     ab2:	0a 94       	dec	r0
     ab4:	e2 f7       	brpl	.-8      	; 0xaae <GPIO_PinDirection+0x12e>
     ab6:	26 2b       	or	r18, r22
     ab8:	fc 01       	movw	r30, r24
     aba:	20 83       	st	Z, r18
        break;
     abc:	47 c0       	rjmp	.+142    	; 0xb4c <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     abe:	84 e3       	ldi	r24, 0x34	; 52
     ac0:	90 e0       	ldi	r25, 0x00	; 0
     ac2:	24 e3       	ldi	r18, 0x34	; 52
     ac4:	30 e0       	ldi	r19, 0x00	; 0
     ac6:	f9 01       	movw	r30, r18
     ac8:	20 81       	ld	r18, Z
     aca:	62 2f       	mov	r22, r18
     acc:	2a 81       	ldd	r18, Y+2	; 0x02
     ace:	42 2f       	mov	r20, r18
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	21 e0       	ldi	r18, 0x01	; 1
     ad4:	30 e0       	ldi	r19, 0x00	; 0
     ad6:	04 2e       	mov	r0, r20
     ad8:	02 c0       	rjmp	.+4      	; 0xade <GPIO_PinDirection+0x15e>
     ada:	22 0f       	add	r18, r18
     adc:	33 1f       	adc	r19, r19
     ade:	0a 94       	dec	r0
     ae0:	e2 f7       	brpl	.-8      	; 0xada <GPIO_PinDirection+0x15a>
     ae2:	20 95       	com	r18
     ae4:	26 23       	and	r18, r22
     ae6:	fc 01       	movw	r30, r24
     ae8:	20 83       	st	Z, r18
        break;
     aea:	30 c0       	rjmp	.+96     	; 0xb4c <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
     aec:	8b 81       	ldd	r24, Y+3	; 0x03
     aee:	88 23       	and	r24, r24
     af0:	b1 f0       	breq	.+44     	; 0xb1e <GPIO_PinDirection+0x19e>
     af2:	81 e3       	ldi	r24, 0x31	; 49
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	21 e3       	ldi	r18, 0x31	; 49
     af8:	30 e0       	ldi	r19, 0x00	; 0
     afa:	f9 01       	movw	r30, r18
     afc:	20 81       	ld	r18, Z
     afe:	62 2f       	mov	r22, r18
     b00:	2a 81       	ldd	r18, Y+2	; 0x02
     b02:	42 2f       	mov	r20, r18
     b04:	50 e0       	ldi	r21, 0x00	; 0
     b06:	21 e0       	ldi	r18, 0x01	; 1
     b08:	30 e0       	ldi	r19, 0x00	; 0
     b0a:	04 2e       	mov	r0, r20
     b0c:	02 c0       	rjmp	.+4      	; 0xb12 <GPIO_PinDirection+0x192>
     b0e:	22 0f       	add	r18, r18
     b10:	33 1f       	adc	r19, r19
     b12:	0a 94       	dec	r0
     b14:	e2 f7       	brpl	.-8      	; 0xb0e <GPIO_PinDirection+0x18e>
     b16:	26 2b       	or	r18, r22
     b18:	fc 01       	movw	r30, r24
     b1a:	20 83       	st	Z, r18
     b1c:	16 c0       	rjmp	.+44     	; 0xb4a <GPIO_PinDirection+0x1ca>
     b1e:	81 e3       	ldi	r24, 0x31	; 49
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	21 e3       	ldi	r18, 0x31	; 49
     b24:	30 e0       	ldi	r19, 0x00	; 0
     b26:	f9 01       	movw	r30, r18
     b28:	20 81       	ld	r18, Z
     b2a:	62 2f       	mov	r22, r18
     b2c:	2a 81       	ldd	r18, Y+2	; 0x02
     b2e:	42 2f       	mov	r20, r18
     b30:	50 e0       	ldi	r21, 0x00	; 0
     b32:	21 e0       	ldi	r18, 0x01	; 1
     b34:	30 e0       	ldi	r19, 0x00	; 0
     b36:	04 2e       	mov	r0, r20
     b38:	02 c0       	rjmp	.+4      	; 0xb3e <GPIO_PinDirection+0x1be>
     b3a:	22 0f       	add	r18, r18
     b3c:	33 1f       	adc	r19, r19
     b3e:	0a 94       	dec	r0
     b40:	e2 f7       	brpl	.-8      	; 0xb3a <GPIO_PinDirection+0x1ba>
     b42:	20 95       	com	r18
     b44:	26 23       	and	r18, r22
     b46:	fc 01       	movw	r30, r24
     b48:	20 83       	st	Z, r18
        break;
     b4a:	00 00       	nop
    case 6:
        util_UpdateBit(DDRG,enm_pinNumber,v_pinDirn_u8);
        break;
#endif    
    }                
}
     b4c:	0f 90       	pop	r0
     b4e:	0f 90       	pop	r0
     b50:	0f 90       	pop	r0
     b52:	df 91       	pop	r29
     b54:	cf 91       	pop	r28
     b56:	08 95       	ret

00000b58 <GPIO_PinWrite>:
 * description :This function updates the specified value on the selected pin.  
                Before updating the pins status, the pin function should be selected and then
                the pin should be configured as OUTPUT 
***************************************************************************************************/
void GPIO_PinWrite(gpioPins_et enm_pinNumber, uint8_t v_pinValue_u8)
{
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	00 d0       	rcall	.+0      	; 0xb5e <GPIO_PinWrite+0x6>
     b5e:	1f 92       	push	r1
     b60:	cd b7       	in	r28, 0x3d	; 61
     b62:	de b7       	in	r29, 0x3e	; 62
     b64:	8a 83       	std	Y+2, r24	; 0x02
     b66:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     b68:	8a 81       	ldd	r24, Y+2	; 0x02
     b6a:	86 95       	lsr	r24
     b6c:	86 95       	lsr	r24
     b6e:	86 95       	lsr	r24
     b70:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     b72:	8a 81       	ldd	r24, Y+2	; 0x02
     b74:	87 70       	andi	r24, 0x07	; 7
     b76:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
     b78:	89 81       	ldd	r24, Y+1	; 0x01
     b7a:	88 2f       	mov	r24, r24
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	81 30       	cpi	r24, 0x01	; 1
     b80:	91 05       	cpc	r25, r1
     b82:	09 f4       	brne	.+2      	; 0xb86 <GPIO_PinWrite+0x2e>
     b84:	3f c0       	rjmp	.+126    	; 0xc04 <GPIO_PinWrite+0xac>
     b86:	82 30       	cpi	r24, 0x02	; 2
     b88:	91 05       	cpc	r25, r1
     b8a:	1c f4       	brge	.+6      	; 0xb92 <GPIO_PinWrite+0x3a>
     b8c:	00 97       	sbiw	r24, 0x00	; 0
     b8e:	51 f0       	breq	.+20     	; 0xba4 <GPIO_PinWrite+0x4c>
     b90:	c9 c0       	rjmp	.+402    	; 0xd24 <GPIO_PinWrite+0x1cc>
     b92:	82 30       	cpi	r24, 0x02	; 2
     b94:	91 05       	cpc	r25, r1
     b96:	09 f4       	brne	.+2      	; 0xb9a <GPIO_PinWrite+0x42>
     b98:	65 c0       	rjmp	.+202    	; 0xc64 <GPIO_PinWrite+0x10c>
     b9a:	83 30       	cpi	r24, 0x03	; 3
     b9c:	91 05       	cpc	r25, r1
     b9e:	09 f4       	brne	.+2      	; 0xba2 <GPIO_PinWrite+0x4a>
     ba0:	91 c0       	rjmp	.+290    	; 0xcc4 <GPIO_PinWrite+0x16c>
     ba2:	c0 c0       	rjmp	.+384    	; 0xd24 <GPIO_PinWrite+0x1cc>
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     ba4:	8b 81       	ldd	r24, Y+3	; 0x03
     ba6:	88 23       	and	r24, r24
     ba8:	b1 f0       	breq	.+44     	; 0xbd6 <GPIO_PinWrite+0x7e>
     baa:	8b e3       	ldi	r24, 0x3B	; 59
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	2b e3       	ldi	r18, 0x3B	; 59
     bb0:	30 e0       	ldi	r19, 0x00	; 0
     bb2:	f9 01       	movw	r30, r18
     bb4:	20 81       	ld	r18, Z
     bb6:	62 2f       	mov	r22, r18
     bb8:	2a 81       	ldd	r18, Y+2	; 0x02
     bba:	42 2f       	mov	r20, r18
     bbc:	50 e0       	ldi	r21, 0x00	; 0
     bbe:	21 e0       	ldi	r18, 0x01	; 1
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	04 2e       	mov	r0, r20
     bc4:	02 c0       	rjmp	.+4      	; 0xbca <GPIO_PinWrite+0x72>
     bc6:	22 0f       	add	r18, r18
     bc8:	33 1f       	adc	r19, r19
     bca:	0a 94       	dec	r0
     bcc:	e2 f7       	brpl	.-8      	; 0xbc6 <GPIO_PinWrite+0x6e>
     bce:	26 2b       	or	r18, r22
     bd0:	fc 01       	movw	r30, r24
     bd2:	20 83       	st	Z, r18
        break;
     bd4:	a7 c0       	rjmp	.+334    	; 0xd24 <GPIO_PinWrite+0x1cc>
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     bd6:	8b e3       	ldi	r24, 0x3B	; 59
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	2b e3       	ldi	r18, 0x3B	; 59
     bdc:	30 e0       	ldi	r19, 0x00	; 0
     bde:	f9 01       	movw	r30, r18
     be0:	20 81       	ld	r18, Z
     be2:	62 2f       	mov	r22, r18
     be4:	2a 81       	ldd	r18, Y+2	; 0x02
     be6:	42 2f       	mov	r20, r18
     be8:	50 e0       	ldi	r21, 0x00	; 0
     bea:	21 e0       	ldi	r18, 0x01	; 1
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	04 2e       	mov	r0, r20
     bf0:	02 c0       	rjmp	.+4      	; 0xbf6 <GPIO_PinWrite+0x9e>
     bf2:	22 0f       	add	r18, r18
     bf4:	33 1f       	adc	r19, r19
     bf6:	0a 94       	dec	r0
     bf8:	e2 f7       	brpl	.-8      	; 0xbf2 <GPIO_PinWrite+0x9a>
     bfa:	20 95       	com	r18
     bfc:	26 23       	and	r18, r22
     bfe:	fc 01       	movw	r30, r24
     c00:	20 83       	st	Z, r18
        break;
     c02:	90 c0       	rjmp	.+288    	; 0xd24 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     c04:	8b 81       	ldd	r24, Y+3	; 0x03
     c06:	88 23       	and	r24, r24
     c08:	b1 f0       	breq	.+44     	; 0xc36 <GPIO_PinWrite+0xde>
     c0a:	88 e3       	ldi	r24, 0x38	; 56
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	28 e3       	ldi	r18, 0x38	; 56
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	f9 01       	movw	r30, r18
     c14:	20 81       	ld	r18, Z
     c16:	62 2f       	mov	r22, r18
     c18:	2a 81       	ldd	r18, Y+2	; 0x02
     c1a:	42 2f       	mov	r20, r18
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	21 e0       	ldi	r18, 0x01	; 1
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	04 2e       	mov	r0, r20
     c24:	02 c0       	rjmp	.+4      	; 0xc2a <GPIO_PinWrite+0xd2>
     c26:	22 0f       	add	r18, r18
     c28:	33 1f       	adc	r19, r19
     c2a:	0a 94       	dec	r0
     c2c:	e2 f7       	brpl	.-8      	; 0xc26 <GPIO_PinWrite+0xce>
     c2e:	26 2b       	or	r18, r22
     c30:	fc 01       	movw	r30, r24
     c32:	20 83       	st	Z, r18
        break;
     c34:	77 c0       	rjmp	.+238    	; 0xd24 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     c36:	88 e3       	ldi	r24, 0x38	; 56
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	28 e3       	ldi	r18, 0x38	; 56
     c3c:	30 e0       	ldi	r19, 0x00	; 0
     c3e:	f9 01       	movw	r30, r18
     c40:	20 81       	ld	r18, Z
     c42:	62 2f       	mov	r22, r18
     c44:	2a 81       	ldd	r18, Y+2	; 0x02
     c46:	42 2f       	mov	r20, r18
     c48:	50 e0       	ldi	r21, 0x00	; 0
     c4a:	21 e0       	ldi	r18, 0x01	; 1
     c4c:	30 e0       	ldi	r19, 0x00	; 0
     c4e:	04 2e       	mov	r0, r20
     c50:	02 c0       	rjmp	.+4      	; 0xc56 <GPIO_PinWrite+0xfe>
     c52:	22 0f       	add	r18, r18
     c54:	33 1f       	adc	r19, r19
     c56:	0a 94       	dec	r0
     c58:	e2 f7       	brpl	.-8      	; 0xc52 <GPIO_PinWrite+0xfa>
     c5a:	20 95       	com	r18
     c5c:	26 23       	and	r18, r22
     c5e:	fc 01       	movw	r30, r24
     c60:	20 83       	st	Z, r18
        break;
     c62:	60 c0       	rjmp	.+192    	; 0xd24 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	88 23       	and	r24, r24
     c68:	b1 f0       	breq	.+44     	; 0xc96 <GPIO_PinWrite+0x13e>
     c6a:	85 e3       	ldi	r24, 0x35	; 53
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	25 e3       	ldi	r18, 0x35	; 53
     c70:	30 e0       	ldi	r19, 0x00	; 0
     c72:	f9 01       	movw	r30, r18
     c74:	20 81       	ld	r18, Z
     c76:	62 2f       	mov	r22, r18
     c78:	2a 81       	ldd	r18, Y+2	; 0x02
     c7a:	42 2f       	mov	r20, r18
     c7c:	50 e0       	ldi	r21, 0x00	; 0
     c7e:	21 e0       	ldi	r18, 0x01	; 1
     c80:	30 e0       	ldi	r19, 0x00	; 0
     c82:	04 2e       	mov	r0, r20
     c84:	02 c0       	rjmp	.+4      	; 0xc8a <GPIO_PinWrite+0x132>
     c86:	22 0f       	add	r18, r18
     c88:	33 1f       	adc	r19, r19
     c8a:	0a 94       	dec	r0
     c8c:	e2 f7       	brpl	.-8      	; 0xc86 <GPIO_PinWrite+0x12e>
     c8e:	26 2b       	or	r18, r22
     c90:	fc 01       	movw	r30, r24
     c92:	20 83       	st	Z, r18
        break;
     c94:	47 c0       	rjmp	.+142    	; 0xd24 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     c96:	85 e3       	ldi	r24, 0x35	; 53
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	25 e3       	ldi	r18, 0x35	; 53
     c9c:	30 e0       	ldi	r19, 0x00	; 0
     c9e:	f9 01       	movw	r30, r18
     ca0:	20 81       	ld	r18, Z
     ca2:	62 2f       	mov	r22, r18
     ca4:	2a 81       	ldd	r18, Y+2	; 0x02
     ca6:	42 2f       	mov	r20, r18
     ca8:	50 e0       	ldi	r21, 0x00	; 0
     caa:	21 e0       	ldi	r18, 0x01	; 1
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	04 2e       	mov	r0, r20
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <GPIO_PinWrite+0x15e>
     cb2:	22 0f       	add	r18, r18
     cb4:	33 1f       	adc	r19, r19
     cb6:	0a 94       	dec	r0
     cb8:	e2 f7       	brpl	.-8      	; 0xcb2 <GPIO_PinWrite+0x15a>
     cba:	20 95       	com	r18
     cbc:	26 23       	and	r18, r22
     cbe:	fc 01       	movw	r30, r24
     cc0:	20 83       	st	Z, r18
        break;
     cc2:	30 c0       	rjmp	.+96     	; 0xd24 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
     cc4:	8b 81       	ldd	r24, Y+3	; 0x03
     cc6:	88 23       	and	r24, r24
     cc8:	b1 f0       	breq	.+44     	; 0xcf6 <GPIO_PinWrite+0x19e>
     cca:	82 e3       	ldi	r24, 0x32	; 50
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	22 e3       	ldi	r18, 0x32	; 50
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	f9 01       	movw	r30, r18
     cd4:	20 81       	ld	r18, Z
     cd6:	62 2f       	mov	r22, r18
     cd8:	2a 81       	ldd	r18, Y+2	; 0x02
     cda:	42 2f       	mov	r20, r18
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	21 e0       	ldi	r18, 0x01	; 1
     ce0:	30 e0       	ldi	r19, 0x00	; 0
     ce2:	04 2e       	mov	r0, r20
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <GPIO_PinWrite+0x192>
     ce6:	22 0f       	add	r18, r18
     ce8:	33 1f       	adc	r19, r19
     cea:	0a 94       	dec	r0
     cec:	e2 f7       	brpl	.-8      	; 0xce6 <GPIO_PinWrite+0x18e>
     cee:	26 2b       	or	r18, r22
     cf0:	fc 01       	movw	r30, r24
     cf2:	20 83       	st	Z, r18
     cf4:	16 c0       	rjmp	.+44     	; 0xd22 <GPIO_PinWrite+0x1ca>
     cf6:	82 e3       	ldi	r24, 0x32	; 50
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	22 e3       	ldi	r18, 0x32	; 50
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	f9 01       	movw	r30, r18
     d00:	20 81       	ld	r18, Z
     d02:	62 2f       	mov	r22, r18
     d04:	2a 81       	ldd	r18, Y+2	; 0x02
     d06:	42 2f       	mov	r20, r18
     d08:	50 e0       	ldi	r21, 0x00	; 0
     d0a:	21 e0       	ldi	r18, 0x01	; 1
     d0c:	30 e0       	ldi	r19, 0x00	; 0
     d0e:	04 2e       	mov	r0, r20
     d10:	02 c0       	rjmp	.+4      	; 0xd16 <GPIO_PinWrite+0x1be>
     d12:	22 0f       	add	r18, r18
     d14:	33 1f       	adc	r19, r19
     d16:	0a 94       	dec	r0
     d18:	e2 f7       	brpl	.-8      	; 0xd12 <GPIO_PinWrite+0x1ba>
     d1a:	20 95       	com	r18
     d1c:	26 23       	and	r18, r22
     d1e:	fc 01       	movw	r30, r24
     d20:	20 83       	st	Z, r18
        break;
     d22:	00 00       	nop
    case 6:
        util_UpdateBit(PORTG,enm_pinNumber,v_pinValue_u8);
        break;
#endif      
    }                
}
     d24:	0f 90       	pop	r0
     d26:	0f 90       	pop	r0
     d28:	0f 90       	pop	r0
     d2a:	df 91       	pop	r29
     d2c:	cf 91       	pop	r28
     d2e:	08 95       	ret

00000d30 <GPIO_PinRead>:

 * description :This function returns the status of the selected pin.
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
     d34:	00 d0       	rcall	.+0      	; 0xd36 <GPIO_PinRead+0x6>
     d36:	1f 92       	push	r1
     d38:	cd b7       	in	r28, 0x3d	; 61
     d3a:	de b7       	in	r29, 0x3e	; 62
     d3c:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
     d3e:	19 82       	std	Y+1, r1	; 0x01

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
     d40:	8b 81       	ldd	r24, Y+3	; 0x03
     d42:	86 95       	lsr	r24
     d44:	86 95       	lsr	r24
     d46:	86 95       	lsr	r24
     d48:	8a 83       	std	Y+2, r24	; 0x02
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
     d4a:	8b 81       	ldd	r24, Y+3	; 0x03
     d4c:	87 70       	andi	r24, 0x07	; 7
     d4e:	8b 83       	std	Y+3, r24	; 0x03

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	88 2f       	mov	r24, r24
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	81 30       	cpi	r24, 0x01	; 1
     d58:	91 05       	cpc	r25, r1
     d5a:	21 f1       	breq	.+72     	; 0xda4 <GPIO_PinRead+0x74>
     d5c:	82 30       	cpi	r24, 0x02	; 2
     d5e:	91 05       	cpc	r25, r1
     d60:	1c f4       	brge	.+6      	; 0xd68 <GPIO_PinRead+0x38>
     d62:	00 97       	sbiw	r24, 0x00	; 0
     d64:	49 f0       	breq	.+18     	; 0xd78 <GPIO_PinRead+0x48>
     d66:	60 c0       	rjmp	.+192    	; 0xe28 <GPIO_PinRead+0xf8>
     d68:	82 30       	cpi	r24, 0x02	; 2
     d6a:	91 05       	cpc	r25, r1
     d6c:	89 f1       	breq	.+98     	; 0xdd0 <GPIO_PinRead+0xa0>
     d6e:	83 30       	cpi	r24, 0x03	; 3
     d70:	91 05       	cpc	r25, r1
     d72:	09 f4       	brne	.+2      	; 0xd76 <GPIO_PinRead+0x46>
     d74:	43 c0       	rjmp	.+134    	; 0xdfc <GPIO_PinRead+0xcc>
     d76:	58 c0       	rjmp	.+176    	; 0xe28 <GPIO_PinRead+0xf8>
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
     d78:	89 e3       	ldi	r24, 0x39	; 57
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	fc 01       	movw	r30, r24
     d7e:	80 81       	ld	r24, Z
     d80:	88 2f       	mov	r24, r24
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	2b 81       	ldd	r18, Y+3	; 0x03
     d86:	22 2f       	mov	r18, r18
     d88:	30 e0       	ldi	r19, 0x00	; 0
     d8a:	02 c0       	rjmp	.+4      	; 0xd90 <GPIO_PinRead+0x60>
     d8c:	95 95       	asr	r25
     d8e:	87 95       	ror	r24
     d90:	2a 95       	dec	r18
     d92:	e2 f7       	brpl	.-8      	; 0xd8c <GPIO_PinRead+0x5c>
     d94:	81 70       	andi	r24, 0x01	; 1
     d96:	99 27       	eor	r25, r25
     d98:	21 e0       	ldi	r18, 0x01	; 1
     d9a:	00 97       	sbiw	r24, 0x00	; 0
     d9c:	09 f4       	brne	.+2      	; 0xda0 <GPIO_PinRead+0x70>
     d9e:	20 e0       	ldi	r18, 0x00	; 0
     da0:	29 83       	std	Y+1, r18	; 0x01
        break;
     da2:	42 c0       	rjmp	.+132    	; 0xe28 <GPIO_PinRead+0xf8>
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
     da4:	86 e3       	ldi	r24, 0x36	; 54
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	fc 01       	movw	r30, r24
     daa:	80 81       	ld	r24, Z
     dac:	88 2f       	mov	r24, r24
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	2b 81       	ldd	r18, Y+3	; 0x03
     db2:	22 2f       	mov	r18, r18
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	02 c0       	rjmp	.+4      	; 0xdbc <GPIO_PinRead+0x8c>
     db8:	95 95       	asr	r25
     dba:	87 95       	ror	r24
     dbc:	2a 95       	dec	r18
     dbe:	e2 f7       	brpl	.-8      	; 0xdb8 <GPIO_PinRead+0x88>
     dc0:	81 70       	andi	r24, 0x01	; 1
     dc2:	99 27       	eor	r25, r25
     dc4:	21 e0       	ldi	r18, 0x01	; 1
     dc6:	00 97       	sbiw	r24, 0x00	; 0
     dc8:	09 f4       	brne	.+2      	; 0xdcc <GPIO_PinRead+0x9c>
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	29 83       	std	Y+1, r18	; 0x01
        break;
     dce:	2c c0       	rjmp	.+88     	; 0xe28 <GPIO_PinRead+0xf8>
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
     dd0:	83 e3       	ldi	r24, 0x33	; 51
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	fc 01       	movw	r30, r24
     dd6:	80 81       	ld	r24, Z
     dd8:	88 2f       	mov	r24, r24
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	2b 81       	ldd	r18, Y+3	; 0x03
     dde:	22 2f       	mov	r18, r18
     de0:	30 e0       	ldi	r19, 0x00	; 0
     de2:	02 c0       	rjmp	.+4      	; 0xde8 <GPIO_PinRead+0xb8>
     de4:	95 95       	asr	r25
     de6:	87 95       	ror	r24
     de8:	2a 95       	dec	r18
     dea:	e2 f7       	brpl	.-8      	; 0xde4 <GPIO_PinRead+0xb4>
     dec:	81 70       	andi	r24, 0x01	; 1
     dee:	99 27       	eor	r25, r25
     df0:	21 e0       	ldi	r18, 0x01	; 1
     df2:	00 97       	sbiw	r24, 0x00	; 0
     df4:	09 f4       	brne	.+2      	; 0xdf8 <GPIO_PinRead+0xc8>
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	29 83       	std	Y+1, r18	; 0x01
        break;
     dfa:	16 c0       	rjmp	.+44     	; 0xe28 <GPIO_PinRead+0xf8>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     dfc:	80 e3       	ldi	r24, 0x30	; 48
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	fc 01       	movw	r30, r24
     e02:	80 81       	ld	r24, Z
     e04:	88 2f       	mov	r24, r24
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	2b 81       	ldd	r18, Y+3	; 0x03
     e0a:	22 2f       	mov	r18, r18
     e0c:	30 e0       	ldi	r19, 0x00	; 0
     e0e:	02 c0       	rjmp	.+4      	; 0xe14 <GPIO_PinRead+0xe4>
     e10:	95 95       	asr	r25
     e12:	87 95       	ror	r24
     e14:	2a 95       	dec	r18
     e16:	e2 f7       	brpl	.-8      	; 0xe10 <GPIO_PinRead+0xe0>
     e18:	81 70       	andi	r24, 0x01	; 1
     e1a:	99 27       	eor	r25, r25
     e1c:	21 e0       	ldi	r18, 0x01	; 1
     e1e:	00 97       	sbiw	r24, 0x00	; 0
     e20:	09 f4       	brne	.+2      	; 0xe24 <GPIO_PinRead+0xf4>
     e22:	20 e0       	ldi	r18, 0x00	; 0
     e24:	29 83       	std	Y+1, r18	; 0x01
        break;
     e26:	00 00       	nop
    case 6:
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
     e28:	89 81       	ldd	r24, Y+1	; 0x01
}
     e2a:	0f 90       	pop	r0
     e2c:	0f 90       	pop	r0
     e2e:	0f 90       	pop	r0
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	08 95       	ret

00000e36 <LCD_SetUp>:
 In case of four bit mode pass P_NC as parameter for D0-D3.
 If RW is not used then pass P_NC as parameter for RS.
 **************************************************************************************************/
void LCD_SetUp(gpioPins_et RS, gpioPins_et RW, gpioPins_et EN, gpioPins_et D0,
		gpioPins_et D1, gpioPins_et D2, gpioPins_et D3, gpioPins_et D4,
		gpioPins_et D5, gpioPins_et D6, gpioPins_et D7) {
     e36:	8f 92       	push	r8
     e38:	af 92       	push	r10
     e3a:	cf 92       	push	r12
     e3c:	ef 92       	push	r14
     e3e:	0f 93       	push	r16
     e40:	cf 93       	push	r28
     e42:	df 93       	push	r29
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	29 97       	sbiw	r28, 0x09	; 9
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	de bf       	out	0x3e, r29	; 62
     e50:	0f be       	out	0x3f, r0	; 63
     e52:	cd bf       	out	0x3d, r28	; 61
     e54:	89 83       	std	Y+1, r24	; 0x01
     e56:	6a 83       	std	Y+2, r22	; 0x02
     e58:	4b 83       	std	Y+3, r20	; 0x03
     e5a:	2c 83       	std	Y+4, r18	; 0x04
     e5c:	0d 83       	std	Y+5, r16	; 0x05
     e5e:	ee 82       	std	Y+6, r14	; 0x06
     e60:	cf 82       	std	Y+7, r12	; 0x07
     e62:	a8 86       	std	Y+8, r10	; 0x08
     e64:	89 86       	std	Y+9, r8	; 0x09
	/* Copy the PIN numbers where the LCD is connected */
	LCDConfig.RS = RS;
     e66:	89 81       	ldd	r24, Y+1	; 0x01
     e68:	80 93 d5 00 	sts	0x00D5, r24
	LCDConfig.RW = RW;
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
     e6e:	80 93 d6 00 	sts	0x00D6, r24
	LCDConfig.EN = EN;
     e72:	8b 81       	ldd	r24, Y+3	; 0x03
     e74:	80 93 d7 00 	sts	0x00D7, r24

	LCDConfig.D0 = D0;
     e78:	8c 81       	ldd	r24, Y+4	; 0x04
     e7a:	80 93 d8 00 	sts	0x00D8, r24
	LCDConfig.D1 = D1;
     e7e:	8d 81       	ldd	r24, Y+5	; 0x05
     e80:	80 93 d9 00 	sts	0x00D9, r24
	LCDConfig.D2 = D2;
     e84:	8e 81       	ldd	r24, Y+6	; 0x06
     e86:	80 93 da 00 	sts	0x00DA, r24
	LCDConfig.D3 = D3;
     e8a:	8f 81       	ldd	r24, Y+7	; 0x07
     e8c:	80 93 db 00 	sts	0x00DB, r24
	LCDConfig.D4 = D4;
     e90:	88 85       	ldd	r24, Y+8	; 0x08
     e92:	80 93 dc 00 	sts	0x00DC, r24
	LCDConfig.D5 = D5;
     e96:	89 85       	ldd	r24, Y+9	; 0x09
     e98:	80 93 dd 00 	sts	0x00DD, r24
	LCDConfig.D6 = D6;
     e9c:	8b 89       	ldd	r24, Y+19	; 0x13
     e9e:	80 93 de 00 	sts	0x00DE, r24
	LCDConfig.D7 = D7;
     ea2:	8c 89       	ldd	r24, Y+20	; 0x14
     ea4:	80 93 df 00 	sts	0x00DF, r24

	if ((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC)) {
     ea8:	8c 81       	ldd	r24, Y+4	; 0x04
     eaa:	8f 3f       	cpi	r24, 0xFF	; 255
     eac:	49 f0       	breq	.+18     	; 0xec0 <LCD_SetUp+0x8a>
     eae:	8d 81       	ldd	r24, Y+5	; 0x05
     eb0:	8f 3f       	cpi	r24, 0xFF	; 255
     eb2:	31 f0       	breq	.+12     	; 0xec0 <LCD_SetUp+0x8a>
     eb4:	8e 81       	ldd	r24, Y+6	; 0x06
     eb6:	8f 3f       	cpi	r24, 0xFF	; 255
     eb8:	19 f0       	breq	.+6      	; 0xec0 <LCD_SetUp+0x8a>
     eba:	8f 81       	ldd	r24, Y+7	; 0x07
     ebc:	8f 3f       	cpi	r24, 0xFF	; 255
     ebe:	21 f4       	brne	.+8      	; 0xec8 <LCD_SetUp+0x92>
		LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
     ec0:	84 e0       	ldi	r24, 0x04	; 4
     ec2:	80 93 d4 00 	sts	0x00D4, r24
     ec6:	13 c0       	rjmp	.+38     	; 0xeee <LCD_SetUp+0xb8>
	} else {
		LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.
     ec8:	88 e0       	ldi	r24, 0x08	; 8
     eca:	80 93 d4 00 	sts	0x00D4, r24
		GPIO_PinDirection(D0, OUTPUT);
     ece:	61 e0       	ldi	r22, 0x01	; 1
     ed0:	8c 81       	ldd	r24, Y+4	; 0x04
     ed2:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
		GPIO_PinDirection(D1, OUTPUT);
     ed6:	61 e0       	ldi	r22, 0x01	; 1
     ed8:	8d 81       	ldd	r24, Y+5	; 0x05
     eda:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
		GPIO_PinDirection(D2, OUTPUT);
     ede:	61 e0       	ldi	r22, 0x01	; 1
     ee0:	8e 81       	ldd	r24, Y+6	; 0x06
     ee2:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
		GPIO_PinDirection(D3, OUTPUT);
     ee6:	61 e0       	ldi	r22, 0x01	; 1
     ee8:	8f 81       	ldd	r24, Y+7	; 0x07
     eea:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	}

	/* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
	GPIO_PinDirection(RS, OUTPUT);
     eee:	61 e0       	ldi	r22, 0x01	; 1
     ef0:	89 81       	ldd	r24, Y+1	; 0x01
     ef2:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	GPIO_PinDirection(RW, OUTPUT);
     ef6:	61 e0       	ldi	r22, 0x01	; 1
     ef8:	8a 81       	ldd	r24, Y+2	; 0x02
     efa:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	GPIO_PinDirection(EN, OUTPUT);
     efe:	61 e0       	ldi	r22, 0x01	; 1
     f00:	8b 81       	ldd	r24, Y+3	; 0x03
     f02:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>

	GPIO_PinDirection(D4, OUTPUT);
     f06:	61 e0       	ldi	r22, 0x01	; 1
     f08:	88 85       	ldd	r24, Y+8	; 0x08
     f0a:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	GPIO_PinDirection(D5, OUTPUT);
     f0e:	61 e0       	ldi	r22, 0x01	; 1
     f10:	89 85       	ldd	r24, Y+9	; 0x09
     f12:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	GPIO_PinDirection(D6, OUTPUT);
     f16:	61 e0       	ldi	r22, 0x01	; 1
     f18:	8b 89       	ldd	r24, Y+19	; 0x13
     f1a:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
	GPIO_PinDirection(D7, OUTPUT);
     f1e:	61 e0       	ldi	r22, 0x01	; 1
     f20:	8c 89       	ldd	r24, Y+20	; 0x14
     f22:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
}
     f26:	29 96       	adiw	r28, 0x09	; 9
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	cd bf       	out	0x3d, r28	; 61
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	0f 91       	pop	r16
     f38:	ef 90       	pop	r14
     f3a:	cf 90       	pop	r12
     f3c:	af 90       	pop	r10
     f3e:	8f 90       	pop	r8
     f40:	08 95       	ret

00000f42 <LCD_Init>:
 * Return value    : none

 * description  :This function is used to initialize the lcd.
 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
 **************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8) {
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	00 d0       	rcall	.+0      	; 0xf48 <LCD_Init+0x6>
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	89 83       	std	Y+1, r24	; 0x01
     f4e:	6a 83       	std	Y+2, r22	; 0x02

	LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
     f50:	8a 81       	ldd	r24, Y+2	; 0x02
     f52:	80 93 d3 00 	sts	0x00D3, r24
	LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
     f56:	89 81       	ldd	r24, Y+1	; 0x01
     f58:	80 93 d2 00 	sts	0x00D2, r24
	if (v_lcdNoOfLines_u8 > C_LcdLineTwo) {
     f5c:	89 81       	ldd	r24, Y+1	; 0x01
     f5e:	83 30       	cpi	r24, 0x03	; 3
     f60:	50 f0       	brcs	.+20     	; 0xf76 <LCD_Init+0x34>
		ARR_LcdLineNumAddress_U8[C_LcdLineTwo] = 0x90
     f62:	8a 81       	ldd	r24, Y+2	; 0x02
     f64:	8f 70       	andi	r24, 0x0F	; 15
     f66:	80 57       	subi	r24, 0x70	; 112
     f68:	80 93 62 00 	sts	0x0062, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
		ARR_LcdLineNumAddress_U8[C_LcdLineThree] = 0xd0
     f6c:	8a 81       	ldd	r24, Y+2	; 0x02
     f6e:	8f 70       	andi	r24, 0x0F	; 15
     f70:	80 53       	subi	r24, 0x30	; 48
     f72:	80 93 63 00 	sts	0x0063, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
	}

	DELAY_ms(100);
     f76:	84 e6       	ldi	r24, 0x64	; 100
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <DELAY_ms>

	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
     f7e:	80 91 d4 00 	lds	r24, 0x00D4
     f82:	88 30       	cpi	r24, 0x08	; 8
     f84:	21 f4       	brne	.+8      	; 0xf8e <LCD_Init+0x4c>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
     f86:	88 e3       	ldi	r24, 0x38	; 56
     f88:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
     f8c:	09 c0       	rjmp	.+18     	; 0xfa0 <LCD_Init+0x5e>
	} else if (LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8) {
     f8e:	80 91 d4 00 	lds	r24, 0x00D4
     f92:	84 30       	cpi	r24, 0x04	; 4
     f94:	29 f4       	brne	.+10     	; 0xfa0 <LCD_Init+0x5e>
		lcd_Reset();
     f96:	0e 94 c8 13 	call	0x2790	; 0x2790 <lcd_Reset>
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type
     f9a:	88 e2       	ldi	r24, 0x28	; 40
     f9c:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
     fa0:	8e e0       	ldi	r24, 0x0E	; 14
     fa2:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
	LCD_Clear();            // Clear the LCD and go to First line First Position
     fa6:	0e 94 da 07 	call	0xfb4	; 0xfb4 <LCD_Clear>
}
     faa:	0f 90       	pop	r0
     fac:	0f 90       	pop	r0
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	08 95       	ret

00000fb4 <LCD_Clear>:
 * I/P Arguments: none.
 * Return value    : none

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ****************************************************************************************************/
void LCD_Clear() {
     fb4:	cf 93       	push	r28
     fb6:	df 93       	push	r29
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
	LCD_CmdWrite(CMD_LCD_CLEAR); // Clear the LCD and go to First line First Position
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
	LCD_GoToLine(C_LcdLineZero);
     fc2:	80 e0       	ldi	r24, 0x00	; 0
     fc4:	0e 94 e7 07 	call	0xfce	; 0xfce <LCD_GoToLine>
}
     fc8:	df 91       	pop	r29
     fca:	cf 91       	pop	r28
     fcc:	08 95       	ret

00000fce <LCD_GoToLine>:
 C_LcdLineOne,
 C_LcdLineTwo,
 C_LcdLineThree,

 ****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8) {
     fce:	cf 93       	push	r28
     fd0:	df 93       	push	r29
     fd2:	1f 92       	push	r1
     fd4:	cd b7       	in	r28, 0x3d	; 61
     fd6:	de b7       	in	r29, 0x3e	; 62
     fd8:	89 83       	std	Y+1, r24	; 0x01
	if (v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8) {
     fda:	90 91 d2 00 	lds	r25, 0x00D2
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	89 17       	cp	r24, r25
     fe2:	70 f4       	brcc	.+28     	; 0x1000 <LCD_GoToLine+0x32>
		/* If the line number is within range then
		 Move the Cursor to beginning of the specified line */
		v_LcdTrackCursorPos_U8 = 0x00;
     fe4:	10 92 e0 00 	sts	0x00E0, r1
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
     fe8:	89 81       	ldd	r24, Y+1	; 0x01
     fea:	80 93 e1 00 	sts	0x00E1, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
     fee:	89 81       	ldd	r24, Y+1	; 0x01
     ff0:	88 2f       	mov	r24, r24
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	80 5a       	subi	r24, 0xA0	; 160
     ff6:	9f 4f       	sbci	r25, 0xFF	; 255
     ff8:	fc 01       	movw	r30, r24
     ffa:	80 81       	ld	r24, Z
     ffc:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
	}
}
    1000:	0f 90       	pop	r0
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	08 95       	ret

00001008 <LCD_GoToNextLine>:

 * description  :This function moves the Cursor to beginning of the next line.
 If the cursor is on last line and NextLine command is issued then
 it will move the cursor to first line.
 ****************************************************************************************************/
void LCD_GoToNextLine(void) {
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	cd b7       	in	r28, 0x3d	; 61
    100e:	de b7       	in	r29, 0x3e	; 62
	/*Increment the current line number.
	 In case it exceeds the limit, rool it back to first line */
	v_LcdTrackLineNum_U8++;
    1010:	80 91 e1 00 	lds	r24, 0x00E1
    1014:	8f 5f       	subi	r24, 0xFF	; 255
    1016:	80 93 e1 00 	sts	0x00E1, r24
	v_LcdTrackCursorPos_U8 = 0x00;
    101a:	10 92 e0 00 	sts	0x00E0, r1
	if (v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
    101e:	90 91 d2 00 	lds	r25, 0x00D2
    1022:	80 91 e1 00 	lds	r24, 0x00E1
    1026:	89 17       	cp	r24, r25
    1028:	10 f0       	brcs	.+4      	; 0x102e <LCD_GoToNextLine+0x26>
		v_LcdTrackLineNum_U8 = C_LcdLineZero;
    102a:	10 92 e1 00 	sts	0x00E1, r1
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
    102e:	80 91 e1 00 	lds	r24, 0x00E1
    1032:	88 2f       	mov	r24, r24
    1034:	90 e0       	ldi	r25, 0x00	; 0
    1036:	80 5a       	subi	r24, 0xA0	; 160
    1038:	9f 4f       	sbci	r25, 0xFF	; 255
    103a:	fc 01       	movw	r30, r24
    103c:	80 81       	ld	r24, Z
    103e:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
}
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	08 95       	ret

00001048 <LCD_SetCursor>:

 Note:If the Input(Line/Char number) are out of range
 then no action will be taken
 ****************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t v_lineNumber_u8, uint8_t v_charNumber_u8) {
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	00 d0       	rcall	.+0      	; 0x104e <LCD_SetCursor+0x6>
    104e:	cd b7       	in	r28, 0x3d	; 61
    1050:	de b7       	in	r29, 0x3e	; 62
    1052:	89 83       	std	Y+1, r24	; 0x01
    1054:	6a 83       	std	Y+2, r22	; 0x02

	if ((v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
    1056:	90 91 d2 00 	lds	r25, 0x00D2
    105a:	89 81       	ldd	r24, Y+1	; 0x01
    105c:	89 17       	cp	r24, r25
    105e:	b0 f4       	brcc	.+44     	; 0x108c <LCD_SetCursor+0x44>
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
    1060:	90 91 d3 00 	lds	r25, 0x00D3
    1064:	8a 81       	ldd	r24, Y+2	; 0x02
    1066:	89 17       	cp	r24, r25
    1068:	88 f4       	brcc	.+34     	; 0x108c <LCD_SetCursor+0x44>
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
    106a:	8a 81       	ldd	r24, Y+2	; 0x02
    106c:	80 93 e0 00 	sts	0x00E0, r24
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	80 93 e1 00 	sts	0x00E1, r24
		LCD_CmdWrite(
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	88 2f       	mov	r24, r24
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	80 5a       	subi	r24, 0xA0	; 160
    107e:	9f 4f       	sbci	r25, 0xFF	; 255
    1080:	fc 01       	movw	r30, r24
    1082:	90 81       	ld	r25, Z
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
		LCD_CmdWrite(
    1084:	8a 81       	ldd	r24, Y+2	; 0x02
    1086:	89 0f       	add	r24, r25
    1088:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
	}
}
    108c:	0f 90       	pop	r0
    108e:	0f 90       	pop	r0
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	08 95       	ret

00001096 <LCD_CmdWrite>:
 * description :This function sends a command to LCD.
 Some of the commonly used commands are defined in lcd.h.
 For more commands refer the data sheet and send the supported command.
 The behaviour is undefined if unsupported commands are sent.
 ****************************************************************************************************/
void LCD_CmdWrite(uint8_t v_lcdCmd_u8) {
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	1f 92       	push	r1
    109c:	cd b7       	in	r28, 0x3d	; 61
    109e:	de b7       	in	r29, 0x3e	; 62
    10a0:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    10a2:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    10a6:	80 91 d4 00 	lds	r24, 0x00D4
    10aa:	88 30       	cpi	r24, 0x08	; 8
    10ac:	21 f4       	brne	.+8      	; 0x10b6 <LCD_CmdWrite+0x20>
		lcd_SendLowerNibble(v_lcdCmd_u8);
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
    10b0:	0e 94 34 14 	call	0x2868	; 0x2868 <lcd_SendLowerNibble>
    10b4:	09 c0       	rjmp	.+18     	; 0x10c8 <LCD_CmdWrite+0x32>
	} else {
		lcd_SendHigherNibble(v_lcdCmd_u8);
    10b6:	89 81       	ldd	r24, Y+1	; 0x01
    10b8:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
		lcd_SendCmdSignals();
    10bc:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
		v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
    10c0:	89 81       	ldd	r24, Y+1	; 0x01
    10c2:	82 95       	swap	r24
    10c4:	80 7f       	andi	r24, 0xF0	; 240
    10c6:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(v_lcdCmd_u8);
    10c8:	89 81       	ldd	r24, Y+1	; 0x01
    10ca:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    10ce:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
}
    10d2:	0f 90       	pop	r0
    10d4:	df 91       	pop	r29
    10d6:	cf 91       	pop	r28
    10d8:	08 95       	ret

000010da <LCD_DisplayChar>:

 * description  : This function sends a character to be displayed on LCD.
 Any valid ascii value can be passed to display respective character

 ****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8) {
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	1f 92       	push	r1
    10e0:	cd b7       	in	r28, 0x3d	; 61
    10e2:	de b7       	in	r29, 0x3e	; 62
    10e4:	89 83       	std	Y+1, r24	; 0x01
	if ((v_LcdTrackCursorPos_U8 >= LCDConfig.v_MaxSupportedChars_U8)
    10e6:	90 91 d3 00 	lds	r25, 0x00D3
    10ea:	80 91 e0 00 	lds	r24, 0x00E0
    10ee:	89 17       	cp	r24, r25
    10f0:	18 f4       	brcc	.+6      	; 0x10f8 <LCD_DisplayChar+0x1e>
			|| (v_lcdData_u8 == '\n')) {
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	8a 30       	cpi	r24, 0x0A	; 10
    10f6:	11 f4       	brne	.+4      	; 0x10fc <LCD_DisplayChar+0x22>
		/* If the cursor has reached to end of line on page1
		 OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
    10f8:	0e 94 04 08 	call	0x1008	; 0x1008 <LCD_GoToNextLine>
	}
	if (v_lcdData_u8 != '\n') /* Display the character if its not newLine Char */
    10fc:	89 81       	ldd	r24, Y+1	; 0x01
    10fe:	8a 30       	cpi	r24, 0x0A	; 10
    1100:	41 f0       	breq	.+16     	; 0x1112 <LCD_DisplayChar+0x38>
	{

		lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
    1102:	89 81       	ldd	r24, Y+1	; 0x01
    1104:	0e 94 2d 13 	call	0x265a	; 0x265a <lcd_DataWrite>
		v_LcdTrackCursorPos_U8++;
    1108:	80 91 e0 00 	lds	r24, 0x00E0
    110c:	8f 5f       	subi	r24, 0xFF	; 255
    110e:	80 93 e0 00 	sts	0x00E0, r24
	}
}
    1112:	0f 90       	pop	r0
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	08 95       	ret

0000111a <LCD_DisplayString>:
 1.The ptr_stringPointer_u8 points to the first char of the string
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	00 d0       	rcall	.+0      	; 0x1120 <LCD_DisplayString+0x6>
    1120:	cd b7       	in	r28, 0x3d	; 61
    1122:	de b7       	in	r29, 0x3e	; 62
    1124:	9a 83       	std	Y+2, r25	; 0x02
    1126:	89 83       	std	Y+1, r24	; 0x01
	while ((*ptr_stringPointer_u8) != 0)
    1128:	0b c0       	rjmp	.+22     	; 0x1140 <LCD_DisplayString+0x26>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
    112a:	89 81       	ldd	r24, Y+1	; 0x01
    112c:	9a 81       	ldd	r25, Y+2	; 0x02
    112e:	9c 01       	movw	r18, r24
    1130:	2f 5f       	subi	r18, 0xFF	; 255
    1132:	3f 4f       	sbci	r19, 0xFF	; 255
    1134:	3a 83       	std	Y+2, r19	; 0x02
    1136:	29 83       	std	Y+1, r18	; 0x01
    1138:	fc 01       	movw	r30, r24
    113a:	80 81       	ld	r24, Z
    113c:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
	while ((*ptr_stringPointer_u8) != 0)
    1140:	89 81       	ldd	r24, Y+1	; 0x01
    1142:	9a 81       	ldd	r25, Y+2	; 0x02
    1144:	fc 01       	movw	r30, r24
    1146:	80 81       	ld	r24, Z
    1148:	88 23       	and	r24, r24
    114a:	79 f7       	brne	.-34     	; 0x112a <LCD_DisplayString+0x10>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
    114c:	0f 90       	pop	r0
    114e:	0f 90       	pop	r0
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	08 95       	ret

00001156 <LCD_DisplayStringWithAddingToBuffor>:
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	cd b7       	in	r28, 0x3d	; 61
    115c:	de b7       	in	r29, 0x3e	; 62
    115e:	27 97       	sbiw	r28, 0x07	; 7
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	de bf       	out	0x3e, r29	; 62
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	cd bf       	out	0x3d, r28	; 61
    116a:	9b 83       	std	Y+3, r25	; 0x03
    116c:	8a 83       	std	Y+2, r24	; 0x02
    116e:	7d 83       	std	Y+5, r23	; 0x05
    1170:	6c 83       	std	Y+4, r22	; 0x04
    1172:	5f 83       	std	Y+7, r21	; 0x07
    1174:	4e 83       	std	Y+6, r20	; 0x06
	while ((*ptr_stringPointer_u8) != 0) {
    1176:	36 c2       	rjmp	.+1132   	; 0x15e4 <LCD_DisplayStringWithAddingToBuffor+0x48e>
		char tmp = (*ptr_stringPointer_u8++);
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	9c 01       	movw	r18, r24
    117e:	2f 5f       	subi	r18, 0xFF	; 255
    1180:	3f 4f       	sbci	r19, 0xFF	; 255
    1182:	3b 83       	std	Y+3, r19	; 0x03
    1184:	2a 83       	std	Y+2, r18	; 0x02
    1186:	fc 01       	movw	r30, r24
    1188:	80 81       	ld	r24, Z
    118a:	89 83       	std	Y+1, r24	; 0x01

		if (tmp == '%') {
    118c:	89 81       	ldd	r24, Y+1	; 0x01
    118e:	85 32       	cpi	r24, 0x25	; 37
    1190:	09 f0       	breq	.+2      	; 0x1194 <LCD_DisplayStringWithAddingToBuffor+0x3e>
    1192:	04 c2       	rjmp	.+1032   	; 0x159c <LCD_DisplayStringWithAddingToBuffor+0x446>
			switch (*ptr_stringPointer_u8++) {
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	9b 81       	ldd	r25, Y+3	; 0x03
    1198:	9c 01       	movw	r18, r24
    119a:	2f 5f       	subi	r18, 0xFF	; 255
    119c:	3f 4f       	sbci	r19, 0xFF	; 255
    119e:	3b 83       	std	Y+3, r19	; 0x03
    11a0:	2a 83       	std	Y+2, r18	; 0x02
    11a2:	fc 01       	movw	r30, r24
    11a4:	80 81       	ld	r24, Z
    11a6:	88 2f       	mov	r24, r24
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	aa 27       	eor	r26, r26
    11ac:	97 fd       	sbrc	r25, 7
    11ae:	a0 95       	com	r26
    11b0:	ba 2f       	mov	r27, r26
    11b2:	45 e2       	ldi	r20, 0x25	; 37
    11b4:	50 e0       	ldi	r21, 0x00	; 0
    11b6:	28 e5       	ldi	r18, 0x58	; 88
    11b8:	30 e0       	ldi	r19, 0x00	; 0
    11ba:	84 1b       	sub	r24, r20
    11bc:	95 0b       	sbc	r25, r21
    11be:	28 17       	cp	r18, r24
    11c0:	39 07       	cpc	r19, r25
    11c2:	08 f4       	brcc	.+2      	; 0x11c6 <LCD_DisplayStringWithAddingToBuffor+0x70>
    11c4:	0f c2       	rjmp	.+1054   	; 0x15e4 <LCD_DisplayStringWithAddingToBuffor+0x48e>
    11c6:	86 5d       	subi	r24, 0xD6	; 214
    11c8:	9f 4f       	sbci	r25, 0xFF	; 255
    11ca:	fc 01       	movw	r30, r24
    11cc:	0c 94 47 1a 	jmp	0x348e	; 0x348e <__tablejump2__>
			case '%':
				LCD_DisplayChar('%');
    11d0:	85 e2       	ldi	r24, 0x25	; 37
    11d2:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				LCD_BUFFOR[y][(*x)] = '%';
    11d6:	8c 81       	ldd	r24, Y+4	; 0x04
    11d8:	9d 81       	ldd	r25, Y+5	; 0x05
    11da:	fc 01       	movw	r30, r24
    11dc:	80 81       	ld	r24, Z
    11de:	91 81       	ldd	r25, Z+1	; 0x01
    11e0:	2e 81       	ldd	r18, Y+6	; 0x06
    11e2:	3f 81       	ldd	r19, Y+7	; 0x07
    11e4:	22 95       	swap	r18
    11e6:	32 95       	swap	r19
    11e8:	30 7f       	andi	r19, 0xF0	; 240
    11ea:	32 27       	eor	r19, r18
    11ec:	20 7f       	andi	r18, 0xF0	; 240
    11ee:	32 27       	eor	r19, r18
    11f0:	82 0f       	add	r24, r18
    11f2:	93 1f       	adc	r25, r19
    11f4:	8e 54       	subi	r24, 0x4E	; 78
    11f6:	9f 4f       	sbci	r25, 0xFF	; 255
    11f8:	25 e2       	ldi	r18, 0x25	; 37
    11fa:	fc 01       	movw	r30, r24
    11fc:	20 83       	st	Z, r18
				(*x)++;
    11fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1200:	9d 81       	ldd	r25, Y+5	; 0x05
    1202:	fc 01       	movw	r30, r24
    1204:	80 81       	ld	r24, Z
    1206:	91 81       	ldd	r25, Z+1	; 0x01
    1208:	9c 01       	movw	r18, r24
    120a:	2f 5f       	subi	r18, 0xFF	; 255
    120c:	3f 4f       	sbci	r19, 0xFF	; 255
    120e:	8c 81       	ldd	r24, Y+4	; 0x04
    1210:	9d 81       	ldd	r25, Y+5	; 0x05
    1212:	fc 01       	movw	r30, r24
    1214:	31 83       	std	Z+1, r19	; 0x01
    1216:	20 83       	st	Z, r18
				break;
    1218:	c0 c1       	rjmp	.+896    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '>':
				LCD_PrintSymbol(1);
    121a:	81 e0       	ldi	r24, 0x01	; 1
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '>';
    1222:	8c 81       	ldd	r24, Y+4	; 0x04
    1224:	9d 81       	ldd	r25, Y+5	; 0x05
    1226:	fc 01       	movw	r30, r24
    1228:	80 81       	ld	r24, Z
    122a:	91 81       	ldd	r25, Z+1	; 0x01
    122c:	2e 81       	ldd	r18, Y+6	; 0x06
    122e:	3f 81       	ldd	r19, Y+7	; 0x07
    1230:	22 95       	swap	r18
    1232:	32 95       	swap	r19
    1234:	30 7f       	andi	r19, 0xF0	; 240
    1236:	32 27       	eor	r19, r18
    1238:	20 7f       	andi	r18, 0xF0	; 240
    123a:	32 27       	eor	r19, r18
    123c:	82 0f       	add	r24, r18
    123e:	93 1f       	adc	r25, r19
    1240:	8e 54       	subi	r24, 0x4E	; 78
    1242:	9f 4f       	sbci	r25, 0xFF	; 255
    1244:	2e e3       	ldi	r18, 0x3E	; 62
    1246:	fc 01       	movw	r30, r24
    1248:	20 83       	st	Z, r18
				(*x)++;
    124a:	8c 81       	ldd	r24, Y+4	; 0x04
    124c:	9d 81       	ldd	r25, Y+5	; 0x05
    124e:	fc 01       	movw	r30, r24
    1250:	80 81       	ld	r24, Z
    1252:	91 81       	ldd	r25, Z+1	; 0x01
    1254:	9c 01       	movw	r18, r24
    1256:	2f 5f       	subi	r18, 0xFF	; 255
    1258:	3f 4f       	sbci	r19, 0xFF	; 255
    125a:	8c 81       	ldd	r24, Y+4	; 0x04
    125c:	9d 81       	ldd	r25, Y+5	; 0x05
    125e:	fc 01       	movw	r30, r24
    1260:	31 83       	std	Z+1, r19	; 0x01
    1262:	20 83       	st	Z, r18
				break;
    1264:	9a c1       	rjmp	.+820    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '<':
				LCD_PrintSymbol(2);
    1266:	82 e0       	ldi	r24, 0x02	; 2
    1268:	90 e0       	ldi	r25, 0x00	; 0
    126a:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '<';
    126e:	8c 81       	ldd	r24, Y+4	; 0x04
    1270:	9d 81       	ldd	r25, Y+5	; 0x05
    1272:	fc 01       	movw	r30, r24
    1274:	80 81       	ld	r24, Z
    1276:	91 81       	ldd	r25, Z+1	; 0x01
    1278:	2e 81       	ldd	r18, Y+6	; 0x06
    127a:	3f 81       	ldd	r19, Y+7	; 0x07
    127c:	22 95       	swap	r18
    127e:	32 95       	swap	r19
    1280:	30 7f       	andi	r19, 0xF0	; 240
    1282:	32 27       	eor	r19, r18
    1284:	20 7f       	andi	r18, 0xF0	; 240
    1286:	32 27       	eor	r19, r18
    1288:	82 0f       	add	r24, r18
    128a:	93 1f       	adc	r25, r19
    128c:	8e 54       	subi	r24, 0x4E	; 78
    128e:	9f 4f       	sbci	r25, 0xFF	; 255
    1290:	2c e3       	ldi	r18, 0x3C	; 60
    1292:	fc 01       	movw	r30, r24
    1294:	20 83       	st	Z, r18
				(*x)++;
    1296:	8c 81       	ldd	r24, Y+4	; 0x04
    1298:	9d 81       	ldd	r25, Y+5	; 0x05
    129a:	fc 01       	movw	r30, r24
    129c:	80 81       	ld	r24, Z
    129e:	91 81       	ldd	r25, Z+1	; 0x01
    12a0:	9c 01       	movw	r18, r24
    12a2:	2f 5f       	subi	r18, 0xFF	; 255
    12a4:	3f 4f       	sbci	r19, 0xFF	; 255
    12a6:	8c 81       	ldd	r24, Y+4	; 0x04
    12a8:	9d 81       	ldd	r25, Y+5	; 0x05
    12aa:	fc 01       	movw	r30, r24
    12ac:	31 83       	std	Z+1, r19	; 0x01
    12ae:	20 83       	st	Z, r18
				break;
    12b0:	74 c1       	rjmp	.+744    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '|':
				LCD_PrintSymbol(3);
    12b2:	83 e0       	ldi	r24, 0x03	; 3
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '|';
    12ba:	8c 81       	ldd	r24, Y+4	; 0x04
    12bc:	9d 81       	ldd	r25, Y+5	; 0x05
    12be:	fc 01       	movw	r30, r24
    12c0:	80 81       	ld	r24, Z
    12c2:	91 81       	ldd	r25, Z+1	; 0x01
    12c4:	2e 81       	ldd	r18, Y+6	; 0x06
    12c6:	3f 81       	ldd	r19, Y+7	; 0x07
    12c8:	22 95       	swap	r18
    12ca:	32 95       	swap	r19
    12cc:	30 7f       	andi	r19, 0xF0	; 240
    12ce:	32 27       	eor	r19, r18
    12d0:	20 7f       	andi	r18, 0xF0	; 240
    12d2:	32 27       	eor	r19, r18
    12d4:	82 0f       	add	r24, r18
    12d6:	93 1f       	adc	r25, r19
    12d8:	8e 54       	subi	r24, 0x4E	; 78
    12da:	9f 4f       	sbci	r25, 0xFF	; 255
    12dc:	2c e7       	ldi	r18, 0x7C	; 124
    12de:	fc 01       	movw	r30, r24
    12e0:	20 83       	st	Z, r18
				(*x)++;
    12e2:	8c 81       	ldd	r24, Y+4	; 0x04
    12e4:	9d 81       	ldd	r25, Y+5	; 0x05
    12e6:	fc 01       	movw	r30, r24
    12e8:	80 81       	ld	r24, Z
    12ea:	91 81       	ldd	r25, Z+1	; 0x01
    12ec:	9c 01       	movw	r18, r24
    12ee:	2f 5f       	subi	r18, 0xFF	; 255
    12f0:	3f 4f       	sbci	r19, 0xFF	; 255
    12f2:	8c 81       	ldd	r24, Y+4	; 0x04
    12f4:	9d 81       	ldd	r25, Y+5	; 0x05
    12f6:	fc 01       	movw	r30, r24
    12f8:	31 83       	std	Z+1, r19	; 0x01
    12fa:	20 83       	st	Z, r18
				break;
    12fc:	4e c1       	rjmp	.+668    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '{':
				LCD_PrintSymbol(4);
    12fe:	84 e0       	ldi	r24, 0x04	; 4
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '{';
    1306:	8c 81       	ldd	r24, Y+4	; 0x04
    1308:	9d 81       	ldd	r25, Y+5	; 0x05
    130a:	fc 01       	movw	r30, r24
    130c:	80 81       	ld	r24, Z
    130e:	91 81       	ldd	r25, Z+1	; 0x01
    1310:	2e 81       	ldd	r18, Y+6	; 0x06
    1312:	3f 81       	ldd	r19, Y+7	; 0x07
    1314:	22 95       	swap	r18
    1316:	32 95       	swap	r19
    1318:	30 7f       	andi	r19, 0xF0	; 240
    131a:	32 27       	eor	r19, r18
    131c:	20 7f       	andi	r18, 0xF0	; 240
    131e:	32 27       	eor	r19, r18
    1320:	82 0f       	add	r24, r18
    1322:	93 1f       	adc	r25, r19
    1324:	8e 54       	subi	r24, 0x4E	; 78
    1326:	9f 4f       	sbci	r25, 0xFF	; 255
    1328:	2b e7       	ldi	r18, 0x7B	; 123
    132a:	fc 01       	movw	r30, r24
    132c:	20 83       	st	Z, r18
				(*x)++;
    132e:	8c 81       	ldd	r24, Y+4	; 0x04
    1330:	9d 81       	ldd	r25, Y+5	; 0x05
    1332:	fc 01       	movw	r30, r24
    1334:	80 81       	ld	r24, Z
    1336:	91 81       	ldd	r25, Z+1	; 0x01
    1338:	9c 01       	movw	r18, r24
    133a:	2f 5f       	subi	r18, 0xFF	; 255
    133c:	3f 4f       	sbci	r19, 0xFF	; 255
    133e:	8c 81       	ldd	r24, Y+4	; 0x04
    1340:	9d 81       	ldd	r25, Y+5	; 0x05
    1342:	fc 01       	movw	r30, r24
    1344:	31 83       	std	Z+1, r19	; 0x01
    1346:	20 83       	st	Z, r18
				break;
    1348:	28 c1       	rjmp	.+592    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '}':
				LCD_PrintSymbol(5);
    134a:	85 e0       	ldi	r24, 0x05	; 5
    134c:	90 e0       	ldi	r25, 0x00	; 0
    134e:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '}';
    1352:	8c 81       	ldd	r24, Y+4	; 0x04
    1354:	9d 81       	ldd	r25, Y+5	; 0x05
    1356:	fc 01       	movw	r30, r24
    1358:	80 81       	ld	r24, Z
    135a:	91 81       	ldd	r25, Z+1	; 0x01
    135c:	2e 81       	ldd	r18, Y+6	; 0x06
    135e:	3f 81       	ldd	r19, Y+7	; 0x07
    1360:	22 95       	swap	r18
    1362:	32 95       	swap	r19
    1364:	30 7f       	andi	r19, 0xF0	; 240
    1366:	32 27       	eor	r19, r18
    1368:	20 7f       	andi	r18, 0xF0	; 240
    136a:	32 27       	eor	r19, r18
    136c:	82 0f       	add	r24, r18
    136e:	93 1f       	adc	r25, r19
    1370:	8e 54       	subi	r24, 0x4E	; 78
    1372:	9f 4f       	sbci	r25, 0xFF	; 255
    1374:	2d e7       	ldi	r18, 0x7D	; 125
    1376:	fc 01       	movw	r30, r24
    1378:	20 83       	st	Z, r18
				(*x)++;
    137a:	8c 81       	ldd	r24, Y+4	; 0x04
    137c:	9d 81       	ldd	r25, Y+5	; 0x05
    137e:	fc 01       	movw	r30, r24
    1380:	80 81       	ld	r24, Z
    1382:	91 81       	ldd	r25, Z+1	; 0x01
    1384:	9c 01       	movw	r18, r24
    1386:	2f 5f       	subi	r18, 0xFF	; 255
    1388:	3f 4f       	sbci	r19, 0xFF	; 255
    138a:	8c 81       	ldd	r24, Y+4	; 0x04
    138c:	9d 81       	ldd	r25, Y+5	; 0x05
    138e:	fc 01       	movw	r30, r24
    1390:	31 83       	std	Z+1, r19	; 0x01
    1392:	20 83       	st	Z, r18
				break;
    1394:	02 c1       	rjmp	.+516    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ',':
				LCD_PrintSymbol(6);
    1396:	86 e0       	ldi	r24, 0x06	; 6
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ',';
    139e:	8c 81       	ldd	r24, Y+4	; 0x04
    13a0:	9d 81       	ldd	r25, Y+5	; 0x05
    13a2:	fc 01       	movw	r30, r24
    13a4:	80 81       	ld	r24, Z
    13a6:	91 81       	ldd	r25, Z+1	; 0x01
    13a8:	2e 81       	ldd	r18, Y+6	; 0x06
    13aa:	3f 81       	ldd	r19, Y+7	; 0x07
    13ac:	22 95       	swap	r18
    13ae:	32 95       	swap	r19
    13b0:	30 7f       	andi	r19, 0xF0	; 240
    13b2:	32 27       	eor	r19, r18
    13b4:	20 7f       	andi	r18, 0xF0	; 240
    13b6:	32 27       	eor	r19, r18
    13b8:	82 0f       	add	r24, r18
    13ba:	93 1f       	adc	r25, r19
    13bc:	8e 54       	subi	r24, 0x4E	; 78
    13be:	9f 4f       	sbci	r25, 0xFF	; 255
    13c0:	2c e2       	ldi	r18, 0x2C	; 44
    13c2:	fc 01       	movw	r30, r24
    13c4:	20 83       	st	Z, r18
				(*x)++;
    13c6:	8c 81       	ldd	r24, Y+4	; 0x04
    13c8:	9d 81       	ldd	r25, Y+5	; 0x05
    13ca:	fc 01       	movw	r30, r24
    13cc:	80 81       	ld	r24, Z
    13ce:	91 81       	ldd	r25, Z+1	; 0x01
    13d0:	9c 01       	movw	r18, r24
    13d2:	2f 5f       	subi	r18, 0xFF	; 255
    13d4:	3f 4f       	sbci	r19, 0xFF	; 255
    13d6:	8c 81       	ldd	r24, Y+4	; 0x04
    13d8:	9d 81       	ldd	r25, Y+5	; 0x05
    13da:	fc 01       	movw	r30, r24
    13dc:	31 83       	std	Z+1, r19	; 0x01
    13de:	20 83       	st	Z, r18
				break;
    13e0:	dc c0       	rjmp	.+440    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ':':
				LCD_PrintSymbol(7);
    13e2:	87 e0       	ldi	r24, 0x07	; 7
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ':';
    13ea:	8c 81       	ldd	r24, Y+4	; 0x04
    13ec:	9d 81       	ldd	r25, Y+5	; 0x05
    13ee:	fc 01       	movw	r30, r24
    13f0:	80 81       	ld	r24, Z
    13f2:	91 81       	ldd	r25, Z+1	; 0x01
    13f4:	2e 81       	ldd	r18, Y+6	; 0x06
    13f6:	3f 81       	ldd	r19, Y+7	; 0x07
    13f8:	22 95       	swap	r18
    13fa:	32 95       	swap	r19
    13fc:	30 7f       	andi	r19, 0xF0	; 240
    13fe:	32 27       	eor	r19, r18
    1400:	20 7f       	andi	r18, 0xF0	; 240
    1402:	32 27       	eor	r19, r18
    1404:	82 0f       	add	r24, r18
    1406:	93 1f       	adc	r25, r19
    1408:	8e 54       	subi	r24, 0x4E	; 78
    140a:	9f 4f       	sbci	r25, 0xFF	; 255
    140c:	2a e3       	ldi	r18, 0x3A	; 58
    140e:	fc 01       	movw	r30, r24
    1410:	20 83       	st	Z, r18
				(*x)++;
    1412:	8c 81       	ldd	r24, Y+4	; 0x04
    1414:	9d 81       	ldd	r25, Y+5	; 0x05
    1416:	fc 01       	movw	r30, r24
    1418:	80 81       	ld	r24, Z
    141a:	91 81       	ldd	r25, Z+1	; 0x01
    141c:	9c 01       	movw	r18, r24
    141e:	2f 5f       	subi	r18, 0xFF	; 255
    1420:	3f 4f       	sbci	r19, 0xFF	; 255
    1422:	8c 81       	ldd	r24, Y+4	; 0x04
    1424:	9d 81       	ldd	r25, Y+5	; 0x05
    1426:	fc 01       	movw	r30, r24
    1428:	31 83       	std	Z+1, r19	; 0x01
    142a:	20 83       	st	Z, r18
				break;
    142c:	b6 c0       	rjmp	.+364    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ';':
				LCD_PrintSymbol(8);
    142e:	88 e0       	ldi	r24, 0x08	; 8
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ';';
    1436:	8c 81       	ldd	r24, Y+4	; 0x04
    1438:	9d 81       	ldd	r25, Y+5	; 0x05
    143a:	fc 01       	movw	r30, r24
    143c:	80 81       	ld	r24, Z
    143e:	91 81       	ldd	r25, Z+1	; 0x01
    1440:	2e 81       	ldd	r18, Y+6	; 0x06
    1442:	3f 81       	ldd	r19, Y+7	; 0x07
    1444:	22 95       	swap	r18
    1446:	32 95       	swap	r19
    1448:	30 7f       	andi	r19, 0xF0	; 240
    144a:	32 27       	eor	r19, r18
    144c:	20 7f       	andi	r18, 0xF0	; 240
    144e:	32 27       	eor	r19, r18
    1450:	82 0f       	add	r24, r18
    1452:	93 1f       	adc	r25, r19
    1454:	8e 54       	subi	r24, 0x4E	; 78
    1456:	9f 4f       	sbci	r25, 0xFF	; 255
    1458:	2b e3       	ldi	r18, 0x3B	; 59
    145a:	fc 01       	movw	r30, r24
    145c:	20 83       	st	Z, r18
				(*x)++;
    145e:	8c 81       	ldd	r24, Y+4	; 0x04
    1460:	9d 81       	ldd	r25, Y+5	; 0x05
    1462:	fc 01       	movw	r30, r24
    1464:	80 81       	ld	r24, Z
    1466:	91 81       	ldd	r25, Z+1	; 0x01
    1468:	9c 01       	movw	r18, r24
    146a:	2f 5f       	subi	r18, 0xFF	; 255
    146c:	3f 4f       	sbci	r19, 0xFF	; 255
    146e:	8c 81       	ldd	r24, Y+4	; 0x04
    1470:	9d 81       	ldd	r25, Y+5	; 0x05
    1472:	fc 01       	movw	r30, r24
    1474:	31 83       	std	Z+1, r19	; 0x01
    1476:	20 83       	st	Z, r18
				break;
    1478:	90 c0       	rjmp	.+288    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '?':
				LCD_PrintBlock();
    147a:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <LCD_PrintBlock>
				LCD_BUFFOR[y][(*x)] = '?';
    147e:	8c 81       	ldd	r24, Y+4	; 0x04
    1480:	9d 81       	ldd	r25, Y+5	; 0x05
    1482:	fc 01       	movw	r30, r24
    1484:	80 81       	ld	r24, Z
    1486:	91 81       	ldd	r25, Z+1	; 0x01
    1488:	2e 81       	ldd	r18, Y+6	; 0x06
    148a:	3f 81       	ldd	r19, Y+7	; 0x07
    148c:	22 95       	swap	r18
    148e:	32 95       	swap	r19
    1490:	30 7f       	andi	r19, 0xF0	; 240
    1492:	32 27       	eor	r19, r18
    1494:	20 7f       	andi	r18, 0xF0	; 240
    1496:	32 27       	eor	r19, r18
    1498:	82 0f       	add	r24, r18
    149a:	93 1f       	adc	r25, r19
    149c:	8e 54       	subi	r24, 0x4E	; 78
    149e:	9f 4f       	sbci	r25, 0xFF	; 255
    14a0:	2f e3       	ldi	r18, 0x3F	; 63
    14a2:	fc 01       	movw	r30, r24
    14a4:	20 83       	st	Z, r18
				(*x)++;
    14a6:	8c 81       	ldd	r24, Y+4	; 0x04
    14a8:	9d 81       	ldd	r25, Y+5	; 0x05
    14aa:	fc 01       	movw	r30, r24
    14ac:	80 81       	ld	r24, Z
    14ae:	91 81       	ldd	r25, Z+1	; 0x01
    14b0:	9c 01       	movw	r18, r24
    14b2:	2f 5f       	subi	r18, 0xFF	; 255
    14b4:	3f 4f       	sbci	r19, 0xFF	; 255
    14b6:	8c 81       	ldd	r24, Y+4	; 0x04
    14b8:	9d 81       	ldd	r25, Y+5	; 0x05
    14ba:	fc 01       	movw	r30, r24
    14bc:	31 83       	std	Z+1, r19	; 0x01
    14be:	20 83       	st	Z, r18
				break;
    14c0:	6c c0       	rjmp	.+216    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '[':
				LCD_PrintLArrow();
    14c2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <LCD_PrintLArrow>
				LCD_BUFFOR[y][(*x)] = '[';
    14c6:	8c 81       	ldd	r24, Y+4	; 0x04
    14c8:	9d 81       	ldd	r25, Y+5	; 0x05
    14ca:	fc 01       	movw	r30, r24
    14cc:	80 81       	ld	r24, Z
    14ce:	91 81       	ldd	r25, Z+1	; 0x01
    14d0:	2e 81       	ldd	r18, Y+6	; 0x06
    14d2:	3f 81       	ldd	r19, Y+7	; 0x07
    14d4:	22 95       	swap	r18
    14d6:	32 95       	swap	r19
    14d8:	30 7f       	andi	r19, 0xF0	; 240
    14da:	32 27       	eor	r19, r18
    14dc:	20 7f       	andi	r18, 0xF0	; 240
    14de:	32 27       	eor	r19, r18
    14e0:	82 0f       	add	r24, r18
    14e2:	93 1f       	adc	r25, r19
    14e4:	8e 54       	subi	r24, 0x4E	; 78
    14e6:	9f 4f       	sbci	r25, 0xFF	; 255
    14e8:	2b e5       	ldi	r18, 0x5B	; 91
    14ea:	fc 01       	movw	r30, r24
    14ec:	20 83       	st	Z, r18
				(*x)++;
    14ee:	8c 81       	ldd	r24, Y+4	; 0x04
    14f0:	9d 81       	ldd	r25, Y+5	; 0x05
    14f2:	fc 01       	movw	r30, r24
    14f4:	80 81       	ld	r24, Z
    14f6:	91 81       	ldd	r25, Z+1	; 0x01
    14f8:	9c 01       	movw	r18, r24
    14fa:	2f 5f       	subi	r18, 0xFF	; 255
    14fc:	3f 4f       	sbci	r19, 0xFF	; 255
    14fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1500:	9d 81       	ldd	r25, Y+5	; 0x05
    1502:	fc 01       	movw	r30, r24
    1504:	31 83       	std	Z+1, r19	; 0x01
    1506:	20 83       	st	Z, r18
				break;
    1508:	48 c0       	rjmp	.+144    	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ']':
				LCD_PrintRArrow();
    150a:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <LCD_PrintRArrow>
				LCD_BUFFOR[y][(*x)] = ']';
    150e:	8c 81       	ldd	r24, Y+4	; 0x04
    1510:	9d 81       	ldd	r25, Y+5	; 0x05
    1512:	fc 01       	movw	r30, r24
    1514:	80 81       	ld	r24, Z
    1516:	91 81       	ldd	r25, Z+1	; 0x01
    1518:	2e 81       	ldd	r18, Y+6	; 0x06
    151a:	3f 81       	ldd	r19, Y+7	; 0x07
    151c:	22 95       	swap	r18
    151e:	32 95       	swap	r19
    1520:	30 7f       	andi	r19, 0xF0	; 240
    1522:	32 27       	eor	r19, r18
    1524:	20 7f       	andi	r18, 0xF0	; 240
    1526:	32 27       	eor	r19, r18
    1528:	82 0f       	add	r24, r18
    152a:	93 1f       	adc	r25, r19
    152c:	8e 54       	subi	r24, 0x4E	; 78
    152e:	9f 4f       	sbci	r25, 0xFF	; 255
    1530:	2d e5       	ldi	r18, 0x5D	; 93
    1532:	fc 01       	movw	r30, r24
    1534:	20 83       	st	Z, r18
				(*x)++;
    1536:	8c 81       	ldd	r24, Y+4	; 0x04
    1538:	9d 81       	ldd	r25, Y+5	; 0x05
    153a:	fc 01       	movw	r30, r24
    153c:	80 81       	ld	r24, Z
    153e:	91 81       	ldd	r25, Z+1	; 0x01
    1540:	9c 01       	movw	r18, r24
    1542:	2f 5f       	subi	r18, 0xFF	; 255
    1544:	3f 4f       	sbci	r19, 0xFF	; 255
    1546:	8c 81       	ldd	r24, Y+4	; 0x04
    1548:	9d 81       	ldd	r25, Y+5	; 0x05
    154a:	fc 01       	movw	r30, r24
    154c:	31 83       	std	Z+1, r19	; 0x01
    154e:	20 83       	st	Z, r18
				break;
    1550:	24 c0       	rjmp	.+72     	; 0x159a <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '.':
				LCD_PrintDot();
    1552:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <LCD_PrintDot>
				LCD_BUFFOR[y][(*x)] = '.';
    1556:	8c 81       	ldd	r24, Y+4	; 0x04
    1558:	9d 81       	ldd	r25, Y+5	; 0x05
    155a:	fc 01       	movw	r30, r24
    155c:	80 81       	ld	r24, Z
    155e:	91 81       	ldd	r25, Z+1	; 0x01
    1560:	2e 81       	ldd	r18, Y+6	; 0x06
    1562:	3f 81       	ldd	r19, Y+7	; 0x07
    1564:	22 95       	swap	r18
    1566:	32 95       	swap	r19
    1568:	30 7f       	andi	r19, 0xF0	; 240
    156a:	32 27       	eor	r19, r18
    156c:	20 7f       	andi	r18, 0xF0	; 240
    156e:	32 27       	eor	r19, r18
    1570:	82 0f       	add	r24, r18
    1572:	93 1f       	adc	r25, r19
    1574:	8e 54       	subi	r24, 0x4E	; 78
    1576:	9f 4f       	sbci	r25, 0xFF	; 255
    1578:	2e e2       	ldi	r18, 0x2E	; 46
    157a:	fc 01       	movw	r30, r24
    157c:	20 83       	st	Z, r18
				(*x)++;
    157e:	8c 81       	ldd	r24, Y+4	; 0x04
    1580:	9d 81       	ldd	r25, Y+5	; 0x05
    1582:	fc 01       	movw	r30, r24
    1584:	80 81       	ld	r24, Z
    1586:	91 81       	ldd	r25, Z+1	; 0x01
    1588:	9c 01       	movw	r18, r24
    158a:	2f 5f       	subi	r18, 0xFF	; 255
    158c:	3f 4f       	sbci	r19, 0xFF	; 255
    158e:	8c 81       	ldd	r24, Y+4	; 0x04
    1590:	9d 81       	ldd	r25, Y+5	; 0x05
    1592:	fc 01       	movw	r30, r24
    1594:	31 83       	std	Z+1, r19	; 0x01
    1596:	20 83       	st	Z, r18
				break;
    1598:	00 00       	nop
    159a:	24 c0       	rjmp	.+72     	; 0x15e4 <LCD_DisplayStringWithAddingToBuffor+0x48e>
			}
		} else {
			LCD_DisplayChar(tmp);
    159c:	89 81       	ldd	r24, Y+1	; 0x01
    159e:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = tmp;
    15a2:	8c 81       	ldd	r24, Y+4	; 0x04
    15a4:	9d 81       	ldd	r25, Y+5	; 0x05
    15a6:	fc 01       	movw	r30, r24
    15a8:	80 81       	ld	r24, Z
    15aa:	91 81       	ldd	r25, Z+1	; 0x01
    15ac:	2e 81       	ldd	r18, Y+6	; 0x06
    15ae:	3f 81       	ldd	r19, Y+7	; 0x07
    15b0:	22 95       	swap	r18
    15b2:	32 95       	swap	r19
    15b4:	30 7f       	andi	r19, 0xF0	; 240
    15b6:	32 27       	eor	r19, r18
    15b8:	20 7f       	andi	r18, 0xF0	; 240
    15ba:	32 27       	eor	r19, r18
    15bc:	82 0f       	add	r24, r18
    15be:	93 1f       	adc	r25, r19
    15c0:	8e 54       	subi	r24, 0x4E	; 78
    15c2:	9f 4f       	sbci	r25, 0xFF	; 255
    15c4:	29 81       	ldd	r18, Y+1	; 0x01
    15c6:	fc 01       	movw	r30, r24
    15c8:	20 83       	st	Z, r18
			(*x)++;
    15ca:	8c 81       	ldd	r24, Y+4	; 0x04
    15cc:	9d 81       	ldd	r25, Y+5	; 0x05
    15ce:	fc 01       	movw	r30, r24
    15d0:	80 81       	ld	r24, Z
    15d2:	91 81       	ldd	r25, Z+1	; 0x01
    15d4:	9c 01       	movw	r18, r24
    15d6:	2f 5f       	subi	r18, 0xFF	; 255
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	8c 81       	ldd	r24, Y+4	; 0x04
    15dc:	9d 81       	ldd	r25, Y+5	; 0x05
    15de:	fc 01       	movw	r30, r24
    15e0:	31 83       	std	Z+1, r19	; 0x01
    15e2:	20 83       	st	Z, r18
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
	while ((*ptr_stringPointer_u8) != 0) {
    15e4:	8a 81       	ldd	r24, Y+2	; 0x02
    15e6:	9b 81       	ldd	r25, Y+3	; 0x03
    15e8:	fc 01       	movw	r30, r24
    15ea:	80 81       	ld	r24, Z
    15ec:	88 23       	and	r24, r24
    15ee:	09 f0       	breq	.+2      	; 0x15f2 <LCD_DisplayStringWithAddingToBuffor+0x49c>
    15f0:	c3 cd       	rjmp	.-1146   	; 0x1178 <LCD_DisplayStringWithAddingToBuffor+0x22>
			LCD_DisplayChar(tmp);
			LCD_BUFFOR[y][(*x)] = tmp;
			(*x)++;
		}
	}
}
    15f2:	27 96       	adiw	r28, 0x07	; 7
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	df 91       	pop	r29
    1600:	cf 91       	pop	r28
    1602:	08 95       	ret

00001604 <LCD_ScrollMessage>:
 * description  :This function scrolls the given message on the specified line.
 If the specified line number is out of range then the message
 will be scrolled on first line
 ****************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8) {
    1604:	cf 93       	push	r28
    1606:	df 93       	push	r29
    1608:	00 d0       	rcall	.+0      	; 0x160a <LCD_ScrollMessage+0x6>
    160a:	00 d0       	rcall	.+0      	; 0x160c <LCD_ScrollMessage+0x8>
    160c:	1f 92       	push	r1
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
    1612:	8b 83       	std	Y+3, r24	; 0x03
    1614:	7d 83       	std	Y+5, r23	; 0x05
    1616:	6c 83       	std	Y+4, r22	; 0x04
	unsigned char i, j;

	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
    1618:	90 91 d2 00 	lds	r25, 0x00D2
    161c:	8b 81       	ldd	r24, Y+3	; 0x03
    161e:	89 17       	cp	r24, r25
    1620:	08 f0       	brcs	.+2      	; 0x1624 <LCD_ScrollMessage+0x20>
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range
    1622:	1b 82       	std	Y+3, r1	; 0x03

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor
    1624:	8c e0       	ldi	r24, 0x0C	; 12
    1626:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    162a:	19 82       	std	Y+1, r1	; 0x01
    162c:	40 c0       	rjmp	.+128    	; 0x16ae <LCD_ScrollMessage+0xaa>
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line
    162e:	8b 81       	ldd	r24, Y+3	; 0x03
    1630:	0e 94 e7 07 	call	0xfce	; 0xfce <LCD_GoToLine>

		for (j = 0;
    1634:	1a 82       	std	Y+2, r1	; 0x02
    1636:	13 c0       	rjmp	.+38     	; 0x165e <LCD_ScrollMessage+0x5a>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	28 2f       	mov	r18, r24
    163c:	30 e0       	ldi	r19, 0x00	; 0
    163e:	8a 81       	ldd	r24, Y+2	; 0x02
    1640:	88 2f       	mov	r24, r24
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	82 0f       	add	r24, r18
    1646:	93 1f       	adc	r25, r19
    1648:	2c 81       	ldd	r18, Y+4	; 0x04
    164a:	3d 81       	ldd	r19, Y+5	; 0x05
    164c:	82 0f       	add	r24, r18
    164e:	93 1f       	adc	r25, r19
    1650:	fc 01       	movw	r30, r24
    1652:	80 81       	ld	r24, Z
    1654:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    1658:	8a 81       	ldd	r24, Y+2	; 0x02
    165a:	8f 5f       	subi	r24, 0xFF	; 255
    165c:	8a 83       	std	Y+2, r24	; 0x02
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
    165e:	90 91 d3 00 	lds	r25, 0x00D3
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
    1662:	8a 81       	ldd	r24, Y+2	; 0x02
    1664:	89 17       	cp	r24, r25
    1666:	80 f4       	brcc	.+32     	; 0x1688 <LCD_ScrollMessage+0x84>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    1668:	89 81       	ldd	r24, Y+1	; 0x01
    166a:	28 2f       	mov	r18, r24
    166c:	30 e0       	ldi	r19, 0x00	; 0
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	88 2f       	mov	r24, r24
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	2c 81       	ldd	r18, Y+4	; 0x04
    167a:	3d 81       	ldd	r19, Y+5	; 0x05
    167c:	82 0f       	add	r24, r18
    167e:	93 1f       	adc	r25, r19
    1680:	fc 01       	movw	r30, r24
    1682:	80 81       	ld	r24, Z
    1684:	88 23       	and	r24, r24
    1686:	c1 f6       	brne	.-80     	; 0x1638 <LCD_ScrollMessage+0x34>
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    1688:	06 c0       	rjmp	.+12     	; 0x1696 <LCD_ScrollMessage+0x92>
			/*If the chars to be scrolled are less than MaxLcdChars,
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
    168a:	80 e2       	ldi	r24, 0x20	; 32
    168c:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			j++;
    1690:	8a 81       	ldd	r24, Y+2	; 0x02
    1692:	8f 5f       	subi	r24, 0xFF	; 255
    1694:	8a 83       	std	Y+2, r24	; 0x02
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    1696:	90 91 d3 00 	lds	r25, 0x00D3
    169a:	8a 81       	ldd	r24, Y+2	; 0x02
    169c:	89 17       	cp	r24, r25
    169e:	a8 f3       	brcs	.-22     	; 0x168a <LCD_ScrollMessage+0x86>
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
    16a0:	88 ec       	ldi	r24, 0xC8	; 200
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	0e 94 f5 02 	call	0x5ea	; 0x5ea <DELAY_ms>
	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    16a8:	89 81       	ldd	r24, Y+1	; 0x01
    16aa:	8f 5f       	subi	r24, 0xFF	; 255
    16ac:	89 83       	std	Y+1, r24	; 0x01
    16ae:	89 81       	ldd	r24, Y+1	; 0x01
    16b0:	88 2f       	mov	r24, r24
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	2c 81       	ldd	r18, Y+4	; 0x04
    16b6:	3d 81       	ldd	r19, Y+5	; 0x05
    16b8:	82 0f       	add	r24, r18
    16ba:	93 1f       	adc	r25, r19
    16bc:	fc 01       	movw	r30, r24
    16be:	80 81       	ld	r24, Z
    16c0:	88 23       	and	r24, r24
    16c2:	09 f0       	breq	.+2      	; 0x16c6 <LCD_ScrollMessage+0xc2>
    16c4:	b4 cf       	rjmp	.-152    	; 0x162e <LCD_ScrollMessage+0x2a>
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);         // Finally enable the Cursor
    16c6:	8e e0       	ldi	r24, 0x0E	; 14
    16c8:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
}
    16cc:	0f 90       	pop	r0
    16ce:	0f 90       	pop	r0
    16d0:	0f 90       	pop	r0
    16d2:	0f 90       	pop	r0
    16d4:	0f 90       	pop	r0
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	08 95       	ret

000016dc <LCD_DisplayNumber>:
 8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
 9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	cd b7       	in	r28, 0x3d	; 61
    16e8:	de b7       	in	r29, 0x3e	; 62
    16ea:	69 97       	sbiw	r28, 0x19	; 25
    16ec:	0f b6       	in	r0, 0x3f	; 63
    16ee:	f8 94       	cli
    16f0:	de bf       	out	0x3e, r29	; 62
    16f2:	0f be       	out	0x3f, r0	; 63
    16f4:	cd bf       	out	0x3d, r28	; 61
    16f6:	8c 87       	std	Y+12, r24	; 0x0c
    16f8:	4d 87       	std	Y+13, r20	; 0x0d
    16fa:	5e 87       	std	Y+14, r21	; 0x0e
    16fc:	6f 87       	std	Y+15, r22	; 0x0f
    16fe:	78 8b       	std	Y+16, r23	; 0x10
    1700:	29 8b       	std	Y+17, r18	; 0x11
	uint8_t i = 0, a[10];
    1702:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    1704:	8c 85       	ldd	r24, Y+12	; 0x0c
    1706:	82 30       	cpi	r24, 0x02	; 2
    1708:	69 f5       	brne	.+90     	; 0x1764 <LCD_DisplayNumber+0x88>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    170a:	28 c0       	rjmp	.+80     	; 0x175c <LCD_DisplayNumber+0x80>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    170c:	89 89       	ldd	r24, Y+17	; 0x11
    170e:	88 2f       	mov	r24, r24
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	9c 01       	movw	r18, r24
    1714:	21 50       	subi	r18, 0x01	; 1
    1716:	31 09       	sbc	r19, r1
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	02 c0       	rjmp	.+4      	; 0x1722 <LCD_DisplayNumber+0x46>
    171e:	88 0f       	add	r24, r24
    1720:	99 1f       	adc	r25, r25
    1722:	2a 95       	dec	r18
    1724:	e2 f7       	brpl	.-8      	; 0x171e <LCD_DisplayNumber+0x42>
    1726:	9c 01       	movw	r18, r24
    1728:	44 27       	eor	r20, r20
    172a:	37 fd       	sbrc	r19, 7
    172c:	40 95       	com	r20
    172e:	54 2f       	mov	r21, r20
    1730:	8d 85       	ldd	r24, Y+13	; 0x0d
    1732:	9e 85       	ldd	r25, Y+14	; 0x0e
    1734:	af 85       	ldd	r26, Y+15	; 0x0f
    1736:	b8 89       	ldd	r27, Y+16	; 0x10
    1738:	82 23       	and	r24, r18
    173a:	93 23       	and	r25, r19
    173c:	a4 23       	and	r26, r20
    173e:	b5 23       	and	r27, r21
    1740:	21 e0       	ldi	r18, 0x01	; 1
    1742:	00 97       	sbiw	r24, 0x00	; 0
    1744:	a1 05       	cpc	r26, r1
    1746:	b1 05       	cpc	r27, r1
    1748:	09 f4       	brne	.+2      	; 0x174c <LCD_DisplayNumber+0x70>
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    174e:	89 81       	ldd	r24, Y+1	; 0x01
    1750:	80 5d       	subi	r24, 0xD0	; 208
    1752:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			v_numOfDigitsToDisplay_u8--;
    1756:	89 89       	ldd	r24, Y+17	; 0x11
    1758:	81 50       	subi	r24, 0x01	; 1
    175a:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    175c:	89 89       	ldd	r24, Y+17	; 0x11
    175e:	88 23       	and	r24, r24
    1760:	a9 f6       	brne	.-86     	; 0x170c <LCD_DisplayNumber+0x30>
    1762:	91 c0       	rjmp	.+290    	; 0x1886 <LCD_DisplayNumber+0x1aa>
			i = util_GetBitStatus(v_number_u32,
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    1764:	8d 85       	ldd	r24, Y+13	; 0x0d
    1766:	9e 85       	ldd	r25, Y+14	; 0x0e
    1768:	af 85       	ldd	r26, Y+15	; 0x0f
    176a:	b8 89       	ldd	r27, Y+16	; 0x10
    176c:	00 97       	sbiw	r24, 0x00	; 0
    176e:	a1 05       	cpc	r26, r1
    1770:	b1 05       	cpc	r27, r1
    1772:	21 f4       	brne	.+8      	; 0x177c <LCD_DisplayNumber+0xa0>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    1774:	80 e3       	ldi	r24, 0x30	; 48
    1776:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
    177a:	85 c0       	rjmp	.+266    	; 0x1886 <LCD_DisplayNumber+0x1aa>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    177c:	19 82       	std	Y+1, r1	; 0x01
    177e:	4f c0       	rjmp	.+158    	; 0x181e <LCD_DisplayNumber+0x142>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    1780:	8d 85       	ldd	r24, Y+13	; 0x0d
    1782:	9e 85       	ldd	r25, Y+14	; 0x0e
    1784:	af 85       	ldd	r26, Y+15	; 0x0f
    1786:	b8 89       	ldd	r27, Y+16	; 0x10
    1788:	00 97       	sbiw	r24, 0x00	; 0
    178a:	a1 05       	cpc	r26, r1
    178c:	b1 05       	cpc	r27, r1
    178e:	a1 f1       	breq	.+104    	; 0x17f8 <LCD_DisplayNumber+0x11c>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    1790:	89 81       	ldd	r24, Y+1	; 0x01
    1792:	08 2f       	mov	r16, r24
    1794:	10 e0       	ldi	r17, 0x00	; 0
    1796:	fd 84       	ldd	r15, Y+13	; 0x0d
    1798:	8c 85       	ldd	r24, Y+12	; 0x0c
    179a:	28 2f       	mov	r18, r24
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	40 e0       	ldi	r20, 0x00	; 0
    17a0:	50 e0       	ldi	r21, 0x00	; 0
    17a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    17a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    17a6:	af 85       	ldd	r26, Y+15	; 0x0f
    17a8:	b8 89       	ldd	r27, Y+16	; 0x10
    17aa:	bc 01       	movw	r22, r24
    17ac:	cd 01       	movw	r24, r26
    17ae:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    17b2:	da 01       	movw	r26, r20
    17b4:	c9 01       	movw	r24, r18
    17b6:	98 2f       	mov	r25, r24
    17b8:	8c 85       	ldd	r24, Y+12	; 0x0c
    17ba:	98 9f       	mul	r25, r24
    17bc:	80 2d       	mov	r24, r0
    17be:	11 24       	eor	r1, r1
    17c0:	2f 2d       	mov	r18, r15
    17c2:	28 1b       	sub	r18, r24
    17c4:	ce 01       	movw	r24, r28
    17c6:	02 96       	adiw	r24, 0x02	; 2
    17c8:	80 0f       	add	r24, r16
    17ca:	91 1f       	adc	r25, r17
    17cc:	fc 01       	movw	r30, r24
    17ce:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    17d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    17d2:	28 2f       	mov	r18, r24
    17d4:	30 e0       	ldi	r19, 0x00	; 0
    17d6:	40 e0       	ldi	r20, 0x00	; 0
    17d8:	50 e0       	ldi	r21, 0x00	; 0
    17da:	8d 85       	ldd	r24, Y+13	; 0x0d
    17dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    17de:	af 85       	ldd	r26, Y+15	; 0x0f
    17e0:	b8 89       	ldd	r27, Y+16	; 0x10
    17e2:	bc 01       	movw	r22, r24
    17e4:	cd 01       	movw	r24, r26
    17e6:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    17ea:	da 01       	movw	r26, r20
    17ec:	c9 01       	movw	r24, r18
    17ee:	8d 87       	std	Y+13, r24	; 0x0d
    17f0:	9e 87       	std	Y+14, r25	; 0x0e
    17f2:	af 87       	std	Y+15, r26	; 0x0f
    17f4:	b8 8b       	std	Y+16, r27	; 0x10
    17f6:	10 c0       	rjmp	.+32     	; 0x1818 <LCD_DisplayNumber+0x13c>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    17f8:	89 89       	ldd	r24, Y+17	; 0x11
    17fa:	8f 3f       	cpi	r24, 0xFF	; 255
    17fc:	a9 f0       	breq	.+42     	; 0x1828 <LCD_DisplayNumber+0x14c>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    17fe:	89 89       	ldd	r24, Y+17	; 0x11
    1800:	8b 30       	cpi	r24, 0x0B	; 11
    1802:	90 f4       	brcc	.+36     	; 0x1828 <LCD_DisplayNumber+0x14c>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    1804:	89 81       	ldd	r24, Y+1	; 0x01
    1806:	88 2f       	mov	r24, r24
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	9e 01       	movw	r18, r28
    180c:	2e 5f       	subi	r18, 0xFE	; 254
    180e:	3f 4f       	sbci	r19, 0xFF	; 255
    1810:	82 0f       	add	r24, r18
    1812:	93 1f       	adc	r25, r19
    1814:	fc 01       	movw	r30, r24
    1816:	10 82       	st	Z, r1
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    1818:	89 81       	ldd	r24, Y+1	; 0x01
    181a:	8f 5f       	subi	r24, 0xFF	; 255
    181c:	89 83       	std	Y+1, r24	; 0x01
    181e:	99 81       	ldd	r25, Y+1	; 0x01
    1820:	89 89       	ldd	r24, Y+17	; 0x11
    1822:	98 17       	cp	r25, r24
    1824:	08 f4       	brcc	.+2      	; 0x1828 <LCD_DisplayNumber+0x14c>
    1826:	ac cf       	rjmp	.-168    	; 0x1780 <LCD_DisplayNumber+0xa4>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    1828:	2b c0       	rjmp	.+86     	; 0x1880 <LCD_DisplayNumber+0x1a4>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    182a:	89 81       	ldd	r24, Y+1	; 0x01
    182c:	88 2f       	mov	r24, r24
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	01 97       	sbiw	r24, 0x01	; 1
    1832:	9e 01       	movw	r18, r28
    1834:	2e 5f       	subi	r18, 0xFE	; 254
    1836:	3f 4f       	sbci	r19, 0xFF	; 255
    1838:	82 0f       	add	r24, r18
    183a:	93 1f       	adc	r25, r19
    183c:	fc 01       	movw	r30, r24
    183e:	80 81       	ld	r24, Z
    1840:	8a 30       	cpi	r24, 0x0A	; 10
    1842:	68 f0       	brcs	.+26     	; 0x185e <LCD_DisplayNumber+0x182>
    1844:	89 81       	ldd	r24, Y+1	; 0x01
    1846:	88 2f       	mov	r24, r24
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	01 97       	sbiw	r24, 0x01	; 1
    184c:	9e 01       	movw	r18, r28
    184e:	2e 5f       	subi	r18, 0xFE	; 254
    1850:	3f 4f       	sbci	r19, 0xFF	; 255
    1852:	82 0f       	add	r24, r18
    1854:	93 1f       	adc	r25, r19
    1856:	fc 01       	movw	r30, r24
    1858:	80 81       	ld	r24, Z
    185a:	89 5c       	subi	r24, 0xC9	; 201
    185c:	0c c0       	rjmp	.+24     	; 0x1876 <LCD_DisplayNumber+0x19a>
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	88 2f       	mov	r24, r24
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9e 01       	movw	r18, r28
    1868:	2e 5f       	subi	r18, 0xFE	; 254
    186a:	3f 4f       	sbci	r19, 0xFF	; 255
    186c:	82 0f       	add	r24, r18
    186e:	93 1f       	adc	r25, r19
    1870:	fc 01       	movw	r30, r24
    1872:	80 81       	ld	r24, Z
    1874:	80 5d       	subi	r24, 0xD0	; 208
    1876:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			i--;
    187a:	89 81       	ldd	r24, Y+1	; 0x01
    187c:	81 50       	subi	r24, 0x01	; 1
    187e:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    1880:	89 81       	ldd	r24, Y+1	; 0x01
    1882:	88 23       	and	r24, r24
    1884:	91 f6       	brne	.-92     	; 0x182a <LCD_DisplayNumber+0x14e>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
			i--;
		}
	}
}
    1886:	69 96       	adiw	r28, 0x19	; 25
    1888:	0f b6       	in	r0, 0x3f	; 63
    188a:	f8 94       	cli
    188c:	de bf       	out	0x3e, r29	; 62
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	cd bf       	out	0x3d, r28	; 61
    1892:	df 91       	pop	r29
    1894:	cf 91       	pop	r28
    1896:	1f 91       	pop	r17
    1898:	0f 91       	pop	r16
    189a:	ff 90       	pop	r15
    189c:	08 95       	ret

0000189e <LCD_DisplayNumberWithAddingToBuffor>:
#endif

#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
    189e:	ef 92       	push	r14
    18a0:	ff 92       	push	r15
    18a2:	0f 93       	push	r16
    18a4:	1f 93       	push	r17
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62
    18ae:	6d 97       	sbiw	r28, 0x1d	; 29
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	de bf       	out	0x3e, r29	; 62
    18b6:	0f be       	out	0x3f, r0	; 63
    18b8:	cd bf       	out	0x3d, r28	; 61
    18ba:	8c 87       	std	Y+12, r24	; 0x0c
    18bc:	4d 87       	std	Y+13, r20	; 0x0d
    18be:	5e 87       	std	Y+14, r21	; 0x0e
    18c0:	6f 87       	std	Y+15, r22	; 0x0f
    18c2:	78 8b       	std	Y+16, r23	; 0x10
    18c4:	29 8b       	std	Y+17, r18	; 0x11
    18c6:	1b 8b       	std	Y+19, r17	; 0x13
    18c8:	0a 8b       	std	Y+18, r16	; 0x12
    18ca:	fd 8a       	std	Y+21, r15	; 0x15
    18cc:	ec 8a       	std	Y+20, r14	; 0x14
	uint8_t i = 0, a[10];
    18ce:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    18d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    18d2:	82 30       	cpi	r24, 0x02	; 2
    18d4:	09 f0       	breq	.+2      	; 0x18d8 <LCD_DisplayNumberWithAddingToBuffor+0x3a>
    18d6:	51 c0       	rjmp	.+162    	; 0x197a <LCD_DisplayNumberWithAddingToBuffor+0xdc>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    18d8:	4b c0       	rjmp	.+150    	; 0x1970 <LCD_DisplayNumberWithAddingToBuffor+0xd2>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    18da:	89 89       	ldd	r24, Y+17	; 0x11
    18dc:	88 2f       	mov	r24, r24
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	9c 01       	movw	r18, r24
    18e2:	21 50       	subi	r18, 0x01	; 1
    18e4:	31 09       	sbc	r19, r1
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	02 c0       	rjmp	.+4      	; 0x18f0 <LCD_DisplayNumberWithAddingToBuffor+0x52>
    18ec:	88 0f       	add	r24, r24
    18ee:	99 1f       	adc	r25, r25
    18f0:	2a 95       	dec	r18
    18f2:	e2 f7       	brpl	.-8      	; 0x18ec <LCD_DisplayNumberWithAddingToBuffor+0x4e>
    18f4:	9c 01       	movw	r18, r24
    18f6:	44 27       	eor	r20, r20
    18f8:	37 fd       	sbrc	r19, 7
    18fa:	40 95       	com	r20
    18fc:	54 2f       	mov	r21, r20
    18fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1900:	9e 85       	ldd	r25, Y+14	; 0x0e
    1902:	af 85       	ldd	r26, Y+15	; 0x0f
    1904:	b8 89       	ldd	r27, Y+16	; 0x10
    1906:	82 23       	and	r24, r18
    1908:	93 23       	and	r25, r19
    190a:	a4 23       	and	r26, r20
    190c:	b5 23       	and	r27, r21
    190e:	21 e0       	ldi	r18, 0x01	; 1
    1910:	00 97       	sbiw	r24, 0x00	; 0
    1912:	a1 05       	cpc	r26, r1
    1914:	b1 05       	cpc	r27, r1
    1916:	09 f4       	brne	.+2      	; 0x191a <LCD_DisplayNumberWithAddingToBuffor+0x7c>
    1918:	20 e0       	ldi	r18, 0x00	; 0
    191a:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	80 5d       	subi	r24, 0xD0	; 208
    1920:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
    1924:	8a 89       	ldd	r24, Y+18	; 0x12
    1926:	9b 89       	ldd	r25, Y+19	; 0x13
    1928:	fc 01       	movw	r30, r24
    192a:	80 81       	ld	r24, Z
    192c:	91 81       	ldd	r25, Z+1	; 0x01
    192e:	29 81       	ldd	r18, Y+1	; 0x01
    1930:	40 e3       	ldi	r20, 0x30	; 48
    1932:	42 0f       	add	r20, r18
    1934:	2c 89       	ldd	r18, Y+20	; 0x14
    1936:	3d 89       	ldd	r19, Y+21	; 0x15
    1938:	22 95       	swap	r18
    193a:	32 95       	swap	r19
    193c:	30 7f       	andi	r19, 0xF0	; 240
    193e:	32 27       	eor	r19, r18
    1940:	20 7f       	andi	r18, 0xF0	; 240
    1942:	32 27       	eor	r19, r18
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	8e 54       	subi	r24, 0x4E	; 78
    194a:	9f 4f       	sbci	r25, 0xFF	; 255
    194c:	fc 01       	movw	r30, r24
    194e:	40 83       	st	Z, r20
			(*x)++;
    1950:	8a 89       	ldd	r24, Y+18	; 0x12
    1952:	9b 89       	ldd	r25, Y+19	; 0x13
    1954:	fc 01       	movw	r30, r24
    1956:	80 81       	ld	r24, Z
    1958:	91 81       	ldd	r25, Z+1	; 0x01
    195a:	9c 01       	movw	r18, r24
    195c:	2f 5f       	subi	r18, 0xFF	; 255
    195e:	3f 4f       	sbci	r19, 0xFF	; 255
    1960:	8a 89       	ldd	r24, Y+18	; 0x12
    1962:	9b 89       	ldd	r25, Y+19	; 0x13
    1964:	fc 01       	movw	r30, r24
    1966:	31 83       	std	Z+1, r19	; 0x01
    1968:	20 83       	st	Z, r18
			v_numOfDigitsToDisplay_u8--;
    196a:	89 89       	ldd	r24, Y+17	; 0x11
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    1970:	89 89       	ldd	r24, Y+17	; 0x11
    1972:	88 23       	and	r24, r24
    1974:	09 f0       	breq	.+2      	; 0x1978 <LCD_DisplayNumberWithAddingToBuffor+0xda>
    1976:	b1 cf       	rjmp	.-158    	; 0x18da <LCD_DisplayNumberWithAddingToBuffor+0x3c>
    1978:	fe c0       	rjmp	.+508    	; 0x1b76 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
			LCD_DisplayChar(util_Dec2Ascii(i));
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
			(*x)++;
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    197a:	8d 85       	ldd	r24, Y+13	; 0x0d
    197c:	9e 85       	ldd	r25, Y+14	; 0x0e
    197e:	af 85       	ldd	r26, Y+15	; 0x0f
    1980:	b8 89       	ldd	r27, Y+16	; 0x10
    1982:	00 97       	sbiw	r24, 0x00	; 0
    1984:	a1 05       	cpc	r26, r1
    1986:	b1 05       	cpc	r27, r1
    1988:	29 f5       	brne	.+74     	; 0x19d4 <LCD_DisplayNumberWithAddingToBuffor+0x136>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    198a:	80 e3       	ldi	r24, 0x30	; 48
    198c:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
		LCD_BUFFOR[y][(*x)] = '0';
    1990:	8a 89       	ldd	r24, Y+18	; 0x12
    1992:	9b 89       	ldd	r25, Y+19	; 0x13
    1994:	fc 01       	movw	r30, r24
    1996:	80 81       	ld	r24, Z
    1998:	91 81       	ldd	r25, Z+1	; 0x01
    199a:	2c 89       	ldd	r18, Y+20	; 0x14
    199c:	3d 89       	ldd	r19, Y+21	; 0x15
    199e:	22 95       	swap	r18
    19a0:	32 95       	swap	r19
    19a2:	30 7f       	andi	r19, 0xF0	; 240
    19a4:	32 27       	eor	r19, r18
    19a6:	20 7f       	andi	r18, 0xF0	; 240
    19a8:	32 27       	eor	r19, r18
    19aa:	82 0f       	add	r24, r18
    19ac:	93 1f       	adc	r25, r19
    19ae:	8e 54       	subi	r24, 0x4E	; 78
    19b0:	9f 4f       	sbci	r25, 0xFF	; 255
    19b2:	20 e3       	ldi	r18, 0x30	; 48
    19b4:	fc 01       	movw	r30, r24
    19b6:	20 83       	st	Z, r18
		(*x)++;
    19b8:	8a 89       	ldd	r24, Y+18	; 0x12
    19ba:	9b 89       	ldd	r25, Y+19	; 0x13
    19bc:	fc 01       	movw	r30, r24
    19be:	80 81       	ld	r24, Z
    19c0:	91 81       	ldd	r25, Z+1	; 0x01
    19c2:	9c 01       	movw	r18, r24
    19c4:	2f 5f       	subi	r18, 0xFF	; 255
    19c6:	3f 4f       	sbci	r19, 0xFF	; 255
    19c8:	8a 89       	ldd	r24, Y+18	; 0x12
    19ca:	9b 89       	ldd	r25, Y+19	; 0x13
    19cc:	fc 01       	movw	r30, r24
    19ce:	31 83       	std	Z+1, r19	; 0x01
    19d0:	20 83       	st	Z, r18
    19d2:	d1 c0       	rjmp	.+418    	; 0x1b76 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    19d4:	19 82       	std	Y+1, r1	; 0x01
    19d6:	4f c0       	rjmp	.+158    	; 0x1a76 <LCD_DisplayNumberWithAddingToBuffor+0x1d8>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    19d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    19da:	9e 85       	ldd	r25, Y+14	; 0x0e
    19dc:	af 85       	ldd	r26, Y+15	; 0x0f
    19de:	b8 89       	ldd	r27, Y+16	; 0x10
    19e0:	00 97       	sbiw	r24, 0x00	; 0
    19e2:	a1 05       	cpc	r26, r1
    19e4:	b1 05       	cpc	r27, r1
    19e6:	a1 f1       	breq	.+104    	; 0x1a50 <LCD_DisplayNumberWithAddingToBuffor+0x1b2>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	08 2f       	mov	r16, r24
    19ec:	10 e0       	ldi	r17, 0x00	; 0
    19ee:	fd 84       	ldd	r15, Y+13	; 0x0d
    19f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    19f2:	28 2f       	mov	r18, r24
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	40 e0       	ldi	r20, 0x00	; 0
    19f8:	50 e0       	ldi	r21, 0x00	; 0
    19fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    19fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    19fe:	af 85       	ldd	r26, Y+15	; 0x0f
    1a00:	b8 89       	ldd	r27, Y+16	; 0x10
    1a02:	bc 01       	movw	r22, r24
    1a04:	cd 01       	movw	r24, r26
    1a06:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    1a0a:	da 01       	movw	r26, r20
    1a0c:	c9 01       	movw	r24, r18
    1a0e:	98 2f       	mov	r25, r24
    1a10:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a12:	98 9f       	mul	r25, r24
    1a14:	80 2d       	mov	r24, r0
    1a16:	11 24       	eor	r1, r1
    1a18:	2f 2d       	mov	r18, r15
    1a1a:	28 1b       	sub	r18, r24
    1a1c:	ce 01       	movw	r24, r28
    1a1e:	02 96       	adiw	r24, 0x02	; 2
    1a20:	80 0f       	add	r24, r16
    1a22:	91 1f       	adc	r25, r17
    1a24:	fc 01       	movw	r30, r24
    1a26:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    1a28:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a2a:	28 2f       	mov	r18, r24
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	40 e0       	ldi	r20, 0x00	; 0
    1a30:	50 e0       	ldi	r21, 0x00	; 0
    1a32:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a34:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a36:	af 85       	ldd	r26, Y+15	; 0x0f
    1a38:	b8 89       	ldd	r27, Y+16	; 0x10
    1a3a:	bc 01       	movw	r22, r24
    1a3c:	cd 01       	movw	r24, r26
    1a3e:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    1a42:	da 01       	movw	r26, r20
    1a44:	c9 01       	movw	r24, r18
    1a46:	8d 87       	std	Y+13, r24	; 0x0d
    1a48:	9e 87       	std	Y+14, r25	; 0x0e
    1a4a:	af 87       	std	Y+15, r26	; 0x0f
    1a4c:	b8 8b       	std	Y+16, r27	; 0x10
    1a4e:	10 c0       	rjmp	.+32     	; 0x1a70 <LCD_DisplayNumberWithAddingToBuffor+0x1d2>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    1a50:	89 89       	ldd	r24, Y+17	; 0x11
    1a52:	8f 3f       	cpi	r24, 0xFF	; 255
    1a54:	a9 f0       	breq	.+42     	; 0x1a80 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    1a56:	89 89       	ldd	r24, Y+17	; 0x11
    1a58:	8b 30       	cpi	r24, 0x0B	; 11
    1a5a:	90 f4       	brcc	.+36     	; 0x1a80 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	88 2f       	mov	r24, r24
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	9e 01       	movw	r18, r28
    1a64:	2e 5f       	subi	r18, 0xFE	; 254
    1a66:	3f 4f       	sbci	r19, 0xFF	; 255
    1a68:	82 0f       	add	r24, r18
    1a6a:	93 1f       	adc	r25, r19
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	10 82       	st	Z, r1
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
		LCD_BUFFOR[y][(*x)] = '0';
		(*x)++;
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	8f 5f       	subi	r24, 0xFF	; 255
    1a74:	89 83       	std	Y+1, r24	; 0x01
    1a76:	99 81       	ldd	r25, Y+1	; 0x01
    1a78:	89 89       	ldd	r24, Y+17	; 0x11
    1a7a:	98 17       	cp	r25, r24
    1a7c:	08 f4       	brcc	.+2      	; 0x1a80 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
    1a7e:	ac cf       	rjmp	.-168    	; 0x19d8 <LCD_DisplayNumberWithAddingToBuffor+0x13a>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    1a80:	76 c0       	rjmp	.+236    	; 0x1b6e <LCD_DisplayNumberWithAddingToBuffor+0x2d0>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    1a82:	89 81       	ldd	r24, Y+1	; 0x01
    1a84:	88 2f       	mov	r24, r24
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	9e 01       	movw	r18, r28
    1a8c:	2e 5f       	subi	r18, 0xFE	; 254
    1a8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a90:	82 0f       	add	r24, r18
    1a92:	93 1f       	adc	r25, r19
    1a94:	fc 01       	movw	r30, r24
    1a96:	80 81       	ld	r24, Z
    1a98:	8a 30       	cpi	r24, 0x0A	; 10
    1a9a:	68 f0       	brcs	.+26     	; 0x1ab6 <LCD_DisplayNumberWithAddingToBuffor+0x218>
    1a9c:	89 81       	ldd	r24, Y+1	; 0x01
    1a9e:	88 2f       	mov	r24, r24
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	01 97       	sbiw	r24, 0x01	; 1
    1aa4:	9e 01       	movw	r18, r28
    1aa6:	2e 5f       	subi	r18, 0xFE	; 254
    1aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aaa:	82 0f       	add	r24, r18
    1aac:	93 1f       	adc	r25, r19
    1aae:	fc 01       	movw	r30, r24
    1ab0:	80 81       	ld	r24, Z
    1ab2:	89 5c       	subi	r24, 0xC9	; 201
    1ab4:	0c c0       	rjmp	.+24     	; 0x1ace <LCD_DisplayNumberWithAddingToBuffor+0x230>
    1ab6:	89 81       	ldd	r24, Y+1	; 0x01
    1ab8:	88 2f       	mov	r24, r24
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	01 97       	sbiw	r24, 0x01	; 1
    1abe:	9e 01       	movw	r18, r28
    1ac0:	2e 5f       	subi	r18, 0xFE	; 254
    1ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ac4:	82 0f       	add	r24, r18
    1ac6:	93 1f       	adc	r25, r19
    1ac8:	fc 01       	movw	r30, r24
    1aca:	80 81       	ld	r24, Z
    1acc:	80 5d       	subi	r24, 0xD0	; 208
    1ace:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
    1ad2:	8a 89       	ldd	r24, Y+18	; 0x12
    1ad4:	9b 89       	ldd	r25, Y+19	; 0x13
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	80 81       	ld	r24, Z
    1ada:	91 81       	ldd	r25, Z+1	; 0x01
    1adc:	29 81       	ldd	r18, Y+1	; 0x01
    1ade:	22 2f       	mov	r18, r18
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	21 50       	subi	r18, 0x01	; 1
    1ae4:	31 09       	sbc	r19, r1
    1ae6:	ae 01       	movw	r20, r28
    1ae8:	4e 5f       	subi	r20, 0xFE	; 254
    1aea:	5f 4f       	sbci	r21, 0xFF	; 255
    1aec:	24 0f       	add	r18, r20
    1aee:	35 1f       	adc	r19, r21
    1af0:	f9 01       	movw	r30, r18
    1af2:	20 81       	ld	r18, Z
    1af4:	2a 30       	cpi	r18, 0x0A	; 10
    1af6:	78 f0       	brcs	.+30     	; 0x1b16 <LCD_DisplayNumberWithAddingToBuffor+0x278>
    1af8:	29 81       	ldd	r18, Y+1	; 0x01
    1afa:	22 2f       	mov	r18, r18
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	21 50       	subi	r18, 0x01	; 1
    1b00:	31 09       	sbc	r19, r1
    1b02:	ae 01       	movw	r20, r28
    1b04:	4e 5f       	subi	r20, 0xFE	; 254
    1b06:	5f 4f       	sbci	r21, 0xFF	; 255
    1b08:	24 0f       	add	r18, r20
    1b0a:	35 1f       	adc	r19, r21
    1b0c:	f9 01       	movw	r30, r18
    1b0e:	20 81       	ld	r18, Z
    1b10:	47 e3       	ldi	r20, 0x37	; 55
    1b12:	42 0f       	add	r20, r18
    1b14:	0e c0       	rjmp	.+28     	; 0x1b32 <LCD_DisplayNumberWithAddingToBuffor+0x294>
    1b16:	29 81       	ldd	r18, Y+1	; 0x01
    1b18:	22 2f       	mov	r18, r18
    1b1a:	30 e0       	ldi	r19, 0x00	; 0
    1b1c:	21 50       	subi	r18, 0x01	; 1
    1b1e:	31 09       	sbc	r19, r1
    1b20:	ae 01       	movw	r20, r28
    1b22:	4e 5f       	subi	r20, 0xFE	; 254
    1b24:	5f 4f       	sbci	r21, 0xFF	; 255
    1b26:	24 0f       	add	r18, r20
    1b28:	35 1f       	adc	r19, r21
    1b2a:	f9 01       	movw	r30, r18
    1b2c:	20 81       	ld	r18, Z
    1b2e:	40 e3       	ldi	r20, 0x30	; 48
    1b30:	42 0f       	add	r20, r18
    1b32:	2c 89       	ldd	r18, Y+20	; 0x14
    1b34:	3d 89       	ldd	r19, Y+21	; 0x15
    1b36:	22 95       	swap	r18
    1b38:	32 95       	swap	r19
    1b3a:	30 7f       	andi	r19, 0xF0	; 240
    1b3c:	32 27       	eor	r19, r18
    1b3e:	20 7f       	andi	r18, 0xF0	; 240
    1b40:	32 27       	eor	r19, r18
    1b42:	82 0f       	add	r24, r18
    1b44:	93 1f       	adc	r25, r19
    1b46:	8e 54       	subi	r24, 0x4E	; 78
    1b48:	9f 4f       	sbci	r25, 0xFF	; 255
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	40 83       	st	Z, r20
			(*x)++;
    1b4e:	8a 89       	ldd	r24, Y+18	; 0x12
    1b50:	9b 89       	ldd	r25, Y+19	; 0x13
    1b52:	fc 01       	movw	r30, r24
    1b54:	80 81       	ld	r24, Z
    1b56:	91 81       	ldd	r25, Z+1	; 0x01
    1b58:	9c 01       	movw	r18, r24
    1b5a:	2f 5f       	subi	r18, 0xFF	; 255
    1b5c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b5e:	8a 89       	ldd	r24, Y+18	; 0x12
    1b60:	9b 89       	ldd	r25, Y+19	; 0x13
    1b62:	fc 01       	movw	r30, r24
    1b64:	31 83       	std	Z+1, r19	; 0x01
    1b66:	20 83       	st	Z, r18
			i--;
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	81 50       	subi	r24, 0x01	; 1
    1b6c:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	88 23       	and	r24, r24
    1b72:	09 f0       	breq	.+2      	; 0x1b76 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
    1b74:	86 cf       	rjmp	.-244    	; 0x1a82 <LCD_DisplayNumberWithAddingToBuffor+0x1e4>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
			(*x)++;
			i--;
		}
	}
}
    1b76:	6d 96       	adiw	r28, 0x1d	; 29
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	f8 94       	cli
    1b7c:	de bf       	out	0x3e, r29	; 62
    1b7e:	0f be       	out	0x3f, r0	; 63
    1b80:	cd bf       	out	0x3d, r28	; 61
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	1f 91       	pop	r17
    1b88:	0f 91       	pop	r16
    1b8a:	ff 90       	pop	r15
    1b8c:	ef 90       	pop	r14
    1b8e:	08 95       	ret

00001b90 <LCD_XYPrintf>:
 #####: In case of printing the 8-bit variables, it is recommended to type cast and promote them to uint16_t.
 uint8_t v_Num_u8;
 LCD_Printf("num1:%u",(uint16_t)v_Num_u8);
 **************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_XYPrintf(int x, int y, const char *argList, ...) {
    1b90:	ef 92       	push	r14
    1b92:	ff 92       	push	r15
    1b94:	0f 93       	push	r16
    1b96:	1f 93       	push	r17
    1b98:	cf 93       	push	r28
    1b9a:	df 93       	push	r29
    1b9c:	cd b7       	in	r28, 0x3d	; 61
    1b9e:	de b7       	in	r29, 0x3e	; 62
    1ba0:	66 97       	sbiw	r28, 0x16	; 22
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	de bf       	out	0x3e, r29	; 62
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	cd bf       	out	0x3d, r28	; 61
	LCD_SetCursor(y, x);
    1bac:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1bae:	89 a1       	ldd	r24, Y+33	; 0x21
    1bb0:	69 2f       	mov	r22, r25
    1bb2:	0e 94 24 08 	call	0x1048	; 0x1048 <LCD_SetCursor>
	int tmpX = x;
    1bb6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1bb8:	98 a1       	ldd	r25, Y+32	; 0x20
    1bba:	9c 8b       	std	Y+20, r25	; 0x14
    1bbc:	8b 8b       	std	Y+19, r24	; 0x13
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    1bbe:	ce 01       	movw	r24, r28
    1bc0:	85 96       	adiw	r24, 0x25	; 37
    1bc2:	9e 8b       	std	Y+22, r25	; 0x16
    1bc4:	8d 8b       	std	Y+21, r24	; 0x15

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    1bc6:	8b a1       	ldd	r24, Y+35	; 0x23
    1bc8:	9c a1       	ldd	r25, Y+36	; 0x24
    1bca:	9a 83       	std	Y+2, r25	; 0x02
    1bcc:	89 83       	std	Y+1, r24	; 0x01
    1bce:	61 c3       	rjmp	.+1730   	; 0x2292 <LCD_XYPrintf+0x702>
		ch = *ptr;
    1bd0:	89 81       	ldd	r24, Y+1	; 0x01
    1bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd4:	fc 01       	movw	r30, r24
    1bd6:	80 81       	ld	r24, Z
    1bd8:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    1bda:	89 85       	ldd	r24, Y+9	; 0x09
    1bdc:	85 32       	cpi	r24, 0x25	; 37
    1bde:	09 f0       	breq	.+2      	; 0x1be2 <LCD_XYPrintf+0x52>
    1be0:	3a c3       	rjmp	.+1652   	; 0x2256 <LCD_XYPrintf+0x6c6>
		{
			ptr++;
    1be2:	89 81       	ldd	r24, Y+1	; 0x01
    1be4:	9a 81       	ldd	r25, Y+2	; 0x02
    1be6:	01 96       	adiw	r24, 0x01	; 1
    1be8:	9a 83       	std	Y+2, r25	; 0x02
    1bea:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    1bec:	89 81       	ldd	r24, Y+1	; 0x01
    1bee:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf0:	fc 01       	movw	r30, r24
    1bf2:	80 81       	ld	r24, Z
    1bf4:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    1bf6:	89 85       	ldd	r24, Y+9	; 0x09
    1bf8:	80 33       	cpi	r24, 0x30	; 48
    1bfa:	00 f1       	brcs	.+64     	; 0x1c3c <LCD_XYPrintf+0xac>
    1bfc:	89 85       	ldd	r24, Y+9	; 0x09
    1bfe:	8a 33       	cpi	r24, 0x3A	; 58
    1c00:	e8 f4       	brcc	.+58     	; 0x1c3c <LCD_XYPrintf+0xac>
				v_numOfDigitsToDisp_u8 = 0;
    1c02:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    1c04:	14 c0       	rjmp	.+40     	; 0x1c2e <LCD_XYPrintf+0x9e>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    1c06:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c08:	88 0f       	add	r24, r24
    1c0a:	98 2f       	mov	r25, r24
    1c0c:	99 0f       	add	r25, r25
    1c0e:	99 0f       	add	r25, r25
    1c10:	98 0f       	add	r25, r24
    1c12:	89 85       	ldd	r24, Y+9	; 0x09
    1c14:	89 0f       	add	r24, r25
    1c16:	80 53       	subi	r24, 0x30	; 48
    1c18:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    1c1a:	89 81       	ldd	r24, Y+1	; 0x01
    1c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1e:	01 96       	adiw	r24, 0x01	; 1
    1c20:	9a 83       	std	Y+2, r25	; 0x02
    1c22:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    1c24:	89 81       	ldd	r24, Y+1	; 0x01
    1c26:	9a 81       	ldd	r25, Y+2	; 0x02
    1c28:	fc 01       	movw	r30, r24
    1c2a:	80 81       	ld	r24, Z
    1c2c:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    1c2e:	89 85       	ldd	r24, Y+9	; 0x09
    1c30:	80 33       	cpi	r24, 0x30	; 48
    1c32:	18 f0       	brcs	.+6      	; 0x1c3a <LCD_XYPrintf+0xaa>
    1c34:	89 85       	ldd	r24, Y+9	; 0x09
    1c36:	8a 33       	cpi	r24, 0x3A	; 58
    1c38:	30 f3       	brcs	.-52     	; 0x1c06 <LCD_XYPrintf+0x76>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    1c3a:	02 c0       	rjmp	.+4      	; 0x1c40 <LCD_XYPrintf+0xb0>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    1c3c:	8f ef       	ldi	r24, 0xFF	; 255
    1c3e:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    1c40:	89 85       	ldd	r24, Y+9	; 0x09
    1c42:	88 2f       	mov	r24, r24
    1c44:	90 e0       	ldi	r25, 0x00	; 0
    1c46:	aa 27       	eor	r26, r26
    1c48:	97 fd       	sbrc	r25, 7
    1c4a:	a0 95       	com	r26
    1c4c:	ba 2f       	mov	r27, r26
    1c4e:	45 e2       	ldi	r20, 0x25	; 37
    1c50:	50 e0       	ldi	r21, 0x00	; 0
    1c52:	28 e5       	ldi	r18, 0x58	; 88
    1c54:	30 e0       	ldi	r19, 0x00	; 0
    1c56:	84 1b       	sub	r24, r20
    1c58:	95 0b       	sbc	r25, r21
    1c5a:	28 17       	cp	r18, r24
    1c5c:	39 07       	cpc	r19, r25
    1c5e:	08 f4       	brcc	.+2      	; 0x1c62 <LCD_XYPrintf+0xd2>
    1c60:	13 c3       	rjmp	.+1574   	; 0x2288 <LCD_XYPrintf+0x6f8>
    1c62:	8d 57       	subi	r24, 0x7D	; 125
    1c64:	9f 4f       	sbci	r25, 0xFF	; 255
    1c66:	fc 01       	movw	r30, r24
    1c68:	0c 94 47 1a 	jmp	0x348e	; 0x348e <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '>';
    1c74:	8b 89       	ldd	r24, Y+19	; 0x13
    1c76:	9c 89       	ldd	r25, Y+20	; 0x14
    1c78:	29 a1       	ldd	r18, Y+33	; 0x21
    1c7a:	3a a1       	ldd	r19, Y+34	; 0x22
    1c7c:	22 95       	swap	r18
    1c7e:	32 95       	swap	r19
    1c80:	30 7f       	andi	r19, 0xF0	; 240
    1c82:	32 27       	eor	r19, r18
    1c84:	20 7f       	andi	r18, 0xF0	; 240
    1c86:	32 27       	eor	r19, r18
    1c88:	82 0f       	add	r24, r18
    1c8a:	93 1f       	adc	r25, r19
    1c8c:	8e 54       	subi	r24, 0x4E	; 78
    1c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c90:	2e e3       	ldi	r18, 0x3E	; 62
    1c92:	fc 01       	movw	r30, r24
    1c94:	20 83       	st	Z, r18
				tmpX++;
    1c96:	8b 89       	ldd	r24, Y+19	; 0x13
    1c98:	9c 89       	ldd	r25, Y+20	; 0x14
    1c9a:	01 96       	adiw	r24, 0x01	; 1
    1c9c:	9c 8b       	std	Y+20, r25	; 0x14
    1c9e:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1ca0:	d9 c2       	rjmp	.+1458   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '<':
				LCD_PrintSymbol(2);
    1ca2:	82 e0       	ldi	r24, 0x02	; 2
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '<';
    1caa:	8b 89       	ldd	r24, Y+19	; 0x13
    1cac:	9c 89       	ldd	r25, Y+20	; 0x14
    1cae:	29 a1       	ldd	r18, Y+33	; 0x21
    1cb0:	3a a1       	ldd	r19, Y+34	; 0x22
    1cb2:	22 95       	swap	r18
    1cb4:	32 95       	swap	r19
    1cb6:	30 7f       	andi	r19, 0xF0	; 240
    1cb8:	32 27       	eor	r19, r18
    1cba:	20 7f       	andi	r18, 0xF0	; 240
    1cbc:	32 27       	eor	r19, r18
    1cbe:	82 0f       	add	r24, r18
    1cc0:	93 1f       	adc	r25, r19
    1cc2:	8e 54       	subi	r24, 0x4E	; 78
    1cc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1cc6:	2c e3       	ldi	r18, 0x3C	; 60
    1cc8:	fc 01       	movw	r30, r24
    1cca:	20 83       	st	Z, r18
				tmpX++;
    1ccc:	8b 89       	ldd	r24, Y+19	; 0x13
    1cce:	9c 89       	ldd	r25, Y+20	; 0x14
    1cd0:	01 96       	adiw	r24, 0x01	; 1
    1cd2:	9c 8b       	std	Y+20, r25	; 0x14
    1cd4:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1cd6:	be c2       	rjmp	.+1404   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '|':
				LCD_PrintSymbol(3);
    1cd8:	83 e0       	ldi	r24, 0x03	; 3
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '|';
    1ce0:	8b 89       	ldd	r24, Y+19	; 0x13
    1ce2:	9c 89       	ldd	r25, Y+20	; 0x14
    1ce4:	29 a1       	ldd	r18, Y+33	; 0x21
    1ce6:	3a a1       	ldd	r19, Y+34	; 0x22
    1ce8:	22 95       	swap	r18
    1cea:	32 95       	swap	r19
    1cec:	30 7f       	andi	r19, 0xF0	; 240
    1cee:	32 27       	eor	r19, r18
    1cf0:	20 7f       	andi	r18, 0xF0	; 240
    1cf2:	32 27       	eor	r19, r18
    1cf4:	82 0f       	add	r24, r18
    1cf6:	93 1f       	adc	r25, r19
    1cf8:	8e 54       	subi	r24, 0x4E	; 78
    1cfa:	9f 4f       	sbci	r25, 0xFF	; 255
    1cfc:	2c e7       	ldi	r18, 0x7C	; 124
    1cfe:	fc 01       	movw	r30, r24
    1d00:	20 83       	st	Z, r18
				tmpX++;
    1d02:	8b 89       	ldd	r24, Y+19	; 0x13
    1d04:	9c 89       	ldd	r25, Y+20	; 0x14
    1d06:	01 96       	adiw	r24, 0x01	; 1
    1d08:	9c 8b       	std	Y+20, r25	; 0x14
    1d0a:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1d0c:	a3 c2       	rjmp	.+1350   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '{':
				LCD_PrintSymbol(4);
    1d0e:	84 e0       	ldi	r24, 0x04	; 4
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '{';
    1d16:	8b 89       	ldd	r24, Y+19	; 0x13
    1d18:	9c 89       	ldd	r25, Y+20	; 0x14
    1d1a:	29 a1       	ldd	r18, Y+33	; 0x21
    1d1c:	3a a1       	ldd	r19, Y+34	; 0x22
    1d1e:	22 95       	swap	r18
    1d20:	32 95       	swap	r19
    1d22:	30 7f       	andi	r19, 0xF0	; 240
    1d24:	32 27       	eor	r19, r18
    1d26:	20 7f       	andi	r18, 0xF0	; 240
    1d28:	32 27       	eor	r19, r18
    1d2a:	82 0f       	add	r24, r18
    1d2c:	93 1f       	adc	r25, r19
    1d2e:	8e 54       	subi	r24, 0x4E	; 78
    1d30:	9f 4f       	sbci	r25, 0xFF	; 255
    1d32:	2b e7       	ldi	r18, 0x7B	; 123
    1d34:	fc 01       	movw	r30, r24
    1d36:	20 83       	st	Z, r18
				tmpX++;
    1d38:	8b 89       	ldd	r24, Y+19	; 0x13
    1d3a:	9c 89       	ldd	r25, Y+20	; 0x14
    1d3c:	01 96       	adiw	r24, 0x01	; 1
    1d3e:	9c 8b       	std	Y+20, r25	; 0x14
    1d40:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1d42:	88 c2       	rjmp	.+1296   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '}':
				LCD_PrintSymbol(5);
    1d44:	85 e0       	ldi	r24, 0x05	; 5
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '}';
    1d4c:	8b 89       	ldd	r24, Y+19	; 0x13
    1d4e:	9c 89       	ldd	r25, Y+20	; 0x14
    1d50:	29 a1       	ldd	r18, Y+33	; 0x21
    1d52:	3a a1       	ldd	r19, Y+34	; 0x22
    1d54:	22 95       	swap	r18
    1d56:	32 95       	swap	r19
    1d58:	30 7f       	andi	r19, 0xF0	; 240
    1d5a:	32 27       	eor	r19, r18
    1d5c:	20 7f       	andi	r18, 0xF0	; 240
    1d5e:	32 27       	eor	r19, r18
    1d60:	82 0f       	add	r24, r18
    1d62:	93 1f       	adc	r25, r19
    1d64:	8e 54       	subi	r24, 0x4E	; 78
    1d66:	9f 4f       	sbci	r25, 0xFF	; 255
    1d68:	2d e7       	ldi	r18, 0x7D	; 125
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	20 83       	st	Z, r18
				tmpX++;
    1d6e:	8b 89       	ldd	r24, Y+19	; 0x13
    1d70:	9c 89       	ldd	r25, Y+20	; 0x14
    1d72:	01 96       	adiw	r24, 0x01	; 1
    1d74:	9c 8b       	std	Y+20, r25	; 0x14
    1d76:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1d78:	6d c2       	rjmp	.+1242   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case ',':
				LCD_PrintSymbol(6);
    1d7a:	86 e0       	ldi	r24, 0x06	; 6
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ',';
    1d82:	8b 89       	ldd	r24, Y+19	; 0x13
    1d84:	9c 89       	ldd	r25, Y+20	; 0x14
    1d86:	29 a1       	ldd	r18, Y+33	; 0x21
    1d88:	3a a1       	ldd	r19, Y+34	; 0x22
    1d8a:	22 95       	swap	r18
    1d8c:	32 95       	swap	r19
    1d8e:	30 7f       	andi	r19, 0xF0	; 240
    1d90:	32 27       	eor	r19, r18
    1d92:	20 7f       	andi	r18, 0xF0	; 240
    1d94:	32 27       	eor	r19, r18
    1d96:	82 0f       	add	r24, r18
    1d98:	93 1f       	adc	r25, r19
    1d9a:	8e 54       	subi	r24, 0x4E	; 78
    1d9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1d9e:	2c e2       	ldi	r18, 0x2C	; 44
    1da0:	fc 01       	movw	r30, r24
    1da2:	20 83       	st	Z, r18
				tmpX++;
    1da4:	8b 89       	ldd	r24, Y+19	; 0x13
    1da6:	9c 89       	ldd	r25, Y+20	; 0x14
    1da8:	01 96       	adiw	r24, 0x01	; 1
    1daa:	9c 8b       	std	Y+20, r25	; 0x14
    1dac:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1dae:	52 c2       	rjmp	.+1188   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case ':':
				LCD_PrintSymbol(7);
    1db0:	87 e0       	ldi	r24, 0x07	; 7
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ':';
    1db8:	8b 89       	ldd	r24, Y+19	; 0x13
    1dba:	9c 89       	ldd	r25, Y+20	; 0x14
    1dbc:	29 a1       	ldd	r18, Y+33	; 0x21
    1dbe:	3a a1       	ldd	r19, Y+34	; 0x22
    1dc0:	22 95       	swap	r18
    1dc2:	32 95       	swap	r19
    1dc4:	30 7f       	andi	r19, 0xF0	; 240
    1dc6:	32 27       	eor	r19, r18
    1dc8:	20 7f       	andi	r18, 0xF0	; 240
    1dca:	32 27       	eor	r19, r18
    1dcc:	82 0f       	add	r24, r18
    1dce:	93 1f       	adc	r25, r19
    1dd0:	8e 54       	subi	r24, 0x4E	; 78
    1dd2:	9f 4f       	sbci	r25, 0xFF	; 255
    1dd4:	2a e3       	ldi	r18, 0x3A	; 58
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	20 83       	st	Z, r18
				tmpX++;
    1dda:	8b 89       	ldd	r24, Y+19	; 0x13
    1ddc:	9c 89       	ldd	r25, Y+20	; 0x14
    1dde:	01 96       	adiw	r24, 0x01	; 1
    1de0:	9c 8b       	std	Y+20, r25	; 0x14
    1de2:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1de4:	37 c2       	rjmp	.+1134   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case ';':
				LCD_PrintSymbol(8);
    1de6:	88 e0       	ldi	r24, 0x08	; 8
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ';';
    1dee:	8b 89       	ldd	r24, Y+19	; 0x13
    1df0:	9c 89       	ldd	r25, Y+20	; 0x14
    1df2:	29 a1       	ldd	r18, Y+33	; 0x21
    1df4:	3a a1       	ldd	r19, Y+34	; 0x22
    1df6:	22 95       	swap	r18
    1df8:	32 95       	swap	r19
    1dfa:	30 7f       	andi	r19, 0xF0	; 240
    1dfc:	32 27       	eor	r19, r18
    1dfe:	20 7f       	andi	r18, 0xF0	; 240
    1e00:	32 27       	eor	r19, r18
    1e02:	82 0f       	add	r24, r18
    1e04:	93 1f       	adc	r25, r19
    1e06:	8e 54       	subi	r24, 0x4E	; 78
    1e08:	9f 4f       	sbci	r25, 0xFF	; 255
    1e0a:	2b e3       	ldi	r18, 0x3B	; 59
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	20 83       	st	Z, r18
				tmpX++;
    1e10:	8b 89       	ldd	r24, Y+19	; 0x13
    1e12:	9c 89       	ldd	r25, Y+20	; 0x14
    1e14:	01 96       	adiw	r24, 0x01	; 1
    1e16:	9c 8b       	std	Y+20, r25	; 0x14
    1e18:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1e1a:	1c c2       	rjmp	.+1080   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '?':
				LCD_PrintBlock();
    1e1c:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <LCD_PrintBlock>
				LCD_BUFFOR[y][tmpX] = '?';
    1e20:	8b 89       	ldd	r24, Y+19	; 0x13
    1e22:	9c 89       	ldd	r25, Y+20	; 0x14
    1e24:	29 a1       	ldd	r18, Y+33	; 0x21
    1e26:	3a a1       	ldd	r19, Y+34	; 0x22
    1e28:	22 95       	swap	r18
    1e2a:	32 95       	swap	r19
    1e2c:	30 7f       	andi	r19, 0xF0	; 240
    1e2e:	32 27       	eor	r19, r18
    1e30:	20 7f       	andi	r18, 0xF0	; 240
    1e32:	32 27       	eor	r19, r18
    1e34:	82 0f       	add	r24, r18
    1e36:	93 1f       	adc	r25, r19
    1e38:	8e 54       	subi	r24, 0x4E	; 78
    1e3a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e3c:	2f e3       	ldi	r18, 0x3F	; 63
    1e3e:	fc 01       	movw	r30, r24
    1e40:	20 83       	st	Z, r18
				tmpX++;
    1e42:	8b 89       	ldd	r24, Y+19	; 0x13
    1e44:	9c 89       	ldd	r25, Y+20	; 0x14
    1e46:	01 96       	adiw	r24, 0x01	; 1
    1e48:	9c 8b       	std	Y+20, r25	; 0x14
    1e4a:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1e4c:	03 c2       	rjmp	.+1030   	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '[':
				LCD_PrintLArrow();
    1e4e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <LCD_PrintLArrow>
				LCD_BUFFOR[y][tmpX] = '[';
    1e52:	8b 89       	ldd	r24, Y+19	; 0x13
    1e54:	9c 89       	ldd	r25, Y+20	; 0x14
    1e56:	29 a1       	ldd	r18, Y+33	; 0x21
    1e58:	3a a1       	ldd	r19, Y+34	; 0x22
    1e5a:	22 95       	swap	r18
    1e5c:	32 95       	swap	r19
    1e5e:	30 7f       	andi	r19, 0xF0	; 240
    1e60:	32 27       	eor	r19, r18
    1e62:	20 7f       	andi	r18, 0xF0	; 240
    1e64:	32 27       	eor	r19, r18
    1e66:	82 0f       	add	r24, r18
    1e68:	93 1f       	adc	r25, r19
    1e6a:	8e 54       	subi	r24, 0x4E	; 78
    1e6c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e6e:	2b e5       	ldi	r18, 0x5B	; 91
    1e70:	fc 01       	movw	r30, r24
    1e72:	20 83       	st	Z, r18
				tmpX++;
    1e74:	8b 89       	ldd	r24, Y+19	; 0x13
    1e76:	9c 89       	ldd	r25, Y+20	; 0x14
    1e78:	01 96       	adiw	r24, 0x01	; 1
    1e7a:	9c 8b       	std	Y+20, r25	; 0x14
    1e7c:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1e7e:	ea c1       	rjmp	.+980    	; 0x2254 <LCD_XYPrintf+0x6c4>
			case ']':
				LCD_PrintRArrow();
    1e80:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <LCD_PrintRArrow>
				LCD_BUFFOR[y][tmpX] = ']';
    1e84:	8b 89       	ldd	r24, Y+19	; 0x13
    1e86:	9c 89       	ldd	r25, Y+20	; 0x14
    1e88:	29 a1       	ldd	r18, Y+33	; 0x21
    1e8a:	3a a1       	ldd	r19, Y+34	; 0x22
    1e8c:	22 95       	swap	r18
    1e8e:	32 95       	swap	r19
    1e90:	30 7f       	andi	r19, 0xF0	; 240
    1e92:	32 27       	eor	r19, r18
    1e94:	20 7f       	andi	r18, 0xF0	; 240
    1e96:	32 27       	eor	r19, r18
    1e98:	82 0f       	add	r24, r18
    1e9a:	93 1f       	adc	r25, r19
    1e9c:	8e 54       	subi	r24, 0x4E	; 78
    1e9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1ea0:	2d e5       	ldi	r18, 0x5D	; 93
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	20 83       	st	Z, r18
				tmpX++;
    1ea6:	8b 89       	ldd	r24, Y+19	; 0x13
    1ea8:	9c 89       	ldd	r25, Y+20	; 0x14
    1eaa:	01 96       	adiw	r24, 0x01	; 1
    1eac:	9c 8b       	std	Y+20, r25	; 0x14
    1eae:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1eb0:	d1 c1       	rjmp	.+930    	; 0x2254 <LCD_XYPrintf+0x6c4>
			case '.':
				LCD_PrintDot();
    1eb2:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <LCD_PrintDot>
				LCD_BUFFOR[y][tmpX] = '.';
    1eb6:	8b 89       	ldd	r24, Y+19	; 0x13
    1eb8:	9c 89       	ldd	r25, Y+20	; 0x14
    1eba:	29 a1       	ldd	r18, Y+33	; 0x21
    1ebc:	3a a1       	ldd	r19, Y+34	; 0x22
    1ebe:	22 95       	swap	r18
    1ec0:	32 95       	swap	r19
    1ec2:	30 7f       	andi	r19, 0xF0	; 240
    1ec4:	32 27       	eor	r19, r18
    1ec6:	20 7f       	andi	r18, 0xF0	; 240
    1ec8:	32 27       	eor	r19, r18
    1eca:	82 0f       	add	r24, r18
    1ecc:	93 1f       	adc	r25, r19
    1ece:	8e 54       	subi	r24, 0x4E	; 78
    1ed0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ed2:	2e e2       	ldi	r18, 0x2E	; 46
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	20 83       	st	Z, r18
				tmpX++;
    1ed8:	8b 89       	ldd	r24, Y+19	; 0x13
    1eda:	9c 89       	ldd	r25, Y+20	; 0x14
    1edc:	01 96       	adiw	r24, 0x01	; 1
    1ede:	9c 8b       	std	Y+20, r25	; 0x14
    1ee0:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1ee2:	b8 c1       	rjmp	.+880    	; 0x2254 <LCD_XYPrintf+0x6c4>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    1ee4:	8d 89       	ldd	r24, Y+21	; 0x15
    1ee6:	9e 89       	ldd	r25, Y+22	; 0x16
    1ee8:	9c 01       	movw	r18, r24
    1eea:	2e 5f       	subi	r18, 0xFE	; 254
    1eec:	3f 4f       	sbci	r19, 0xFF	; 255
    1eee:	3e 8b       	std	Y+22, r19	; 0x16
    1ef0:	2d 8b       	std	Y+21, r18	; 0x15
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	80 81       	ld	r24, Z
    1ef6:	91 81       	ldd	r25, Z+1	; 0x01
    1ef8:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    1efa:	89 85       	ldd	r24, Y+9	; 0x09
    1efc:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = ch;
    1f00:	8b 89       	ldd	r24, Y+19	; 0x13
    1f02:	9c 89       	ldd	r25, Y+20	; 0x14
    1f04:	29 a1       	ldd	r18, Y+33	; 0x21
    1f06:	3a a1       	ldd	r19, Y+34	; 0x22
    1f08:	22 95       	swap	r18
    1f0a:	32 95       	swap	r19
    1f0c:	30 7f       	andi	r19, 0xF0	; 240
    1f0e:	32 27       	eor	r19, r18
    1f10:	20 7f       	andi	r18, 0xF0	; 240
    1f12:	32 27       	eor	r19, r18
    1f14:	82 0f       	add	r24, r18
    1f16:	93 1f       	adc	r25, r19
    1f18:	8e 54       	subi	r24, 0x4E	; 78
    1f1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1f1c:	29 85       	ldd	r18, Y+9	; 0x09
    1f1e:	fc 01       	movw	r30, r24
    1f20:	20 83       	st	Z, r18
				tmpX++;
    1f22:	8b 89       	ldd	r24, Y+19	; 0x13
    1f24:	9c 89       	ldd	r25, Y+20	; 0x14
    1f26:	01 96       	adiw	r24, 0x01	; 1
    1f28:	9c 8b       	std	Y+20, r25	; 0x14
    1f2a:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    1f2c:	93 c1       	rjmp	.+806    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    1f2e:	8d 89       	ldd	r24, Y+21	; 0x15
    1f30:	9e 89       	ldd	r25, Y+22	; 0x16
    1f32:	9c 01       	movw	r18, r24
    1f34:	2e 5f       	subi	r18, 0xFE	; 254
    1f36:	3f 4f       	sbci	r19, 0xFF	; 255
    1f38:	3e 8b       	std	Y+22, r19	; 0x16
    1f3a:	2d 8b       	std	Y+21, r18	; 0x15
    1f3c:	fc 01       	movw	r30, r24
    1f3e:	80 81       	ld	r24, Z
    1f40:	91 81       	ldd	r25, Z+1	; 0x01
    1f42:	9c 83       	std	Y+4, r25	; 0x04
    1f44:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    1f46:	8b 81       	ldd	r24, Y+3	; 0x03
    1f48:	9c 81       	ldd	r25, Y+4	; 0x04
    1f4a:	99 23       	and	r25, r25
    1f4c:	04 f5       	brge	.+64     	; 0x1f8e <LCD_XYPrintf+0x3fe>
					v_num_s16 = -v_num_s16;
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	91 95       	neg	r25
    1f54:	81 95       	neg	r24
    1f56:	91 09       	sbc	r25, r1
    1f58:	9c 83       	std	Y+4, r25	; 0x04
    1f5a:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    1f5c:	8d e2       	ldi	r24, 0x2D	; 45
    1f5e:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    1f62:	8b 89       	ldd	r24, Y+19	; 0x13
    1f64:	9c 89       	ldd	r25, Y+20	; 0x14
    1f66:	29 a1       	ldd	r18, Y+33	; 0x21
    1f68:	3a a1       	ldd	r19, Y+34	; 0x22
    1f6a:	22 95       	swap	r18
    1f6c:	32 95       	swap	r19
    1f6e:	30 7f       	andi	r19, 0xF0	; 240
    1f70:	32 27       	eor	r19, r18
    1f72:	20 7f       	andi	r18, 0xF0	; 240
    1f74:	32 27       	eor	r19, r18
    1f76:	82 0f       	add	r24, r18
    1f78:	93 1f       	adc	r25, r19
    1f7a:	8e 54       	subi	r24, 0x4E	; 78
    1f7c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f7e:	2d e2       	ldi	r18, 0x2D	; 45
    1f80:	fc 01       	movw	r30, r24
    1f82:	20 83       	st	Z, r18
					tmpX++;
    1f84:	8b 89       	ldd	r24, Y+19	; 0x13
    1f86:	9c 89       	ldd	r25, Y+20	; 0x14
    1f88:	01 96       	adiw	r24, 0x01	; 1
    1f8a:	9c 8b       	std	Y+20, r25	; 0x14
    1f8c:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s16,
    1f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f90:	9c 81       	ldd	r25, Y+4	; 0x04
    1f92:	aa 27       	eor	r26, r26
    1f94:	97 fd       	sbrc	r25, 7
    1f96:	a0 95       	com	r26
    1f98:	ba 2f       	mov	r27, r26
    1f9a:	49 a1       	ldd	r20, Y+33	; 0x21
    1f9c:	5a a1       	ldd	r21, Y+34	; 0x22
    1f9e:	9e 01       	movw	r18, r28
    1fa0:	2d 5e       	subi	r18, 0xED	; 237
    1fa2:	3f 4f       	sbci	r19, 0xFF	; 255
    1fa4:	7a 01       	movw	r14, r20
    1fa6:	89 01       	movw	r16, r18
    1fa8:	2a 85       	ldd	r18, Y+10	; 0x0a
    1faa:	ac 01       	movw	r20, r24
    1fac:	bd 01       	movw	r22, r26
    1fae:	8a e0       	ldi	r24, 0x0A	; 10
    1fb0:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    1fb4:	4f c1       	rjmp	.+670    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    1fb6:	8d 89       	ldd	r24, Y+21	; 0x15
    1fb8:	9e 89       	ldd	r25, Y+22	; 0x16
    1fba:	9c 01       	movw	r18, r24
    1fbc:	2c 5f       	subi	r18, 0xFC	; 252
    1fbe:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc0:	3e 8b       	std	Y+22, r19	; 0x16
    1fc2:	2d 8b       	std	Y+21, r18	; 0x15
    1fc4:	fc 01       	movw	r30, r24
    1fc6:	80 81       	ld	r24, Z
    1fc8:	91 81       	ldd	r25, Z+1	; 0x01
    1fca:	a2 81       	ldd	r26, Z+2	; 0x02
    1fcc:	b3 81       	ldd	r27, Z+3	; 0x03
    1fce:	8d 83       	std	Y+5, r24	; 0x05
    1fd0:	9e 83       	std	Y+6, r25	; 0x06
    1fd2:	af 83       	std	Y+7, r26	; 0x07
    1fd4:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    1fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fd8:	9e 81       	ldd	r25, Y+6	; 0x06
    1fda:	af 81       	ldd	r26, Y+7	; 0x07
    1fdc:	b8 85       	ldd	r27, Y+8	; 0x08
    1fde:	bb 23       	and	r27, r27
    1fe0:	44 f5       	brge	.+80     	; 0x2032 <LCD_XYPrintf+0x4a2>
					v_num_s32 = -v_num_s32;
    1fe2:	8d 81       	ldd	r24, Y+5	; 0x05
    1fe4:	9e 81       	ldd	r25, Y+6	; 0x06
    1fe6:	af 81       	ldd	r26, Y+7	; 0x07
    1fe8:	b8 85       	ldd	r27, Y+8	; 0x08
    1fea:	b0 95       	com	r27
    1fec:	a0 95       	com	r26
    1fee:	90 95       	com	r25
    1ff0:	81 95       	neg	r24
    1ff2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ff4:	af 4f       	sbci	r26, 0xFF	; 255
    1ff6:	bf 4f       	sbci	r27, 0xFF	; 255
    1ff8:	8d 83       	std	Y+5, r24	; 0x05
    1ffa:	9e 83       	std	Y+6, r25	; 0x06
    1ffc:	af 83       	std	Y+7, r26	; 0x07
    1ffe:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    2000:	8d e2       	ldi	r24, 0x2D	; 45
    2002:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    2006:	8b 89       	ldd	r24, Y+19	; 0x13
    2008:	9c 89       	ldd	r25, Y+20	; 0x14
    200a:	29 a1       	ldd	r18, Y+33	; 0x21
    200c:	3a a1       	ldd	r19, Y+34	; 0x22
    200e:	22 95       	swap	r18
    2010:	32 95       	swap	r19
    2012:	30 7f       	andi	r19, 0xF0	; 240
    2014:	32 27       	eor	r19, r18
    2016:	20 7f       	andi	r18, 0xF0	; 240
    2018:	32 27       	eor	r19, r18
    201a:	82 0f       	add	r24, r18
    201c:	93 1f       	adc	r25, r19
    201e:	8e 54       	subi	r24, 0x4E	; 78
    2020:	9f 4f       	sbci	r25, 0xFF	; 255
    2022:	2d e2       	ldi	r18, 0x2D	; 45
    2024:	fc 01       	movw	r30, r24
    2026:	20 83       	st	Z, r18
					tmpX++;
    2028:	8b 89       	ldd	r24, Y+19	; 0x13
    202a:	9c 89       	ldd	r25, Y+20	; 0x14
    202c:	01 96       	adiw	r24, 0x01	; 1
    202e:	9c 8b       	std	Y+20, r25	; 0x14
    2030:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s32,
    2032:	8d 81       	ldd	r24, Y+5	; 0x05
    2034:	9e 81       	ldd	r25, Y+6	; 0x06
    2036:	af 81       	ldd	r26, Y+7	; 0x07
    2038:	b8 85       	ldd	r27, Y+8	; 0x08
    203a:	49 a1       	ldd	r20, Y+33	; 0x21
    203c:	5a a1       	ldd	r21, Y+34	; 0x22
    203e:	9e 01       	movw	r18, r28
    2040:	2d 5e       	subi	r18, 0xED	; 237
    2042:	3f 4f       	sbci	r19, 0xFF	; 255
    2044:	7a 01       	movw	r14, r20
    2046:	89 01       	movw	r16, r18
    2048:	2a 85       	ldd	r18, Y+10	; 0x0a
    204a:	ac 01       	movw	r20, r24
    204c:	bd 01       	movw	r22, r26
    204e:	8a e0       	ldi	r24, 0x0A	; 10
    2050:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2054:	ff c0       	rjmp	.+510    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    2056:	8d 89       	ldd	r24, Y+21	; 0x15
    2058:	9e 89       	ldd	r25, Y+22	; 0x16
    205a:	9c 01       	movw	r18, r24
    205c:	2e 5f       	subi	r18, 0xFE	; 254
    205e:	3f 4f       	sbci	r19, 0xFF	; 255
    2060:	3e 8b       	std	Y+22, r19	; 0x16
    2062:	2d 8b       	std	Y+21, r18	; 0x15
    2064:	fc 01       	movw	r30, r24
    2066:	80 81       	ld	r24, Z
    2068:	91 81       	ldd	r25, Z+1	; 0x01
    206a:	9c 87       	std	Y+12, r25	; 0x0c
    206c:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u16,
    206e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2070:	9c 85       	ldd	r25, Y+12	; 0x0c
    2072:	cc 01       	movw	r24, r24
    2074:	a0 e0       	ldi	r26, 0x00	; 0
    2076:	b0 e0       	ldi	r27, 0x00	; 0
    2078:	49 a1       	ldd	r20, Y+33	; 0x21
    207a:	5a a1       	ldd	r21, Y+34	; 0x22
    207c:	9e 01       	movw	r18, r28
    207e:	2d 5e       	subi	r18, 0xED	; 237
    2080:	3f 4f       	sbci	r19, 0xFF	; 255
    2082:	7a 01       	movw	r14, r20
    2084:	89 01       	movw	r16, r18
    2086:	2a 85       	ldd	r18, Y+10	; 0x0a
    2088:	ac 01       	movw	r20, r24
    208a:	bd 01       	movw	r22, r26
    208c:	8a e0       	ldi	r24, 0x0A	; 10
    208e:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2092:	e0 c0       	rjmp	.+448    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    2094:	8d 89       	ldd	r24, Y+21	; 0x15
    2096:	9e 89       	ldd	r25, Y+22	; 0x16
    2098:	9c 01       	movw	r18, r24
    209a:	2c 5f       	subi	r18, 0xFC	; 252
    209c:	3f 4f       	sbci	r19, 0xFF	; 255
    209e:	3e 8b       	std	Y+22, r19	; 0x16
    20a0:	2d 8b       	std	Y+21, r18	; 0x15
    20a2:	fc 01       	movw	r30, r24
    20a4:	80 81       	ld	r24, Z
    20a6:	91 81       	ldd	r25, Z+1	; 0x01
    20a8:	a2 81       	ldd	r26, Z+2	; 0x02
    20aa:	b3 81       	ldd	r27, Z+3	; 0x03
    20ac:	8d 87       	std	Y+13, r24	; 0x0d
    20ae:	9e 87       	std	Y+14, r25	; 0x0e
    20b0:	af 87       	std	Y+15, r26	; 0x0f
    20b2:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u32,
    20b4:	49 a1       	ldd	r20, Y+33	; 0x21
    20b6:	5a a1       	ldd	r21, Y+34	; 0x22
    20b8:	9e 01       	movw	r18, r28
    20ba:	2d 5e       	subi	r18, 0xED	; 237
    20bc:	3f 4f       	sbci	r19, 0xFF	; 255
    20be:	8d 85       	ldd	r24, Y+13	; 0x0d
    20c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    20c2:	af 85       	ldd	r26, Y+15	; 0x0f
    20c4:	b8 89       	ldd	r27, Y+16	; 0x10
    20c6:	7a 01       	movw	r14, r20
    20c8:	89 01       	movw	r16, r18
    20ca:	2a 85       	ldd	r18, Y+10	; 0x0a
    20cc:	ac 01       	movw	r20, r24
    20ce:	bd 01       	movw	r22, r26
    20d0:	8a e0       	ldi	r24, 0x0A	; 10
    20d2:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    20d6:	be c0       	rjmp	.+380    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    20d8:	8d 89       	ldd	r24, Y+21	; 0x15
    20da:	9e 89       	ldd	r25, Y+22	; 0x16
    20dc:	9c 01       	movw	r18, r24
    20de:	2e 5f       	subi	r18, 0xFE	; 254
    20e0:	3f 4f       	sbci	r19, 0xFF	; 255
    20e2:	3e 8b       	std	Y+22, r19	; 0x16
    20e4:	2d 8b       	std	Y+21, r18	; 0x15
    20e6:	fc 01       	movw	r30, r24
    20e8:	80 81       	ld	r24, Z
    20ea:	91 81       	ldd	r25, Z+1	; 0x01
    20ec:	9c 87       	std	Y+12, r25	; 0x0c
    20ee:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u16,
    20f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    20f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    20f4:	cc 01       	movw	r24, r24
    20f6:	a0 e0       	ldi	r26, 0x00	; 0
    20f8:	b0 e0       	ldi	r27, 0x00	; 0
    20fa:	49 a1       	ldd	r20, Y+33	; 0x21
    20fc:	5a a1       	ldd	r21, Y+34	; 0x22
    20fe:	9e 01       	movw	r18, r28
    2100:	2d 5e       	subi	r18, 0xED	; 237
    2102:	3f 4f       	sbci	r19, 0xFF	; 255
    2104:	7a 01       	movw	r14, r20
    2106:	89 01       	movw	r16, r18
    2108:	2a 85       	ldd	r18, Y+10	; 0x0a
    210a:	ac 01       	movw	r20, r24
    210c:	bd 01       	movw	r22, r26
    210e:	80 e1       	ldi	r24, 0x10	; 16
    2110:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2114:	9f c0       	rjmp	.+318    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    2116:	8d 89       	ldd	r24, Y+21	; 0x15
    2118:	9e 89       	ldd	r25, Y+22	; 0x16
    211a:	9c 01       	movw	r18, r24
    211c:	2c 5f       	subi	r18, 0xFC	; 252
    211e:	3f 4f       	sbci	r19, 0xFF	; 255
    2120:	3e 8b       	std	Y+22, r19	; 0x16
    2122:	2d 8b       	std	Y+21, r18	; 0x15
    2124:	fc 01       	movw	r30, r24
    2126:	80 81       	ld	r24, Z
    2128:	91 81       	ldd	r25, Z+1	; 0x01
    212a:	a2 81       	ldd	r26, Z+2	; 0x02
    212c:	b3 81       	ldd	r27, Z+3	; 0x03
    212e:	8d 87       	std	Y+13, r24	; 0x0d
    2130:	9e 87       	std	Y+14, r25	; 0x0e
    2132:	af 87       	std	Y+15, r26	; 0x0f
    2134:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u32,
    2136:	49 a1       	ldd	r20, Y+33	; 0x21
    2138:	5a a1       	ldd	r21, Y+34	; 0x22
    213a:	9e 01       	movw	r18, r28
    213c:	2d 5e       	subi	r18, 0xED	; 237
    213e:	3f 4f       	sbci	r19, 0xFF	; 255
    2140:	8d 85       	ldd	r24, Y+13	; 0x0d
    2142:	9e 85       	ldd	r25, Y+14	; 0x0e
    2144:	af 85       	ldd	r26, Y+15	; 0x0f
    2146:	b8 89       	ldd	r27, Y+16	; 0x10
    2148:	7a 01       	movw	r14, r20
    214a:	89 01       	movw	r16, r18
    214c:	2a 85       	ldd	r18, Y+10	; 0x0a
    214e:	ac 01       	movw	r20, r24
    2150:	bd 01       	movw	r22, r26
    2152:	80 e1       	ldi	r24, 0x10	; 16
    2154:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2158:	7d c0       	rjmp	.+250    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    215a:	8d 89       	ldd	r24, Y+21	; 0x15
    215c:	9e 89       	ldd	r25, Y+22	; 0x16
    215e:	9c 01       	movw	r18, r24
    2160:	2e 5f       	subi	r18, 0xFE	; 254
    2162:	3f 4f       	sbci	r19, 0xFF	; 255
    2164:	3e 8b       	std	Y+22, r19	; 0x16
    2166:	2d 8b       	std	Y+21, r18	; 0x15
    2168:	fc 01       	movw	r30, r24
    216a:	80 81       	ld	r24, Z
    216c:	91 81       	ldd	r25, Z+1	; 0x01
    216e:	9c 87       	std	Y+12, r25	; 0x0c
    2170:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2172:	8a 85       	ldd	r24, Y+10	; 0x0a
    2174:	8f 3f       	cpi	r24, 0xFF	; 255
    2176:	11 f4       	brne	.+4      	; 0x217c <LCD_XYPrintf+0x5ec>
					v_numOfDigitsToDisp_u8 = 16;
    2178:	80 e1       	ldi	r24, 0x10	; 16
    217a:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u16,
    217c:	8b 85       	ldd	r24, Y+11	; 0x0b
    217e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2180:	cc 01       	movw	r24, r24
    2182:	a0 e0       	ldi	r26, 0x00	; 0
    2184:	b0 e0       	ldi	r27, 0x00	; 0
    2186:	49 a1       	ldd	r20, Y+33	; 0x21
    2188:	5a a1       	ldd	r21, Y+34	; 0x22
    218a:	9e 01       	movw	r18, r28
    218c:	2d 5e       	subi	r18, 0xED	; 237
    218e:	3f 4f       	sbci	r19, 0xFF	; 255
    2190:	7a 01       	movw	r14, r20
    2192:	89 01       	movw	r16, r18
    2194:	2a 85       	ldd	r18, Y+10	; 0x0a
    2196:	ac 01       	movw	r20, r24
    2198:	bd 01       	movw	r22, r26
    219a:	82 e0       	ldi	r24, 0x02	; 2
    219c:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    21a0:	59 c0       	rjmp	.+178    	; 0x2254 <LCD_XYPrintf+0x6c4>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    21a2:	8d 89       	ldd	r24, Y+21	; 0x15
    21a4:	9e 89       	ldd	r25, Y+22	; 0x16
    21a6:	9c 01       	movw	r18, r24
    21a8:	2c 5f       	subi	r18, 0xFC	; 252
    21aa:	3f 4f       	sbci	r19, 0xFF	; 255
    21ac:	3e 8b       	std	Y+22, r19	; 0x16
    21ae:	2d 8b       	std	Y+21, r18	; 0x15
    21b0:	fc 01       	movw	r30, r24
    21b2:	80 81       	ld	r24, Z
    21b4:	91 81       	ldd	r25, Z+1	; 0x01
    21b6:	a2 81       	ldd	r26, Z+2	; 0x02
    21b8:	b3 81       	ldd	r27, Z+3	; 0x03
    21ba:	8d 87       	std	Y+13, r24	; 0x0d
    21bc:	9e 87       	std	Y+14, r25	; 0x0e
    21be:	af 87       	std	Y+15, r26	; 0x0f
    21c0:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    21c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    21c4:	8f 3f       	cpi	r24, 0xFF	; 255
    21c6:	11 f4       	brne	.+4      	; 0x21cc <LCD_XYPrintf+0x63c>
					v_numOfDigitsToDisp_u8 = 16;
    21c8:	80 e1       	ldi	r24, 0x10	; 16
    21ca:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u32,
    21cc:	49 a1       	ldd	r20, Y+33	; 0x21
    21ce:	5a a1       	ldd	r21, Y+34	; 0x22
    21d0:	9e 01       	movw	r18, r28
    21d2:	2d 5e       	subi	r18, 0xED	; 237
    21d4:	3f 4f       	sbci	r19, 0xFF	; 255
    21d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    21d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    21da:	af 85       	ldd	r26, Y+15	; 0x0f
    21dc:	b8 89       	ldd	r27, Y+16	; 0x10
    21de:	7a 01       	movw	r14, r20
    21e0:	89 01       	movw	r16, r18
    21e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    21e4:	ac 01       	movw	r20, r24
    21e6:	bd 01       	movw	r22, r26
    21e8:	82 e0       	ldi	r24, 0x02	; 2
    21ea:	0e 94 4f 0c 	call	0x189e	; 0x189e <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    21ee:	32 c0       	rjmp	.+100    	; 0x2254 <LCD_XYPrintf+0x6c4>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    21f0:	8d 89       	ldd	r24, Y+21	; 0x15
    21f2:	9e 89       	ldd	r25, Y+22	; 0x16
    21f4:	9c 01       	movw	r18, r24
    21f6:	2e 5f       	subi	r18, 0xFE	; 254
    21f8:	3f 4f       	sbci	r19, 0xFF	; 255
    21fa:	3e 8b       	std	Y+22, r19	; 0x16
    21fc:	2d 8b       	std	Y+21, r18	; 0x15
    21fe:	fc 01       	movw	r30, r24
    2200:	80 81       	ld	r24, Z
    2202:	91 81       	ldd	r25, Z+1	; 0x01
    2204:	9a 8b       	std	Y+18, r25	; 0x12
    2206:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayStringWithAddingToBuffor(str, &tmpX, y);
    2208:	49 a1       	ldd	r20, Y+33	; 0x21
    220a:	5a a1       	ldd	r21, Y+34	; 0x22
    220c:	9e 01       	movw	r18, r28
    220e:	2d 5e       	subi	r18, 0xED	; 237
    2210:	3f 4f       	sbci	r19, 0xFF	; 255
    2212:	89 89       	ldd	r24, Y+17	; 0x11
    2214:	9a 89       	ldd	r25, Y+18	; 0x12
    2216:	b9 01       	movw	r22, r18
    2218:	0e 94 ab 08 	call	0x1156	; 0x1156 <LCD_DisplayStringWithAddingToBuffor>
				break;
    221c:	1b c0       	rjmp	.+54     	; 0x2254 <LCD_XYPrintf+0x6c4>

			case '%':
				LCD_DisplayChar('%');
    221e:	85 e2       	ldi	r24, 0x25	; 37
    2220:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = '%';
    2224:	8b 89       	ldd	r24, Y+19	; 0x13
    2226:	9c 89       	ldd	r25, Y+20	; 0x14
    2228:	29 a1       	ldd	r18, Y+33	; 0x21
    222a:	3a a1       	ldd	r19, Y+34	; 0x22
    222c:	22 95       	swap	r18
    222e:	32 95       	swap	r19
    2230:	30 7f       	andi	r19, 0xF0	; 240
    2232:	32 27       	eor	r19, r18
    2234:	20 7f       	andi	r18, 0xF0	; 240
    2236:	32 27       	eor	r19, r18
    2238:	82 0f       	add	r24, r18
    223a:	93 1f       	adc	r25, r19
    223c:	8e 54       	subi	r24, 0x4E	; 78
    223e:	9f 4f       	sbci	r25, 0xFF	; 255
    2240:	25 e2       	ldi	r18, 0x25	; 37
    2242:	fc 01       	movw	r30, r24
    2244:	20 83       	st	Z, r18
				tmpX++;
    2246:	8b 89       	ldd	r24, Y+19	; 0x13
    2248:	9c 89       	ldd	r25, Y+20	; 0x14
    224a:	01 96       	adiw	r24, 0x01	; 1
    224c:	9c 8b       	std	Y+20, r25	; 0x14
    224e:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2250:	01 c0       	rjmp	.+2      	; 0x2254 <LCD_XYPrintf+0x6c4>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    2252:	00 00       	nop
    2254:	19 c0       	rjmp	.+50     	; 0x2288 <LCD_XYPrintf+0x6f8>
				tmpX++;
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    2256:	89 85       	ldd	r24, Y+9	; 0x09
    2258:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
			LCD_BUFFOR[y][tmpX] = ch;
    225c:	8b 89       	ldd	r24, Y+19	; 0x13
    225e:	9c 89       	ldd	r25, Y+20	; 0x14
    2260:	29 a1       	ldd	r18, Y+33	; 0x21
    2262:	3a a1       	ldd	r19, Y+34	; 0x22
    2264:	22 95       	swap	r18
    2266:	32 95       	swap	r19
    2268:	30 7f       	andi	r19, 0xF0	; 240
    226a:	32 27       	eor	r19, r18
    226c:	20 7f       	andi	r18, 0xF0	; 240
    226e:	32 27       	eor	r19, r18
    2270:	82 0f       	add	r24, r18
    2272:	93 1f       	adc	r25, r19
    2274:	8e 54       	subi	r24, 0x4E	; 78
    2276:	9f 4f       	sbci	r25, 0xFF	; 255
    2278:	29 85       	ldd	r18, Y+9	; 0x09
    227a:	fc 01       	movw	r30, r24
    227c:	20 83       	st	Z, r18
			tmpX++;
    227e:	8b 89       	ldd	r24, Y+19	; 0x13
    2280:	9c 89       	ldd	r25, Y+20	; 0x14
    2282:	01 96       	adiw	r24, 0x01	; 1
    2284:	9c 8b       	std	Y+20, r25	; 0x14
    2286:	8b 8b       	std	Y+19, r24	; 0x13
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	01 96       	adiw	r24, 0x01	; 1
    228e:	9a 83       	std	Y+2, r25	; 0x02
    2290:	89 83       	std	Y+1, r24	; 0x01
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	fc 01       	movw	r30, r24
    2298:	80 81       	ld	r24, Z
    229a:	88 23       	and	r24, r24
    229c:	09 f0       	breq	.+2      	; 0x22a0 <LCD_XYPrintf+0x710>
    229e:	98 cc       	rjmp	.-1744   	; 0x1bd0 <LCD_XYPrintf+0x40>
			tmpX++;
		}
	}

	va_end(argp);
}
    22a0:	66 96       	adiw	r28, 0x16	; 22
    22a2:	0f b6       	in	r0, 0x3f	; 63
    22a4:	f8 94       	cli
    22a6:	de bf       	out	0x3e, r29	; 62
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	cd bf       	out	0x3d, r28	; 61
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	ff 90       	pop	r15
    22b6:	ef 90       	pop	r14
    22b8:	08 95       	ret

000022ba <LCD_Printf>:
#endif

#if ( Enable_LCD_Printf   == 1 )
void LCD_Printf(const char *argList, ...) {
    22ba:	cf 93       	push	r28
    22bc:	df 93       	push	r29
    22be:	cd b7       	in	r28, 0x3d	; 61
    22c0:	de b7       	in	r29, 0x3e	; 62
    22c2:	64 97       	sbiw	r28, 0x14	; 20
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	f8 94       	cli
    22c8:	de bf       	out	0x3e, r29	; 62
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	cd bf       	out	0x3d, r28	; 61
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    22ce:	ce 01       	movw	r24, r28
    22d0:	4b 96       	adiw	r24, 0x1b	; 27
    22d2:	9c 8b       	std	Y+20, r25	; 0x14
    22d4:	8b 8b       	std	Y+19, r24	; 0x13

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    22d6:	89 8d       	ldd	r24, Y+25	; 0x19
    22d8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    22da:	9a 83       	std	Y+2, r25	; 0x02
    22dc:	89 83       	std	Y+1, r24	; 0x01
    22de:	ad c1       	rjmp	.+858    	; 0x263a <LCD_Printf+0x380>

		ch = *ptr;
    22e0:	89 81       	ldd	r24, Y+1	; 0x01
    22e2:	9a 81       	ldd	r25, Y+2	; 0x02
    22e4:	fc 01       	movw	r30, r24
    22e6:	80 81       	ld	r24, Z
    22e8:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    22ea:	89 85       	ldd	r24, Y+9	; 0x09
    22ec:	85 32       	cpi	r24, 0x25	; 37
    22ee:	09 f0       	breq	.+2      	; 0x22f2 <LCD_Printf+0x38>
    22f0:	9c c1       	rjmp	.+824    	; 0x262a <LCD_Printf+0x370>
		{
			ptr++;
    22f2:	89 81       	ldd	r24, Y+1	; 0x01
    22f4:	9a 81       	ldd	r25, Y+2	; 0x02
    22f6:	01 96       	adiw	r24, 0x01	; 1
    22f8:	9a 83       	std	Y+2, r25	; 0x02
    22fa:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2300:	fc 01       	movw	r30, r24
    2302:	80 81       	ld	r24, Z
    2304:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    2306:	89 85       	ldd	r24, Y+9	; 0x09
    2308:	80 33       	cpi	r24, 0x30	; 48
    230a:	00 f1       	brcs	.+64     	; 0x234c <LCD_Printf+0x92>
    230c:	89 85       	ldd	r24, Y+9	; 0x09
    230e:	8a 33       	cpi	r24, 0x3A	; 58
    2310:	e8 f4       	brcc	.+58     	; 0x234c <LCD_Printf+0x92>
				v_numOfDigitsToDisp_u8 = 0;
    2312:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    2314:	14 c0       	rjmp	.+40     	; 0x233e <LCD_Printf+0x84>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    2316:	8a 85       	ldd	r24, Y+10	; 0x0a
    2318:	88 0f       	add	r24, r24
    231a:	98 2f       	mov	r25, r24
    231c:	99 0f       	add	r25, r25
    231e:	99 0f       	add	r25, r25
    2320:	98 0f       	add	r25, r24
    2322:	89 85       	ldd	r24, Y+9	; 0x09
    2324:	89 0f       	add	r24, r25
    2326:	80 53       	subi	r24, 0x30	; 48
    2328:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    232a:	89 81       	ldd	r24, Y+1	; 0x01
    232c:	9a 81       	ldd	r25, Y+2	; 0x02
    232e:	01 96       	adiw	r24, 0x01	; 1
    2330:	9a 83       	std	Y+2, r25	; 0x02
    2332:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    2334:	89 81       	ldd	r24, Y+1	; 0x01
    2336:	9a 81       	ldd	r25, Y+2	; 0x02
    2338:	fc 01       	movw	r30, r24
    233a:	80 81       	ld	r24, Z
    233c:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    233e:	89 85       	ldd	r24, Y+9	; 0x09
    2340:	80 33       	cpi	r24, 0x30	; 48
    2342:	18 f0       	brcs	.+6      	; 0x234a <LCD_Printf+0x90>
    2344:	89 85       	ldd	r24, Y+9	; 0x09
    2346:	8a 33       	cpi	r24, 0x3A	; 58
    2348:	30 f3       	brcs	.-52     	; 0x2316 <LCD_Printf+0x5c>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    234a:	02 c0       	rjmp	.+4      	; 0x2350 <LCD_Printf+0x96>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    234c:	8f ef       	ldi	r24, 0xFF	; 255
    234e:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    2350:	89 85       	ldd	r24, Y+9	; 0x09
    2352:	88 2f       	mov	r24, r24
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	aa 27       	eor	r26, r26
    2358:	97 fd       	sbrc	r25, 7
    235a:	a0 95       	com	r26
    235c:	ba 2f       	mov	r27, r26
    235e:	45 e2       	ldi	r20, 0x25	; 37
    2360:	50 e0       	ldi	r21, 0x00	; 0
    2362:	28 e5       	ldi	r18, 0x58	; 88
    2364:	30 e0       	ldi	r19, 0x00	; 0
    2366:	84 1b       	sub	r24, r20
    2368:	95 0b       	sbc	r25, r21
    236a:	28 17       	cp	r18, r24
    236c:	39 07       	cpc	r19, r25
    236e:	08 f4       	brcc	.+2      	; 0x2372 <LCD_Printf+0xb8>
    2370:	5f c1       	rjmp	.+702    	; 0x2630 <LCD_Printf+0x376>
    2372:	84 52       	subi	r24, 0x24	; 36
    2374:	9f 4f       	sbci	r25, 0xFF	; 255
    2376:	fc 01       	movw	r30, r24
    2378:	0c 94 47 1a 	jmp	0x348e	; 0x348e <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    237c:	81 e0       	ldi	r24, 0x01	; 1
    237e:	90 e0       	ldi	r25, 0x00	; 0
    2380:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    2384:	51 c1       	rjmp	.+674    	; 0x2628 <LCD_Printf+0x36e>
			case '<':
				LCD_PrintSymbol(2);
    2386:	82 e0       	ldi	r24, 0x02	; 2
    2388:	90 e0       	ldi	r25, 0x00	; 0
    238a:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    238e:	4c c1       	rjmp	.+664    	; 0x2628 <LCD_Printf+0x36e>
			case '|':
				LCD_PrintSymbol(3);
    2390:	83 e0       	ldi	r24, 0x03	; 3
    2392:	90 e0       	ldi	r25, 0x00	; 0
    2394:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    2398:	47 c1       	rjmp	.+654    	; 0x2628 <LCD_Printf+0x36e>
			case '{':
				LCD_PrintSymbol(4);
    239a:	84 e0       	ldi	r24, 0x04	; 4
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    23a2:	42 c1       	rjmp	.+644    	; 0x2628 <LCD_Printf+0x36e>
			case '}':
				LCD_PrintSymbol(5);
    23a4:	85 e0       	ldi	r24, 0x05	; 5
    23a6:	90 e0       	ldi	r25, 0x00	; 0
    23a8:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    23ac:	3d c1       	rjmp	.+634    	; 0x2628 <LCD_Printf+0x36e>
			case ',':
				LCD_PrintSymbol(6);
    23ae:	86 e0       	ldi	r24, 0x06	; 6
    23b0:	90 e0       	ldi	r25, 0x00	; 0
    23b2:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    23b6:	38 c1       	rjmp	.+624    	; 0x2628 <LCD_Printf+0x36e>
			case ':':
				LCD_PrintSymbol(7);
    23b8:	87 e0       	ldi	r24, 0x07	; 7
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    23c0:	33 c1       	rjmp	.+614    	; 0x2628 <LCD_Printf+0x36e>
			case ';':
				LCD_PrintSymbol(8);
    23c2:	88 e0       	ldi	r24, 0x08	; 8
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_PrintSymbol>
				break;
    23ca:	2e c1       	rjmp	.+604    	; 0x2628 <LCD_Printf+0x36e>
			case '?':
				LCD_PrintBlock();
    23cc:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <LCD_PrintBlock>
				break;
    23d0:	2b c1       	rjmp	.+598    	; 0x2628 <LCD_Printf+0x36e>
			case '[':
				LCD_PrintLArrow();
    23d2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <LCD_PrintLArrow>
				break;
    23d6:	28 c1       	rjmp	.+592    	; 0x2628 <LCD_Printf+0x36e>
			case ']':
				LCD_PrintRArrow();
    23d8:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <LCD_PrintRArrow>
				break;
    23dc:	25 c1       	rjmp	.+586    	; 0x2628 <LCD_Printf+0x36e>
			case '.':
				LCD_PrintDot();
    23de:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <LCD_PrintDot>
				break;
    23e2:	22 c1       	rjmp	.+580    	; 0x2628 <LCD_Printf+0x36e>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    23e4:	8b 89       	ldd	r24, Y+19	; 0x13
    23e6:	9c 89       	ldd	r25, Y+20	; 0x14
    23e8:	9c 01       	movw	r18, r24
    23ea:	2e 5f       	subi	r18, 0xFE	; 254
    23ec:	3f 4f       	sbci	r19, 0xFF	; 255
    23ee:	3c 8b       	std	Y+20, r19	; 0x14
    23f0:	2b 8b       	std	Y+19, r18	; 0x13
    23f2:	fc 01       	movw	r30, r24
    23f4:	80 81       	ld	r24, Z
    23f6:	91 81       	ldd	r25, Z+1	; 0x01
    23f8:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    23fa:	89 85       	ldd	r24, Y+9	; 0x09
    23fc:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				break;
    2400:	13 c1       	rjmp	.+550    	; 0x2628 <LCD_Printf+0x36e>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    2402:	8b 89       	ldd	r24, Y+19	; 0x13
    2404:	9c 89       	ldd	r25, Y+20	; 0x14
    2406:	9c 01       	movw	r18, r24
    2408:	2e 5f       	subi	r18, 0xFE	; 254
    240a:	3f 4f       	sbci	r19, 0xFF	; 255
    240c:	3c 8b       	std	Y+20, r19	; 0x14
    240e:	2b 8b       	std	Y+19, r18	; 0x13
    2410:	fc 01       	movw	r30, r24
    2412:	80 81       	ld	r24, Z
    2414:	91 81       	ldd	r25, Z+1	; 0x01
    2416:	9c 83       	std	Y+4, r25	; 0x04
    2418:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    241a:	8b 81       	ldd	r24, Y+3	; 0x03
    241c:	9c 81       	ldd	r25, Y+4	; 0x04
    241e:	99 23       	and	r25, r25
    2420:	54 f4       	brge	.+20     	; 0x2436 <LCD_Printf+0x17c>
					v_num_s16 = -v_num_s16;
    2422:	8b 81       	ldd	r24, Y+3	; 0x03
    2424:	9c 81       	ldd	r25, Y+4	; 0x04
    2426:	91 95       	neg	r25
    2428:	81 95       	neg	r24
    242a:	91 09       	sbc	r25, r1
    242c:	9c 83       	std	Y+4, r25	; 0x04
    242e:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    2430:	8d e2       	ldi	r24, 0x2D	; 45
    2432:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s16,
    2436:	8b 81       	ldd	r24, Y+3	; 0x03
    2438:	9c 81       	ldd	r25, Y+4	; 0x04
    243a:	aa 27       	eor	r26, r26
    243c:	97 fd       	sbrc	r25, 7
    243e:	a0 95       	com	r26
    2440:	ba 2f       	mov	r27, r26
    2442:	2a 85       	ldd	r18, Y+10	; 0x0a
    2444:	ac 01       	movw	r20, r24
    2446:	bd 01       	movw	r22, r26
    2448:	8a e0       	ldi	r24, 0x0A	; 10
    244a:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    244e:	ec c0       	rjmp	.+472    	; 0x2628 <LCD_Printf+0x36e>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    2450:	8b 89       	ldd	r24, Y+19	; 0x13
    2452:	9c 89       	ldd	r25, Y+20	; 0x14
    2454:	9c 01       	movw	r18, r24
    2456:	2c 5f       	subi	r18, 0xFC	; 252
    2458:	3f 4f       	sbci	r19, 0xFF	; 255
    245a:	3c 8b       	std	Y+20, r19	; 0x14
    245c:	2b 8b       	std	Y+19, r18	; 0x13
    245e:	fc 01       	movw	r30, r24
    2460:	80 81       	ld	r24, Z
    2462:	91 81       	ldd	r25, Z+1	; 0x01
    2464:	a2 81       	ldd	r26, Z+2	; 0x02
    2466:	b3 81       	ldd	r27, Z+3	; 0x03
    2468:	8d 83       	std	Y+5, r24	; 0x05
    246a:	9e 83       	std	Y+6, r25	; 0x06
    246c:	af 83       	std	Y+7, r26	; 0x07
    246e:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    2470:	8d 81       	ldd	r24, Y+5	; 0x05
    2472:	9e 81       	ldd	r25, Y+6	; 0x06
    2474:	af 81       	ldd	r26, Y+7	; 0x07
    2476:	b8 85       	ldd	r27, Y+8	; 0x08
    2478:	bb 23       	and	r27, r27
    247a:	94 f4       	brge	.+36     	; 0x24a0 <LCD_Printf+0x1e6>
					v_num_s32 = -v_num_s32;
    247c:	8d 81       	ldd	r24, Y+5	; 0x05
    247e:	9e 81       	ldd	r25, Y+6	; 0x06
    2480:	af 81       	ldd	r26, Y+7	; 0x07
    2482:	b8 85       	ldd	r27, Y+8	; 0x08
    2484:	b0 95       	com	r27
    2486:	a0 95       	com	r26
    2488:	90 95       	com	r25
    248a:	81 95       	neg	r24
    248c:	9f 4f       	sbci	r25, 0xFF	; 255
    248e:	af 4f       	sbci	r26, 0xFF	; 255
    2490:	bf 4f       	sbci	r27, 0xFF	; 255
    2492:	8d 83       	std	Y+5, r24	; 0x05
    2494:	9e 83       	std	Y+6, r25	; 0x06
    2496:	af 83       	std	Y+7, r26	; 0x07
    2498:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    249a:	8d e2       	ldi	r24, 0x2D	; 45
    249c:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s32,
    24a0:	8d 81       	ldd	r24, Y+5	; 0x05
    24a2:	9e 81       	ldd	r25, Y+6	; 0x06
    24a4:	af 81       	ldd	r26, Y+7	; 0x07
    24a6:	b8 85       	ldd	r27, Y+8	; 0x08
    24a8:	2a 85       	ldd	r18, Y+10	; 0x0a
    24aa:	ac 01       	movw	r20, r24
    24ac:	bd 01       	movw	r22, r26
    24ae:	8a e0       	ldi	r24, 0x0A	; 10
    24b0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    24b4:	b9 c0       	rjmp	.+370    	; 0x2628 <LCD_Printf+0x36e>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    24b6:	8b 89       	ldd	r24, Y+19	; 0x13
    24b8:	9c 89       	ldd	r25, Y+20	; 0x14
    24ba:	9c 01       	movw	r18, r24
    24bc:	2e 5f       	subi	r18, 0xFE	; 254
    24be:	3f 4f       	sbci	r19, 0xFF	; 255
    24c0:	3c 8b       	std	Y+20, r19	; 0x14
    24c2:	2b 8b       	std	Y+19, r18	; 0x13
    24c4:	fc 01       	movw	r30, r24
    24c6:	80 81       	ld	r24, Z
    24c8:	91 81       	ldd	r25, Z+1	; 0x01
    24ca:	9c 87       	std	Y+12, r25	; 0x0c
    24cc:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u16,
    24ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    24d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    24d2:	cc 01       	movw	r24, r24
    24d4:	a0 e0       	ldi	r26, 0x00	; 0
    24d6:	b0 e0       	ldi	r27, 0x00	; 0
    24d8:	2a 85       	ldd	r18, Y+10	; 0x0a
    24da:	ac 01       	movw	r20, r24
    24dc:	bd 01       	movw	r22, r26
    24de:	8a e0       	ldi	r24, 0x0A	; 10
    24e0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    24e4:	a1 c0       	rjmp	.+322    	; 0x2628 <LCD_Printf+0x36e>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    24e6:	8b 89       	ldd	r24, Y+19	; 0x13
    24e8:	9c 89       	ldd	r25, Y+20	; 0x14
    24ea:	9c 01       	movw	r18, r24
    24ec:	2c 5f       	subi	r18, 0xFC	; 252
    24ee:	3f 4f       	sbci	r19, 0xFF	; 255
    24f0:	3c 8b       	std	Y+20, r19	; 0x14
    24f2:	2b 8b       	std	Y+19, r18	; 0x13
    24f4:	fc 01       	movw	r30, r24
    24f6:	80 81       	ld	r24, Z
    24f8:	91 81       	ldd	r25, Z+1	; 0x01
    24fa:	a2 81       	ldd	r26, Z+2	; 0x02
    24fc:	b3 81       	ldd	r27, Z+3	; 0x03
    24fe:	8d 87       	std	Y+13, r24	; 0x0d
    2500:	9e 87       	std	Y+14, r25	; 0x0e
    2502:	af 87       	std	Y+15, r26	; 0x0f
    2504:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u32,
    2506:	8d 85       	ldd	r24, Y+13	; 0x0d
    2508:	9e 85       	ldd	r25, Y+14	; 0x0e
    250a:	af 85       	ldd	r26, Y+15	; 0x0f
    250c:	b8 89       	ldd	r27, Y+16	; 0x10
    250e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2510:	ac 01       	movw	r20, r24
    2512:	bd 01       	movw	r22, r26
    2514:	8a e0       	ldi	r24, 0x0A	; 10
    2516:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    251a:	86 c0       	rjmp	.+268    	; 0x2628 <LCD_Printf+0x36e>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    251c:	8b 89       	ldd	r24, Y+19	; 0x13
    251e:	9c 89       	ldd	r25, Y+20	; 0x14
    2520:	9c 01       	movw	r18, r24
    2522:	2e 5f       	subi	r18, 0xFE	; 254
    2524:	3f 4f       	sbci	r19, 0xFF	; 255
    2526:	3c 8b       	std	Y+20, r19	; 0x14
    2528:	2b 8b       	std	Y+19, r18	; 0x13
    252a:	fc 01       	movw	r30, r24
    252c:	80 81       	ld	r24, Z
    252e:	91 81       	ldd	r25, Z+1	; 0x01
    2530:	9c 87       	std	Y+12, r25	; 0x0c
    2532:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_HEX_U8, v_num_u16, v_numOfDigitsToDisp_u8);
    2534:	8b 85       	ldd	r24, Y+11	; 0x0b
    2536:	9c 85       	ldd	r25, Y+12	; 0x0c
    2538:	cc 01       	movw	r24, r24
    253a:	a0 e0       	ldi	r26, 0x00	; 0
    253c:	b0 e0       	ldi	r27, 0x00	; 0
    253e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2540:	ac 01       	movw	r20, r24
    2542:	bd 01       	movw	r22, r26
    2544:	80 e1       	ldi	r24, 0x10	; 16
    2546:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
				break;
    254a:	6e c0       	rjmp	.+220    	; 0x2628 <LCD_Printf+0x36e>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    254c:	8b 89       	ldd	r24, Y+19	; 0x13
    254e:	9c 89       	ldd	r25, Y+20	; 0x14
    2550:	9c 01       	movw	r18, r24
    2552:	2c 5f       	subi	r18, 0xFC	; 252
    2554:	3f 4f       	sbci	r19, 0xFF	; 255
    2556:	3c 8b       	std	Y+20, r19	; 0x14
    2558:	2b 8b       	std	Y+19, r18	; 0x13
    255a:	fc 01       	movw	r30, r24
    255c:	80 81       	ld	r24, Z
    255e:	91 81       	ldd	r25, Z+1	; 0x01
    2560:	a2 81       	ldd	r26, Z+2	; 0x02
    2562:	b3 81       	ldd	r27, Z+3	; 0x03
    2564:	8d 87       	std	Y+13, r24	; 0x0d
    2566:	9e 87       	std	Y+14, r25	; 0x0e
    2568:	af 87       	std	Y+15, r26	; 0x0f
    256a:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_HEX_U8, v_num_u32, v_numOfDigitsToDisp_u8);
    256c:	8d 85       	ldd	r24, Y+13	; 0x0d
    256e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2570:	af 85       	ldd	r26, Y+15	; 0x0f
    2572:	b8 89       	ldd	r27, Y+16	; 0x10
    2574:	2a 85       	ldd	r18, Y+10	; 0x0a
    2576:	ac 01       	movw	r20, r24
    2578:	bd 01       	movw	r22, r26
    257a:	80 e1       	ldi	r24, 0x10	; 16
    257c:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
				break;
    2580:	53 c0       	rjmp	.+166    	; 0x2628 <LCD_Printf+0x36e>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    2582:	8b 89       	ldd	r24, Y+19	; 0x13
    2584:	9c 89       	ldd	r25, Y+20	; 0x14
    2586:	9c 01       	movw	r18, r24
    2588:	2e 5f       	subi	r18, 0xFE	; 254
    258a:	3f 4f       	sbci	r19, 0xFF	; 255
    258c:	3c 8b       	std	Y+20, r19	; 0x14
    258e:	2b 8b       	std	Y+19, r18	; 0x13
    2590:	fc 01       	movw	r30, r24
    2592:	80 81       	ld	r24, Z
    2594:	91 81       	ldd	r25, Z+1	; 0x01
    2596:	9c 87       	std	Y+12, r25	; 0x0c
    2598:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    259a:	8a 85       	ldd	r24, Y+10	; 0x0a
    259c:	8f 3f       	cpi	r24, 0xFF	; 255
    259e:	11 f4       	brne	.+4      	; 0x25a4 <LCD_Printf+0x2ea>
					v_numOfDigitsToDisp_u8 = 16;
    25a0:	80 e1       	ldi	r24, 0x10	; 16
    25a2:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u16,
    25a4:	8b 85       	ldd	r24, Y+11	; 0x0b
    25a6:	9c 85       	ldd	r25, Y+12	; 0x0c
    25a8:	cc 01       	movw	r24, r24
    25aa:	a0 e0       	ldi	r26, 0x00	; 0
    25ac:	b0 e0       	ldi	r27, 0x00	; 0
    25ae:	2a 85       	ldd	r18, Y+10	; 0x0a
    25b0:	ac 01       	movw	r20, r24
    25b2:	bd 01       	movw	r22, r26
    25b4:	82 e0       	ldi	r24, 0x02	; 2
    25b6:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    25ba:	36 c0       	rjmp	.+108    	; 0x2628 <LCD_Printf+0x36e>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    25bc:	8b 89       	ldd	r24, Y+19	; 0x13
    25be:	9c 89       	ldd	r25, Y+20	; 0x14
    25c0:	9c 01       	movw	r18, r24
    25c2:	2c 5f       	subi	r18, 0xFC	; 252
    25c4:	3f 4f       	sbci	r19, 0xFF	; 255
    25c6:	3c 8b       	std	Y+20, r19	; 0x14
    25c8:	2b 8b       	std	Y+19, r18	; 0x13
    25ca:	fc 01       	movw	r30, r24
    25cc:	80 81       	ld	r24, Z
    25ce:	91 81       	ldd	r25, Z+1	; 0x01
    25d0:	a2 81       	ldd	r26, Z+2	; 0x02
    25d2:	b3 81       	ldd	r27, Z+3	; 0x03
    25d4:	8d 87       	std	Y+13, r24	; 0x0d
    25d6:	9e 87       	std	Y+14, r25	; 0x0e
    25d8:	af 87       	std	Y+15, r26	; 0x0f
    25da:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    25dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    25de:	8f 3f       	cpi	r24, 0xFF	; 255
    25e0:	11 f4       	brne	.+4      	; 0x25e6 <LCD_Printf+0x32c>
					v_numOfDigitsToDisp_u8 = 16;
    25e2:	80 e1       	ldi	r24, 0x10	; 16
    25e4:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u32,
    25e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    25e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    25ea:	af 85       	ldd	r26, Y+15	; 0x0f
    25ec:	b8 89       	ldd	r27, Y+16	; 0x10
    25ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    25f0:	ac 01       	movw	r20, r24
    25f2:	bd 01       	movw	r22, r26
    25f4:	82 e0       	ldi	r24, 0x02	; 2
    25f6:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    25fa:	16 c0       	rjmp	.+44     	; 0x2628 <LCD_Printf+0x36e>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    25fc:	8b 89       	ldd	r24, Y+19	; 0x13
    25fe:	9c 89       	ldd	r25, Y+20	; 0x14
    2600:	9c 01       	movw	r18, r24
    2602:	2e 5f       	subi	r18, 0xFE	; 254
    2604:	3f 4f       	sbci	r19, 0xFF	; 255
    2606:	3c 8b       	std	Y+20, r19	; 0x14
    2608:	2b 8b       	std	Y+19, r18	; 0x13
    260a:	fc 01       	movw	r30, r24
    260c:	80 81       	ld	r24, Z
    260e:	91 81       	ldd	r25, Z+1	; 0x01
    2610:	9a 8b       	std	Y+18, r25	; 0x12
    2612:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayString(str);
    2614:	89 89       	ldd	r24, Y+17	; 0x11
    2616:	9a 89       	ldd	r25, Y+18	; 0x12
    2618:	0e 94 8d 08 	call	0x111a	; 0x111a <LCD_DisplayString>
				break;
    261c:	05 c0       	rjmp	.+10     	; 0x2628 <LCD_Printf+0x36e>

			case '%':
				LCD_DisplayChar('%');
    261e:	85 e2       	ldi	r24, 0x25	; 37
    2620:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
				break;
    2624:	01 c0       	rjmp	.+2      	; 0x2628 <LCD_Printf+0x36e>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)
                v_floatNum_f32 = va_arg(argp, double);
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    2626:	00 00       	nop
    2628:	03 c0       	rjmp	.+6      	; 0x2630 <LCD_Printf+0x376>
				LCD_DisplayChar('%');
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    262a:	89 85       	ldd	r24, Y+9	; 0x09
    262c:	0e 94 6d 08 	call	0x10da	; 0x10da <LCD_DisplayChar>
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    2630:	89 81       	ldd	r24, Y+1	; 0x01
    2632:	9a 81       	ldd	r25, Y+2	; 0x02
    2634:	01 96       	adiw	r24, 0x01	; 1
    2636:	9a 83       	std	Y+2, r25	; 0x02
    2638:	89 83       	std	Y+1, r24	; 0x01
    263a:	89 81       	ldd	r24, Y+1	; 0x01
    263c:	9a 81       	ldd	r25, Y+2	; 0x02
    263e:	fc 01       	movw	r30, r24
    2640:	80 81       	ld	r24, Z
    2642:	88 23       	and	r24, r24
    2644:	09 f0       	breq	.+2      	; 0x2648 <LCD_Printf+0x38e>
    2646:	4c ce       	rjmp	.-872    	; 0x22e0 <LCD_Printf+0x26>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
    2648:	64 96       	adiw	r28, 0x14	; 20
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	de bf       	out	0x3e, r29	; 62
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	cd bf       	out	0x3d, r28	; 61
    2654:	df 91       	pop	r29
    2656:	cf 91       	pop	r28
    2658:	08 95       	ret

0000265a <lcd_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .    
 **************************************************************************************************/
static void lcd_DataWrite(uint8_t dataByte) {
    265a:	cf 93       	push	r28
    265c:	df 93       	push	r29
    265e:	1f 92       	push	r1
    2660:	cd b7       	in	r28, 0x3d	; 61
    2662:	de b7       	in	r29, 0x3e	; 62
    2664:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    2666:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    266a:	80 91 d4 00 	lds	r24, 0x00D4
    266e:	88 30       	cpi	r24, 0x08	; 8
    2670:	21 f4       	brne	.+8      	; 0x267a <lcd_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    2672:	89 81       	ldd	r24, Y+1	; 0x01
    2674:	0e 94 34 14 	call	0x2868	; 0x2868 <lcd_SendLowerNibble>
    2678:	09 c0       	rjmp	.+18     	; 0x268c <lcd_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    267a:	89 81       	ldd	r24, Y+1	; 0x01
    267c:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    2680:	0e 94 99 14 	call	0x2932	; 0x2932 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    2684:	89 81       	ldd	r24, Y+1	; 0x01
    2686:	82 95       	swap	r24
    2688:	80 7f       	andi	r24, 0xF0	; 240
    268a:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    268c:	89 81       	ldd	r24, Y+1	; 0x01
    268e:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    2692:	0e 94 99 14 	call	0x2932	; 0x2932 <lcd_SendDataSignals>
}
    2696:	0f 90       	pop	r0
    2698:	df 91       	pop	r29
    269a:	cf 91       	pop	r28
    269c:	08 95       	ret

0000269e <LCD_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .
 **************************************************************************************************/
void LCD_DataWrite(uint8_t dataByte) {
    269e:	cf 93       	push	r28
    26a0:	df 93       	push	r29
    26a2:	1f 92       	push	r1
    26a4:	cd b7       	in	r28, 0x3d	; 61
    26a6:	de b7       	in	r29, 0x3e	; 62
    26a8:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    26aa:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    26ae:	80 91 d4 00 	lds	r24, 0x00D4
    26b2:	88 30       	cpi	r24, 0x08	; 8
    26b4:	21 f4       	brne	.+8      	; 0x26be <LCD_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    26b6:	89 81       	ldd	r24, Y+1	; 0x01
    26b8:	0e 94 34 14 	call	0x2868	; 0x2868 <lcd_SendLowerNibble>
    26bc:	09 c0       	rjmp	.+18     	; 0x26d0 <LCD_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    26c4:	0e 94 99 14 	call	0x2932	; 0x2932 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    26c8:	89 81       	ldd	r24, Y+1	; 0x01
    26ca:	82 95       	swap	r24
    26cc:	80 7f       	andi	r24, 0xF0	; 240
    26ce:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    26d0:	89 81       	ldd	r24, Y+1	; 0x01
    26d2:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    26d6:	0e 94 99 14 	call	0x2932	; 0x2932 <lcd_SendDataSignals>
}
    26da:	0f 90       	pop	r0
    26dc:	df 91       	pop	r29
    26de:	cf 91       	pop	r28
    26e0:	08 95       	ret

000026e2 <lcd_BusyCheck>:

 * description : This functions is used check whether LCD is busy.
 It waits till the LCD is busy by polling the LCD busy flag.
 After completing the previous operation, LCDs clears its internal busy flag.
 **************************************************************************************************/
static void lcd_BusyCheck(void) {
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	1f 92       	push	r1
    26e8:	cd b7       	in	r28, 0x3d	; 61
    26ea:	de b7       	in	r29, 0x3e	; 62
	uint8_t busyflag;

	if (LCDConfig.RW != P_NC)             //Perform Busy check if RW pin is used
    26ec:	80 91 d6 00 	lds	r24, 0x00D6
    26f0:	8f 3f       	cpi	r24, 0xFF	; 255
    26f2:	09 f4       	brne	.+2      	; 0x26f6 <lcd_BusyCheck+0x14>
    26f4:	45 c0       	rjmp	.+138    	; 0x2780 <lcd_BusyCheck+0x9e>
			{
		GPIO_PinDirection(LCDConfig.D7, INPUT); // Configure busy pin as input
    26f6:	80 91 df 00 	lds	r24, 0x00DF
    26fa:	60 e0       	ldi	r22, 0x00	; 0
    26fc:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
		GPIO_PinWrite(LCDConfig.RS, 0); // Select the Command Register by pulling RS LOW
    2700:	80 91 d5 00 	lds	r24, 0x00D5
    2704:	60 e0       	ldi	r22, 0x00	; 0
    2706:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
		GPIO_PinWrite(LCDConfig.RW, 1); // Select the Read Operation for busy flag by setting RW
    270a:	80 91 d6 00 	lds	r24, 0x00D6
    270e:	61 e0       	ldi	r22, 0x01	; 1
    2710:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
		do {

			GPIO_PinWrite(LCDConfig.EN, 0);
    2714:	80 91 d7 00 	lds	r24, 0x00D7
    2718:	60 e0       	ldi	r22, 0x00	; 0
    271a:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
			DELAY_us(10);
    271e:	8a e0       	ldi	r24, 0x0A	; 10
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
			GPIO_PinWrite(LCDConfig.EN, 1);
    2726:	80 91 d7 00 	lds	r24, 0x00D7
    272a:	61 e0       	ldi	r22, 0x01	; 1
    272c:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
			DELAY_us(10);
    2730:	8a e0       	ldi	r24, 0x0A	; 10
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
			busyflag = GPIO_PinRead(LCDConfig.D7);
    2738:	80 91 df 00 	lds	r24, 0x00DF
    273c:	0e 94 98 06 	call	0xd30	; 0xd30 <GPIO_PinRead>
    2740:	89 83       	std	Y+1, r24	; 0x01

			if (LCDConfig.v_LcdMode_U8 == 4) {
    2742:	80 91 d4 00 	lds	r24, 0x00D4
    2746:	84 30       	cpi	r24, 0x04	; 4
    2748:	91 f4       	brne	.+36     	; 0x276e <lcd_BusyCheck+0x8c>
				/* Perform extra dummy read for 4-bit */
				GPIO_PinWrite(LCDConfig.EN, 0);
    274a:	80 91 d7 00 	lds	r24, 0x00D7
    274e:	60 e0       	ldi	r22, 0x00	; 0
    2750:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
				DELAY_us(10);
    2754:	8a e0       	ldi	r24, 0x0A	; 10
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
				GPIO_PinWrite(LCDConfig.EN, 1);
    275c:	80 91 d7 00 	lds	r24, 0x00D7
    2760:	61 e0       	ldi	r22, 0x01	; 1
    2762:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
				DELAY_us(10);
    2766:	8a e0       	ldi	r24, 0x0A	; 10
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
			}
		} while (busyflag != 0);
    276e:	89 81       	ldd	r24, Y+1	; 0x01
    2770:	88 23       	and	r24, r24
    2772:	81 f6       	brne	.-96     	; 0x2714 <lcd_BusyCheck+0x32>

		GPIO_PinDirection(LCDConfig.D7, OUTPUT); // Configure busy pin as Output
    2774:	80 91 df 00 	lds	r24, 0x00DF
    2778:	61 e0       	ldi	r22, 0x01	; 1
    277a:	0e 94 c0 04 	call	0x980	; 0x980 <GPIO_PinDirection>
    277e:	04 c0       	rjmp	.+8      	; 0x2788 <lcd_BusyCheck+0xa6>
	} else {
		/* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added
		 to ensure the LCD completes previous operation and ready to receive new commands/data */
		DELAY_ms(1);
    2780:	81 e0       	ldi	r24, 0x01	; 1
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	0e 94 f5 02 	call	0x5ea	; 0x5ea <DELAY_ms>
	}
}
    2788:	0f 90       	pop	r0
    278a:	df 91       	pop	r29
    278c:	cf 91       	pop	r28
    278e:	08 95       	ret

00002790 <lcd_Reset>:
 * Return value    : none

 * description : This functions is used to reset the LCD. 
 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
 ----------------------------------------------------------------------------------*/
static void lcd_Reset(void) {
    2790:	cf 93       	push	r28
    2792:	df 93       	push	r29
    2794:	cd b7       	in	r28, 0x3d	; 61
    2796:	de b7       	in	r29, 0x3e	; 62
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendHigherNibble(0x30);
    2798:	80 e3       	ldi	r24, 0x30	; 48
    279a:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    279e:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
	DELAY_ms(100);
    27a2:	84 e6       	ldi	r24, 0x64	; 100
    27a4:	90 e0       	ldi	r25, 0x00	; 0
    27a6:	0e 94 f5 02 	call	0x5ea	; 0x5ea <DELAY_ms>
	lcd_SendHigherNibble(0x30);
    27aa:	80 e3       	ldi	r24, 0x30	; 48
    27ac:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    27b0:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
	DELAY_us(200);
    27b4:	88 ec       	ldi	r24, 0xC8	; 200
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
	lcd_SendHigherNibble(0x30);
    27bc:	80 e3       	ldi	r24, 0x30	; 48
    27be:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    27c2:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
	DELAY_us(200);
    27c6:	88 ec       	ldi	r24, 0xC8	; 200
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
	lcd_SendHigherNibble(0x20);
    27ce:	80 e2       	ldi	r24, 0x20	; 32
    27d0:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    27d4:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <lcd_SendCmdSignals>
	DELAY_us(200);
    27d8:	88 ec       	ldi	r24, 0xC8	; 200
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
}
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	08 95       	ret

000027e6 <lcd_SendHigherNibble>:
 * I/P Arguments: uint8_t: Higher nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 **************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte) {
    27e6:	cf 93       	push	r28
    27e8:	df 93       	push	r29
    27ea:	1f 92       	push	r1
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
    27f0:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D4, util_IsBitSet(dataByte, 4));
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	88 2f       	mov	r24, r24
    27f6:	90 e0       	ldi	r25, 0x00	; 0
    27f8:	80 71       	andi	r24, 0x10	; 16
    27fa:	99 27       	eor	r25, r25
    27fc:	21 e0       	ldi	r18, 0x01	; 1
    27fe:	00 97       	sbiw	r24, 0x00	; 0
    2800:	09 f4       	brne	.+2      	; 0x2804 <lcd_SendHigherNibble+0x1e>
    2802:	20 e0       	ldi	r18, 0x00	; 0
    2804:	92 2f       	mov	r25, r18
    2806:	80 91 dc 00 	lds	r24, 0x00DC
    280a:	69 2f       	mov	r22, r25
    280c:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D5, util_IsBitSet(dataByte, 5));
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	88 2f       	mov	r24, r24
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	80 72       	andi	r24, 0x20	; 32
    2818:	99 27       	eor	r25, r25
    281a:	21 e0       	ldi	r18, 0x01	; 1
    281c:	00 97       	sbiw	r24, 0x00	; 0
    281e:	09 f4       	brne	.+2      	; 0x2822 <lcd_SendHigherNibble+0x3c>
    2820:	20 e0       	ldi	r18, 0x00	; 0
    2822:	92 2f       	mov	r25, r18
    2824:	80 91 dd 00 	lds	r24, 0x00DD
    2828:	69 2f       	mov	r22, r25
    282a:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D6, util_IsBitSet(dataByte, 6));
    282e:	89 81       	ldd	r24, Y+1	; 0x01
    2830:	88 2f       	mov	r24, r24
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	80 74       	andi	r24, 0x40	; 64
    2836:	99 27       	eor	r25, r25
    2838:	21 e0       	ldi	r18, 0x01	; 1
    283a:	00 97       	sbiw	r24, 0x00	; 0
    283c:	09 f4       	brne	.+2      	; 0x2840 <lcd_SendHigherNibble+0x5a>
    283e:	20 e0       	ldi	r18, 0x00	; 0
    2840:	92 2f       	mov	r25, r18
    2842:	80 91 de 00 	lds	r24, 0x00DE
    2846:	69 2f       	mov	r22, r25
    2848:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D7, util_IsBitSet(dataByte, 7));
    284c:	89 81       	ldd	r24, Y+1	; 0x01
    284e:	88 1f       	adc	r24, r24
    2850:	88 27       	eor	r24, r24
    2852:	88 1f       	adc	r24, r24
    2854:	98 2f       	mov	r25, r24
    2856:	80 91 df 00 	lds	r24, 0x00DF
    285a:	69 2f       	mov	r22, r25
    285c:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
}
    2860:	0f 90       	pop	r0
    2862:	df 91       	pop	r29
    2864:	cf 91       	pop	r28
    2866:	08 95       	ret

00002868 <lcd_SendLowerNibble>:
 * I/P Arguments: uint8_t: Lower nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
 **************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte) {
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
    286c:	1f 92       	push	r1
    286e:	cd b7       	in	r28, 0x3d	; 61
    2870:	de b7       	in	r29, 0x3e	; 62
    2872:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D0, util_IsBitSet(dataByte, 0));
    2874:	89 81       	ldd	r24, Y+1	; 0x01
    2876:	88 2f       	mov	r24, r24
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	81 70       	andi	r24, 0x01	; 1
    287c:	99 27       	eor	r25, r25
    287e:	21 e0       	ldi	r18, 0x01	; 1
    2880:	00 97       	sbiw	r24, 0x00	; 0
    2882:	09 f4       	brne	.+2      	; 0x2886 <lcd_SendLowerNibble+0x1e>
    2884:	20 e0       	ldi	r18, 0x00	; 0
    2886:	92 2f       	mov	r25, r18
    2888:	80 91 d8 00 	lds	r24, 0x00D8
    288c:	69 2f       	mov	r22, r25
    288e:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D1, util_IsBitSet(dataByte, 1));
    2892:	89 81       	ldd	r24, Y+1	; 0x01
    2894:	88 2f       	mov	r24, r24
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	82 70       	andi	r24, 0x02	; 2
    289a:	99 27       	eor	r25, r25
    289c:	21 e0       	ldi	r18, 0x01	; 1
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	09 f4       	brne	.+2      	; 0x28a4 <lcd_SendLowerNibble+0x3c>
    28a2:	20 e0       	ldi	r18, 0x00	; 0
    28a4:	92 2f       	mov	r25, r18
    28a6:	80 91 d9 00 	lds	r24, 0x00D9
    28aa:	69 2f       	mov	r22, r25
    28ac:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D2, util_IsBitSet(dataByte, 2));
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	88 2f       	mov	r24, r24
    28b4:	90 e0       	ldi	r25, 0x00	; 0
    28b6:	84 70       	andi	r24, 0x04	; 4
    28b8:	99 27       	eor	r25, r25
    28ba:	21 e0       	ldi	r18, 0x01	; 1
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	09 f4       	brne	.+2      	; 0x28c2 <lcd_SendLowerNibble+0x5a>
    28c0:	20 e0       	ldi	r18, 0x00	; 0
    28c2:	92 2f       	mov	r25, r18
    28c4:	80 91 da 00 	lds	r24, 0x00DA
    28c8:	69 2f       	mov	r22, r25
    28ca:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D3, util_IsBitSet(dataByte, 3));
    28ce:	89 81       	ldd	r24, Y+1	; 0x01
    28d0:	88 2f       	mov	r24, r24
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	88 70       	andi	r24, 0x08	; 8
    28d6:	99 27       	eor	r25, r25
    28d8:	21 e0       	ldi	r18, 0x01	; 1
    28da:	00 97       	sbiw	r24, 0x00	; 0
    28dc:	09 f4       	brne	.+2      	; 0x28e0 <lcd_SendLowerNibble+0x78>
    28de:	20 e0       	ldi	r18, 0x00	; 0
    28e0:	92 2f       	mov	r25, r18
    28e2:	80 91 db 00 	lds	r24, 0x00DB
    28e6:	69 2f       	mov	r22, r25
    28e8:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
}
    28ec:	0f 90       	pop	r0
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	08 95       	ret

000028f4 <lcd_SendCmdSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
 **************************************************************************************************/
static void lcd_SendCmdSignals(void) {
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 0);
    28fc:	80 91 d5 00 	lds	r24, 0x00D5
    2900:	60 e0       	ldi	r22, 0x00	; 0
    2902:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    2906:	80 91 d6 00 	lds	r24, 0x00D6
    290a:	60 e0       	ldi	r22, 0x00	; 0
    290c:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    2910:	80 91 d7 00 	lds	r24, 0x00D7
    2914:	61 e0       	ldi	r22, 0x01	; 1
    2916:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	DELAY_us(10);
    291a:	8a e0       	ldi	r24, 0x0A	; 10
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    2922:	80 91 d7 00 	lds	r24, 0x00D7
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>

}
    292c:	df 91       	pop	r29
    292e:	cf 91       	pop	r28
    2930:	08 95       	ret

00002932 <lcd_SendDataSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
 **************************************************************************************************/
static void lcd_SendDataSignals(void) {
    2932:	cf 93       	push	r28
    2934:	df 93       	push	r29
    2936:	cd b7       	in	r28, 0x3d	; 61
    2938:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 1);
    293a:	80 91 d5 00 	lds	r24, 0x00D5
    293e:	61 e0       	ldi	r22, 0x01	; 1
    2940:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    2944:	80 91 d6 00 	lds	r24, 0x00D6
    2948:	60 e0       	ldi	r22, 0x00	; 0
    294a:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    294e:	80 91 d7 00 	lds	r24, 0x00D7
    2952:	61 e0       	ldi	r22, 0x01	; 1
    2954:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
	DELAY_us(10);
    2958:	8a e0       	ldi	r24, 0x0A	; 10
    295a:	90 e0       	ldi	r25, 0x00	; 0
    295c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    2960:	80 91 d7 00 	lds	r24, 0x00D7
    2964:	60 e0       	ldi	r22, 0x00	; 0
    2966:	0e 94 ac 05 	call	0xb58	; 0xb58 <GPIO_PinWrite>
}
    296a:	df 91       	pop	r29
    296c:	cf 91       	pop	r28
    296e:	08 95       	ret

00002970 <LCD_RefreshScreen>:

void LCD_RefreshScreen(int *clock, int valueToRefresh) {
    2970:	cf 93       	push	r28
    2972:	df 93       	push	r29
    2974:	00 d0       	rcall	.+0      	; 0x2976 <LCD_RefreshScreen+0x6>
    2976:	00 d0       	rcall	.+0      	; 0x2978 <LCD_RefreshScreen+0x8>
    2978:	cd b7       	in	r28, 0x3d	; 61
    297a:	de b7       	in	r29, 0x3e	; 62
    297c:	9a 83       	std	Y+2, r25	; 0x02
    297e:	89 83       	std	Y+1, r24	; 0x01
    2980:	7c 83       	std	Y+4, r23	; 0x04
    2982:	6b 83       	std	Y+3, r22	; 0x03
	clock++;
    2984:	89 81       	ldd	r24, Y+1	; 0x01
    2986:	9a 81       	ldd	r25, Y+2	; 0x02
    2988:	02 96       	adiw	r24, 0x02	; 2
    298a:	9a 83       	std	Y+2, r25	; 0x02
    298c:	89 83       	std	Y+1, r24	; 0x01
	if ((*clock) >= valueToRefresh) {
    298e:	89 81       	ldd	r24, Y+1	; 0x01
    2990:	9a 81       	ldd	r25, Y+2	; 0x02
    2992:	fc 01       	movw	r30, r24
    2994:	20 81       	ld	r18, Z
    2996:	31 81       	ldd	r19, Z+1	; 0x01
    2998:	8b 81       	ldd	r24, Y+3	; 0x03
    299a:	9c 81       	ldd	r25, Y+4	; 0x04
    299c:	28 17       	cp	r18, r24
    299e:	39 07       	cpc	r19, r25
    29a0:	4c f1       	brlt	.+82     	; 0x29f4 <LCD_RefreshScreen+0x84>
		LCD_XYPrintf(0, 0, LCD_BUFFOR[0]);
    29a2:	82 eb       	ldi	r24, 0xB2	; 178
    29a4:	90 e0       	ldi	r25, 0x00	; 0
    29a6:	89 2f       	mov	r24, r25
    29a8:	8f 93       	push	r24
    29aa:	82 eb       	ldi	r24, 0xB2	; 178
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	8f 93       	push	r24
    29b0:	1f 92       	push	r1
    29b2:	1f 92       	push	r1
    29b4:	1f 92       	push	r1
    29b6:	1f 92       	push	r1
    29b8:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <LCD_XYPrintf>
    29bc:	0f 90       	pop	r0
    29be:	0f 90       	pop	r0
    29c0:	0f 90       	pop	r0
    29c2:	0f 90       	pop	r0
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
		LCD_XYPrintf(1, 0, LCD_BUFFOR[1]);
    29c8:	82 ec       	ldi	r24, 0xC2	; 194
    29ca:	90 e0       	ldi	r25, 0x00	; 0
    29cc:	89 2f       	mov	r24, r25
    29ce:	8f 93       	push	r24
    29d0:	82 ec       	ldi	r24, 0xC2	; 194
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	8f 93       	push	r24
    29d6:	1f 92       	push	r1
    29d8:	1f 92       	push	r1
    29da:	1f 92       	push	r1
    29dc:	81 e0       	ldi	r24, 0x01	; 1
    29de:	8f 93       	push	r24
    29e0:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <LCD_XYPrintf>
    29e4:	0f 90       	pop	r0
    29e6:	0f 90       	pop	r0
    29e8:	0f 90       	pop	r0
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
		clock = 0;
    29f0:	1a 82       	std	Y+2, r1	; 0x02
    29f2:	19 82       	std	Y+1, r1	; 0x01
	}
}
    29f4:	0f 90       	pop	r0
    29f6:	0f 90       	pop	r0
    29f8:	0f 90       	pop	r0
    29fa:	0f 90       	pop	r0
    29fc:	df 91       	pop	r29
    29fe:	cf 91       	pop	r28
    2a00:	08 95       	ret

00002a02 <LCD_InitializeSymbols>:

void LCD_InitializeSymbols() {
    2a02:	cf 93       	push	r28
    2a04:	df 93       	push	r29
    2a06:	cd b7       	in	r28, 0x3d	; 61
    2a08:	de b7       	in	r29, 0x3e	; 62
    2a0a:	cc 54       	subi	r28, 0x4C	; 76
    2a0c:	d1 09       	sbc	r29, r1
    2a0e:	0f b6       	in	r0, 0x3f	; 63
    2a10:	f8 94       	cli
    2a12:	de bf       	out	0x3e, r29	; 62
    2a14:	0f be       	out	0x3f, r0	; 63
    2a16:	cd bf       	out	0x3d, r28	; 61
	/*
	 *  To generate new hex code of characters use page "https://maxpromer.github.io/LCD-Character-Creator/"
	 */
	uint8_t addresses[8] = { 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78 };
    2a18:	88 e0       	ldi	r24, 0x08	; 8
    2a1a:	e9 e6       	ldi	r30, 0x69	; 105
    2a1c:	f0 e0       	ldi	r31, 0x00	; 0
    2a1e:	de 01       	movw	r26, r28
    2a20:	15 96       	adiw	r26, 0x05	; 5
    2a22:	01 90       	ld	r0, Z+
    2a24:	0d 92       	st	X+, r0
    2a26:	8a 95       	dec	r24
    2a28:	e1 f7       	brne	.-8      	; 0x2a22 <LCD_InitializeSymbols+0x20>

	uint8_t symbols[8][8] = {
    2a2a:	80 e4       	ldi	r24, 0x40	; 64
    2a2c:	e1 e7       	ldi	r30, 0x71	; 113
    2a2e:	f0 e0       	ldi	r31, 0x00	; 0
    2a30:	de 01       	movw	r26, r28
    2a32:	1d 96       	adiw	r26, 0x0d	; 13
    2a34:	01 90       	ld	r0, Z+
    2a36:	0d 92       	st	X+, r0
    2a38:	8a 95       	dec	r24
    2a3a:	e1 f7       	brne	.-8      	; 0x2a34 <LCD_InitializeSymbols+0x32>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    2a3c:	1a 82       	std	Y+2, r1	; 0x02
    2a3e:	19 82       	std	Y+1, r1	; 0x01
    2a40:	33 c0       	rjmp	.+102    	; 0x2aa8 <LCD_InitializeSymbols+0xa6>
		LCD_CmdWrite(addresses[clkAddress]);
    2a42:	9e 01       	movw	r18, r28
    2a44:	2b 5f       	subi	r18, 0xFB	; 251
    2a46:	3f 4f       	sbci	r19, 0xFF	; 255
    2a48:	89 81       	ldd	r24, Y+1	; 0x01
    2a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a4c:	82 0f       	add	r24, r18
    2a4e:	93 1f       	adc	r25, r19
    2a50:	fc 01       	movw	r30, r24
    2a52:	80 81       	ld	r24, Z
    2a54:	0e 94 4b 08 	call	0x1096	; 0x1096 <LCD_CmdWrite>
		for (int clkData = 0; clkData < 8; clkData++) {
    2a58:	1c 82       	std	Y+4, r1	; 0x04
    2a5a:	1b 82       	std	Y+3, r1	; 0x03
    2a5c:	1b c0       	rjmp	.+54     	; 0x2a94 <LCD_InitializeSymbols+0x92>
			LCD_DataWrite(symbols[clkAddress][clkData]);
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
    2a60:	9a 81       	ldd	r25, Y+2	; 0x02
    2a62:	88 0f       	add	r24, r24
    2a64:	99 1f       	adc	r25, r25
    2a66:	88 0f       	add	r24, r24
    2a68:	99 1f       	adc	r25, r25
    2a6a:	88 0f       	add	r24, r24
    2a6c:	99 1f       	adc	r25, r25
    2a6e:	9e 01       	movw	r18, r28
    2a70:	2f 5f       	subi	r18, 0xFF	; 255
    2a72:	3f 4f       	sbci	r19, 0xFF	; 255
    2a74:	28 0f       	add	r18, r24
    2a76:	39 1f       	adc	r19, r25
    2a78:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7c:	82 0f       	add	r24, r18
    2a7e:	93 1f       	adc	r25, r19
    2a80:	0c 96       	adiw	r24, 0x0c	; 12
    2a82:	fc 01       	movw	r30, r24
    2a84:	80 81       	ld	r24, Z
    2a86:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
    2a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8e:	01 96       	adiw	r24, 0x01	; 1
    2a90:	9c 83       	std	Y+4, r25	; 0x04
    2a92:	8b 83       	std	Y+3, r24	; 0x03
    2a94:	8b 81       	ldd	r24, Y+3	; 0x03
    2a96:	9c 81       	ldd	r25, Y+4	; 0x04
    2a98:	88 30       	cpi	r24, 0x08	; 8
    2a9a:	91 05       	cpc	r25, r1
    2a9c:	04 f3       	brlt	.-64     	; 0x2a5e <LCD_InitializeSymbols+0x5c>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa2:	01 96       	adiw	r24, 0x01	; 1
    2aa4:	9a 83       	std	Y+2, r25	; 0x02
    2aa6:	89 83       	std	Y+1, r24	; 0x01
    2aa8:	89 81       	ldd	r24, Y+1	; 0x01
    2aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    2aac:	88 30       	cpi	r24, 0x08	; 8
    2aae:	91 05       	cpc	r25, r1
    2ab0:	44 f2       	brlt	.-112    	; 0x2a42 <LCD_InitializeSymbols+0x40>
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
			LCD_DataWrite(symbols[clkAddress][clkData]);
		}
	}
}
    2ab2:	c4 5b       	subi	r28, 0xB4	; 180
    2ab4:	df 4f       	sbci	r29, 0xFF	; 255
    2ab6:	0f b6       	in	r0, 0x3f	; 63
    2ab8:	f8 94       	cli
    2aba:	de bf       	out	0x3e, r29	; 62
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	cd bf       	out	0x3d, r28	; 61
    2ac0:	df 91       	pop	r29
    2ac2:	cf 91       	pop	r28
    2ac4:	08 95       	ret

00002ac6 <LCD_PrintSymbol>:

void LCD_PrintSymbol(int number) {
    2ac6:	cf 93       	push	r28
    2ac8:	df 93       	push	r29
    2aca:	00 d0       	rcall	.+0      	; 0x2acc <LCD_PrintSymbol+0x6>
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
    2ad0:	9a 83       	std	Y+2, r25	; 0x02
    2ad2:	89 83       	std	Y+1, r24	; 0x01
	if (number == 1)
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
    2ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad8:	81 30       	cpi	r24, 0x01	; 1
    2ada:	91 05       	cpc	r25, r1
    2adc:	21 f4       	brne	.+8      	; 0x2ae6 <LCD_PrintSymbol+0x20>
		LCD_DataWrite(0x00);
    2ade:	80 e0       	ldi	r24, 0x00	; 0
    2ae0:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2ae4:	3e c0       	rjmp	.+124    	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 2)
    2ae6:	89 81       	ldd	r24, Y+1	; 0x01
    2ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aea:	82 30       	cpi	r24, 0x02	; 2
    2aec:	91 05       	cpc	r25, r1
    2aee:	21 f4       	brne	.+8      	; 0x2af8 <LCD_PrintSymbol+0x32>
		LCD_DataWrite(0x01);
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2af6:	35 c0       	rjmp	.+106    	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 3)
    2af8:	89 81       	ldd	r24, Y+1	; 0x01
    2afa:	9a 81       	ldd	r25, Y+2	; 0x02
    2afc:	83 30       	cpi	r24, 0x03	; 3
    2afe:	91 05       	cpc	r25, r1
    2b00:	21 f4       	brne	.+8      	; 0x2b0a <LCD_PrintSymbol+0x44>
		LCD_DataWrite(0x02);
    2b02:	82 e0       	ldi	r24, 0x02	; 2
    2b04:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2b08:	2c c0       	rjmp	.+88     	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 4)
    2b0a:	89 81       	ldd	r24, Y+1	; 0x01
    2b0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b0e:	84 30       	cpi	r24, 0x04	; 4
    2b10:	91 05       	cpc	r25, r1
    2b12:	21 f4       	brne	.+8      	; 0x2b1c <LCD_PrintSymbol+0x56>
		LCD_DataWrite(0x03);
    2b14:	83 e0       	ldi	r24, 0x03	; 3
    2b16:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2b1a:	23 c0       	rjmp	.+70     	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 5)
    2b1c:	89 81       	ldd	r24, Y+1	; 0x01
    2b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b20:	85 30       	cpi	r24, 0x05	; 5
    2b22:	91 05       	cpc	r25, r1
    2b24:	21 f4       	brne	.+8      	; 0x2b2e <LCD_PrintSymbol+0x68>
		LCD_DataWrite(0x04);
    2b26:	84 e0       	ldi	r24, 0x04	; 4
    2b28:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2b2c:	1a c0       	rjmp	.+52     	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 6)
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
    2b30:	9a 81       	ldd	r25, Y+2	; 0x02
    2b32:	86 30       	cpi	r24, 0x06	; 6
    2b34:	91 05       	cpc	r25, r1
    2b36:	21 f4       	brne	.+8      	; 0x2b40 <LCD_PrintSymbol+0x7a>
		LCD_DataWrite(0x05);
    2b38:	85 e0       	ldi	r24, 0x05	; 5
    2b3a:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2b3e:	11 c0       	rjmp	.+34     	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 7)
    2b40:	89 81       	ldd	r24, Y+1	; 0x01
    2b42:	9a 81       	ldd	r25, Y+2	; 0x02
    2b44:	87 30       	cpi	r24, 0x07	; 7
    2b46:	91 05       	cpc	r25, r1
    2b48:	21 f4       	brne	.+8      	; 0x2b52 <LCD_PrintSymbol+0x8c>
		LCD_DataWrite(0x06);
    2b4a:	86 e0       	ldi	r24, 0x06	; 6
    2b4c:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
    2b50:	08 c0       	rjmp	.+16     	; 0x2b62 <LCD_PrintSymbol+0x9c>
	else if (number == 8)
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	9a 81       	ldd	r25, Y+2	; 0x02
    2b56:	88 30       	cpi	r24, 0x08	; 8
    2b58:	91 05       	cpc	r25, r1
    2b5a:	19 f4       	brne	.+6      	; 0x2b62 <LCD_PrintSymbol+0x9c>
		LCD_DataWrite(0x07);
    2b5c:	87 e0       	ldi	r24, 0x07	; 7
    2b5e:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
}
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	08 95       	ret

00002b6c <LCD_PrintBlock>:

void LCD_PrintBlock() {
    2b6c:	cf 93       	push	r28
    2b6e:	df 93       	push	r29
    2b70:	cd b7       	in	r28, 0x3d	; 61
    2b72:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xFF);
    2b74:	8f ef       	ldi	r24, 0xFF	; 255
    2b76:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
}
    2b7a:	df 91       	pop	r29
    2b7c:	cf 91       	pop	r28
    2b7e:	08 95       	ret

00002b80 <LCD_PrintLArrow>:

void LCD_PrintLArrow() {
    2b80:	cf 93       	push	r28
    2b82:	df 93       	push	r29
    2b84:	cd b7       	in	r28, 0x3d	; 61
    2b86:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7F);
    2b88:	8f e7       	ldi	r24, 0x7F	; 127
    2b8a:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
}
    2b8e:	df 91       	pop	r29
    2b90:	cf 91       	pop	r28
    2b92:	08 95       	ret

00002b94 <LCD_PrintRArrow>:

void LCD_PrintRArrow() {
    2b94:	cf 93       	push	r28
    2b96:	df 93       	push	r29
    2b98:	cd b7       	in	r28, 0x3d	; 61
    2b9a:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7E);
    2b9c:	8e e7       	ldi	r24, 0x7E	; 126
    2b9e:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
}
    2ba2:	df 91       	pop	r29
    2ba4:	cf 91       	pop	r28
    2ba6:	08 95       	ret

00002ba8 <LCD_PrintDot>:

void LCD_PrintDot() {
    2ba8:	cf 93       	push	r28
    2baa:	df 93       	push	r29
    2bac:	cd b7       	in	r28, 0x3d	; 61
    2bae:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xA5);
    2bb0:	85 ea       	ldi	r24, 0xA5	; 165
    2bb2:	0e 94 4f 13 	call	0x269e	; 0x269e <LCD_DataWrite>
}
    2bb6:	df 91       	pop	r29
    2bb8:	cf 91       	pop	r28
    2bba:	08 95       	ret

00002bbc <UART_Init>:


		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t v_baudRate_u32)
{
    2bbc:	cf 93       	push	r28
    2bbe:	df 93       	push	r29
    2bc0:	00 d0       	rcall	.+0      	; 0x2bc2 <UART_Init+0x6>
    2bc2:	00 d0       	rcall	.+0      	; 0x2bc4 <UART_Init+0x8>
    2bc4:	cd b7       	in	r28, 0x3d	; 61
    2bc6:	de b7       	in	r29, 0x3e	; 62
    2bc8:	69 83       	std	Y+1, r22	; 0x01
    2bca:	7a 83       	std	Y+2, r23	; 0x02
    2bcc:	8b 83       	std	Y+3, r24	; 0x03
    2bce:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    2bd0:	8a e2       	ldi	r24, 0x2A	; 42
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	28 e1       	ldi	r18, 0x18	; 24
    2bd6:	fc 01       	movw	r30, r24
    2bd8:	20 83       	st	Z, r18
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
    2bda:	80 e4       	ldi	r24, 0x40	; 64
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	26 e8       	ldi	r18, 0x86	; 134
    2be0:	fc 01       	movw	r30, r24
    2be2:	20 83       	st	Z, r18
	UCSRA= 0x00;                                   // Clear the UASRT status register
    2be4:	8b e2       	ldi	r24, 0x2B	; 43
    2be6:	90 e0       	ldi	r25, 0x00	; 0
    2be8:	fc 01       	movw	r30, r24
    2bea:	10 82       	st	Z, r1
	UART_SetBaudRate(v_baudRate_u32);
    2bec:	89 81       	ldd	r24, Y+1	; 0x01
    2bee:	9a 81       	ldd	r25, Y+2	; 0x02
    2bf0:	ab 81       	ldd	r26, Y+3	; 0x03
    2bf2:	bc 81       	ldd	r27, Y+4	; 0x04
    2bf4:	bc 01       	movw	r22, r24
    2bf6:	cd 01       	movw	r24, r26
    2bf8:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <UART_SetBaudRate>
}
    2bfc:	0f 90       	pop	r0
    2bfe:	0f 90       	pop	r0
    2c00:	0f 90       	pop	r0
    2c02:	0f 90       	pop	r0
    2c04:	df 91       	pop	r29
    2c06:	cf 91       	pop	r28
    2c08:	08 95       	ret

00002c0a <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t v_baudRate_u32)
{
    2c0a:	ef 92       	push	r14
    2c0c:	ff 92       	push	r15
    2c0e:	0f 93       	push	r16
    2c10:	1f 93       	push	r17
    2c12:	cf 93       	push	r28
    2c14:	df 93       	push	r29
    2c16:	cd b7       	in	r28, 0x3d	; 61
    2c18:	de b7       	in	r29, 0x3e	; 62
    2c1a:	2a 97       	sbiw	r28, 0x0a	; 10
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	f8 94       	cli
    2c20:	de bf       	out	0x3e, r29	; 62
    2c22:	0f be       	out	0x3f, r0	; 63
    2c24:	cd bf       	out	0x3d, r28	; 61
    2c26:	6b 83       	std	Y+3, r22	; 0x03
    2c28:	7c 83       	std	Y+4, r23	; 0x04
    2c2a:	8d 83       	std	Y+5, r24	; 0x05
    2c2c:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t RegValue;

	if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
    2c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c30:	9c 81       	ldd	r25, Y+4	; 0x04
    2c32:	ad 81       	ldd	r26, Y+5	; 0x05
    2c34:	be 81       	ldd	r27, Y+6	; 0x06
    2c36:	80 36       	cpi	r24, 0x60	; 96
    2c38:	29 e0       	ldi	r18, 0x09	; 9
    2c3a:	92 07       	cpc	r25, r18
    2c3c:	a1 05       	cpc	r26, r1
    2c3e:	b1 05       	cpc	r27, r1
    2c40:	08 f4       	brcc	.+2      	; 0x2c44 <UART_SetBaudRate+0x3a>
    2c42:	47 c0       	rjmp	.+142    	; 0x2cd2 <UART_SetBaudRate+0xc8>
    2c44:	8b 81       	ldd	r24, Y+3	; 0x03
    2c46:	9c 81       	ldd	r25, Y+4	; 0x04
    2c48:	ad 81       	ldd	r26, Y+5	; 0x05
    2c4a:	be 81       	ldd	r27, Y+6	; 0x06
    2c4c:	81 30       	cpi	r24, 0x01	; 1
    2c4e:	e2 ec       	ldi	r30, 0xC2	; 194
    2c50:	9e 07       	cpc	r25, r30
    2c52:	e1 e0       	ldi	r30, 0x01	; 1
    2c54:	ae 07       	cpc	r26, r30
    2c56:	b1 05       	cpc	r27, r1
    2c58:	e0 f5       	brcc	.+120    	; 0x2cd2 <UART_SetBaudRate+0xc8>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
    2c5a:	2b 81       	ldd	r18, Y+3	; 0x03
    2c5c:	3c 81       	ldd	r19, Y+4	; 0x04
    2c5e:	4d 81       	ldd	r20, Y+5	; 0x05
    2c60:	5e 81       	ldd	r21, Y+6	; 0x06
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	dc 01       	movw	r26, r24
    2c68:	82 1b       	sub	r24, r18
    2c6a:	93 0b       	sbc	r25, r19
    2c6c:	a4 0b       	sbc	r26, r20
    2c6e:	b5 0b       	sbc	r27, r21
    2c70:	88 0f       	add	r24, r24
    2c72:	99 1f       	adc	r25, r25
    2c74:	aa 1f       	adc	r26, r26
    2c76:	bb 1f       	adc	r27, r27
    2c78:	88 0f       	add	r24, r24
    2c7a:	99 1f       	adc	r25, r25
    2c7c:	aa 1f       	adc	r26, r26
    2c7e:	bb 1f       	adc	r27, r27
    2c80:	88 0f       	add	r24, r24
    2c82:	99 1f       	adc	r25, r25
    2c84:	aa 1f       	adc	r26, r26
    2c86:	bb 1f       	adc	r27, r27
    2c88:	7c 01       	movw	r14, r24
    2c8a:	8d 01       	movw	r16, r26
    2c8c:	f6 e9       	ldi	r31, 0x96	; 150
    2c8e:	ff 1a       	sub	r15, r31
    2c90:	07 4e       	sbci	r16, 0xE7	; 231
    2c92:	1f 4f       	sbci	r17, 0xFF	; 255
    2c94:	8b 81       	ldd	r24, Y+3	; 0x03
    2c96:	9c 81       	ldd	r25, Y+4	; 0x04
    2c98:	ad 81       	ldd	r26, Y+5	; 0x05
    2c9a:	be 81       	ldd	r27, Y+6	; 0x06
    2c9c:	88 0f       	add	r24, r24
    2c9e:	99 1f       	adc	r25, r25
    2ca0:	aa 1f       	adc	r26, r26
    2ca2:	bb 1f       	adc	r27, r27
    2ca4:	88 0f       	add	r24, r24
    2ca6:	99 1f       	adc	r25, r25
    2ca8:	aa 1f       	adc	r26, r26
    2caa:	bb 1f       	adc	r27, r27
    2cac:	88 0f       	add	r24, r24
    2cae:	99 1f       	adc	r25, r25
    2cb0:	aa 1f       	adc	r26, r26
    2cb2:	bb 1f       	adc	r27, r27
    2cb4:	88 0f       	add	r24, r24
    2cb6:	99 1f       	adc	r25, r25
    2cb8:	aa 1f       	adc	r26, r26
    2cba:	bb 1f       	adc	r27, r27
    2cbc:	9c 01       	movw	r18, r24
    2cbe:	ad 01       	movw	r20, r26
    2cc0:	c8 01       	movw	r24, r16
    2cc2:	b7 01       	movw	r22, r14
    2cc4:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    2cc8:	da 01       	movw	r26, r20
    2cca:	c9 01       	movw	r24, r18
    2ccc:	9a 83       	std	Y+2, r25	; 0x02
    2cce:	89 83       	std	Y+1, r24	; 0x01
    2cd0:	04 c0       	rjmp	.+8      	; 0x2cda <UART_SetBaudRate+0xd0>
	}
	else
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
    2cd2:	89 e0       	ldi	r24, 0x09	; 9
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	9a 83       	std	Y+2, r25	; 0x02
    2cd8:	89 83       	std	Y+1, r24	; 0x01
	}

	UBRRL = util_ExtractByte0to8(RegValue);
    2cda:	89 e2       	ldi	r24, 0x29	; 41
    2cdc:	90 e0       	ldi	r25, 0x00	; 0
    2cde:	29 81       	ldd	r18, Y+1	; 0x01
    2ce0:	fc 01       	movw	r30, r24
    2ce2:	20 83       	st	Z, r18
	UBRRH = util_ExtractByte8to16(RegValue);
    2ce4:	80 e4       	ldi	r24, 0x40	; 64
    2ce6:	90 e0       	ldi	r25, 0x00	; 0
    2ce8:	29 81       	ldd	r18, Y+1	; 0x01
    2cea:	3a 81       	ldd	r19, Y+2	; 0x02
    2cec:	23 2f       	mov	r18, r19
    2cee:	33 27       	eor	r19, r19
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	20 83       	st	Z, r18
}
    2cf4:	2a 96       	adiw	r28, 0x0a	; 10
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	f8 94       	cli
    2cfa:	de bf       	out	0x3e, r29	; 62
    2cfc:	0f be       	out	0x3f, r0	; 63
    2cfe:	cd bf       	out	0x3d, r28	; 61
    2d00:	df 91       	pop	r29
    2d02:	cf 91       	pop	r28
    2d04:	1f 91       	pop	r17
    2d06:	0f 91       	pop	r16
    2d08:	ff 90       	pop	r15
    2d0a:	ef 90       	pop	r14
    2d0c:	08 95       	ret

00002d0e <UART_RxChar>:

 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar(void)
{
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	cd b7       	in	r28, 0x3d	; 61
    2d14:	de b7       	in	r29, 0x3e	; 62
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
    2d16:	00 00       	nop
    2d18:	8b e2       	ldi	r24, 0x2B	; 43
    2d1a:	90 e0       	ldi	r25, 0x00	; 0
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	80 81       	ld	r24, Z
    2d20:	88 23       	and	r24, r24
    2d22:	d4 f7       	brge	.-12     	; 0x2d18 <UART_RxChar+0xa>
	return(UDR);                          // return the received char
    2d24:	8c e2       	ldi	r24, 0x2C	; 44
    2d26:	90 e0       	ldi	r25, 0x00	; 0
    2d28:	fc 01       	movw	r30, r24
    2d2a:	80 81       	ld	r24, Z
}
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	08 95       	ret

00002d32 <UART_TxChar>:
 * Return value	: none.

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char v_uartData_u8)
{
    2d32:	cf 93       	push	r28
    2d34:	df 93       	push	r29
    2d36:	1f 92       	push	r1
    2d38:	cd b7       	in	r28, 0x3d	; 61
    2d3a:	de b7       	in	r29, 0x3e	; 62
    2d3c:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
    2d3e:	00 00       	nop
    2d40:	8b e2       	ldi	r24, 0x2B	; 43
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	fc 01       	movw	r30, r24
    2d46:	80 81       	ld	r24, Z
    2d48:	88 2f       	mov	r24, r24
    2d4a:	90 e0       	ldi	r25, 0x00	; 0
    2d4c:	80 72       	andi	r24, 0x20	; 32
    2d4e:	99 27       	eor	r25, r25
    2d50:	00 97       	sbiw	r24, 0x00	; 0
    2d52:	b1 f3       	breq	.-20     	; 0x2d40 <UART_TxChar+0xe>
	UDR =v_uartData_u8;                              // Load the data to be transmitted
    2d54:	8c e2       	ldi	r24, 0x2C	; 44
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	29 81       	ldd	r18, Y+1	; 0x01
    2d5a:	fc 01       	movw	r30, r24
    2d5c:	20 83       	st	Z, r18
}
    2d5e:	0f 90       	pop	r0
    2d60:	df 91       	pop	r29
    2d62:	cf 91       	pop	r28
    2d64:	08 95       	ret

00002d66 <UART_TxString>:
               1.The ptr_string points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
    2d66:	cf 93       	push	r28
    2d68:	df 93       	push	r29
    2d6a:	00 d0       	rcall	.+0      	; 0x2d6c <UART_TxString+0x6>
    2d6c:	cd b7       	in	r28, 0x3d	; 61
    2d6e:	de b7       	in	r29, 0x3e	; 62
    2d70:	9a 83       	std	Y+2, r25	; 0x02
    2d72:	89 83       	std	Y+1, r24	; 0x01
	while(*ptr_string)
    2d74:	0b c0       	rjmp	.+22     	; 0x2d8c <UART_TxString+0x26>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7a:	9c 01       	movw	r18, r24
    2d7c:	2f 5f       	subi	r18, 0xFF	; 255
    2d7e:	3f 4f       	sbci	r19, 0xFF	; 255
    2d80:	3a 83       	std	Y+2, r19	; 0x02
    2d82:	29 83       	std	Y+1, r18	; 0x01
    2d84:	fc 01       	movw	r30, r24
    2d86:	80 81       	ld	r24, Z
    2d88:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
	while(*ptr_string)
    2d8c:	89 81       	ldd	r24, Y+1	; 0x01
    2d8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d90:	fc 01       	movw	r30, r24
    2d92:	80 81       	ld	r24, Z
    2d94:	88 23       	and	r24, r24
    2d96:	79 f7       	brne	.-34     	; 0x2d76 <UART_TxString+0x10>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
}
    2d98:	0f 90       	pop	r0
    2d9a:	0f 90       	pop	r0
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	08 95       	ret

00002da2 <UART_RxString>:
    if not required then comment UART_TxChar(ch) in the code.
  2.BackSlash is not taken care.
***************************************************************************************************/
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
    2da2:	cf 93       	push	r28
    2da4:	df 93       	push	r29
    2da6:	00 d0       	rcall	.+0      	; 0x2da8 <UART_RxString+0x6>
    2da8:	00 d0       	rcall	.+0      	; 0x2daa <UART_RxString+0x8>
    2daa:	00 d0       	rcall	.+0      	; 0x2dac <UART_RxString+0xa>
    2dac:	cd b7       	in	r28, 0x3d	; 61
    2dae:	de b7       	in	r29, 0x3e	; 62
    2db0:	9e 83       	std	Y+6, r25	; 0x06
    2db2:	8d 83       	std	Y+5, r24	; 0x05
	char ch;
    uint8_t len = 0;
    2db4:	19 82       	std	Y+1, r1	; 0x01
	for(int clk=0;clk<1000;clk++)
    2db6:	1b 82       	std	Y+3, r1	; 0x03
    2db8:	1a 82       	std	Y+2, r1	; 0x02
    2dba:	2f c0       	rjmp	.+94     	; 0x2e1a <UART_RxString+0x78>
	{
		ch=UART_RxChar();    //Receive a char
    2dbc:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <UART_RxChar>
    2dc0:	8c 83       	std	Y+4, r24	; 0x04
		//UART_TxChar(ch);     //Echo back the received char

		if((ch=='\r') || (ch=='\n')) //read till enter key is pressed
    2dc2:	8c 81       	ldd	r24, Y+4	; 0x04
    2dc4:	8d 30       	cpi	r24, 0x0D	; 13
    2dc6:	19 f0       	breq	.+6      	; 0x2dce <UART_RxString+0x2c>
    2dc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2dca:	8a 30       	cpi	r24, 0x0A	; 10
    2dcc:	51 f4       	brne	.+20     	; 0x2de2 <UART_RxString+0x40>
		{						     //once enter key is pressed null terminate the string
			ptr_string[len]=0;           //and break the loop
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	88 2f       	mov	r24, r24
    2dd2:	90 e0       	ldi	r25, 0x00	; 0
    2dd4:	2d 81       	ldd	r18, Y+5	; 0x05
    2dd6:	3e 81       	ldd	r19, Y+6	; 0x06
    2dd8:	82 0f       	add	r24, r18
    2dda:	93 1f       	adc	r25, r19
    2ddc:	fc 01       	movw	r30, r24
    2dde:	10 82       	st	Z, r1
			break;				  
    2de0:	22 c0       	rjmp	.+68     	; 0x2e26 <UART_RxString+0x84>
		}
        else if((ch=='\b') && (len!=0))
    2de2:	8c 81       	ldd	r24, Y+4	; 0x04
    2de4:	88 30       	cpi	r24, 0x08	; 8
    2de6:	39 f4       	brne	.+14     	; 0x2df6 <UART_RxString+0x54>
    2de8:	89 81       	ldd	r24, Y+1	; 0x01
    2dea:	88 23       	and	r24, r24
    2dec:	21 f0       	breq	.+8      	; 0x2df6 <UART_RxString+0x54>
        {
		    len--;    //If backspace is pressed then decrement the index to remove the old char
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	81 50       	subi	r24, 0x01	; 1
    2df2:	89 83       	std	Y+1, r24	; 0x01
    2df4:	0d c0       	rjmp	.+26     	; 0x2e10 <UART_RxString+0x6e>
        }
        else
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
    2df6:	89 81       	ldd	r24, Y+1	; 0x01
    2df8:	88 2f       	mov	r24, r24
    2dfa:	90 e0       	ldi	r25, 0x00	; 0
    2dfc:	2d 81       	ldd	r18, Y+5	; 0x05
    2dfe:	3e 81       	ldd	r19, Y+6	; 0x06
    2e00:	82 0f       	add	r24, r18
    2e02:	93 1f       	adc	r25, r19
    2e04:	2c 81       	ldd	r18, Y+4	; 0x04
    2e06:	fc 01       	movw	r30, r24
    2e08:	20 83       	st	Z, r18
            len++;
    2e0a:	89 81       	ldd	r24, Y+1	; 0x01
    2e0c:	8f 5f       	subi	r24, 0xFF	; 255
    2e0e:	89 83       	std	Y+1, r24	; 0x01
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
	char ch;
    uint8_t len = 0;
	for(int clk=0;clk<1000;clk++)
    2e10:	8a 81       	ldd	r24, Y+2	; 0x02
    2e12:	9b 81       	ldd	r25, Y+3	; 0x03
    2e14:	01 96       	adiw	r24, 0x01	; 1
    2e16:	9b 83       	std	Y+3, r25	; 0x03
    2e18:	8a 83       	std	Y+2, r24	; 0x02
    2e1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e1e:	88 3e       	cpi	r24, 0xE8	; 232
    2e20:	f3 e0       	ldi	r31, 0x03	; 3
    2e22:	9f 07       	cpc	r25, r31
    2e24:	5c f2       	brlt	.-106    	; 0x2dbc <UART_RxString+0x1a>
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
            len++;
        }
	}
  return len;   
    2e26:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e28:	26 96       	adiw	r28, 0x06	; 6
    2e2a:	0f b6       	in	r0, 0x3f	; 63
    2e2c:	f8 94       	cli
    2e2e:	de bf       	out	0x3e, r29	; 62
    2e30:	0f be       	out	0x3f, r0	; 63
    2e32:	cd bf       	out	0x3d, r28	; 61
    2e34:	df 91       	pop	r29
    2e36:	cf 91       	pop	r28
    2e38:	08 95       	ret

00002e3a <UART_TxNumber>:
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
{
    2e3a:	ff 92       	push	r15
    2e3c:	0f 93       	push	r16
    2e3e:	1f 93       	push	r17
    2e40:	cf 93       	push	r28
    2e42:	df 93       	push	r29
    2e44:	cd b7       	in	r28, 0x3d	; 61
    2e46:	de b7       	in	r29, 0x3e	; 62
    2e48:	69 97       	sbiw	r28, 0x19	; 25
    2e4a:	0f b6       	in	r0, 0x3f	; 63
    2e4c:	f8 94       	cli
    2e4e:	de bf       	out	0x3e, r29	; 62
    2e50:	0f be       	out	0x3f, r0	; 63
    2e52:	cd bf       	out	0x3d, r28	; 61
    2e54:	8c 87       	std	Y+12, r24	; 0x0c
    2e56:	4d 87       	std	Y+13, r20	; 0x0d
    2e58:	5e 87       	std	Y+14, r21	; 0x0e
    2e5a:	6f 87       	std	Y+15, r22	; 0x0f
    2e5c:	78 8b       	std	Y+16, r23	; 0x10
    2e5e:	29 8b       	std	Y+17, r18	; 0x11
    uint8_t i=0,a[10];
    2e60:	19 82       	std	Y+1, r1	; 0x01

    if(C_BINARY_U8 == v_numericSystem_u8)
    2e62:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e64:	82 30       	cpi	r24, 0x02	; 2
    2e66:	69 f5       	brne	.+90     	; 0x2ec2 <UART_TxNumber+0x88>
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    2e68:	28 c0       	rjmp	.+80     	; 0x2eba <UART_TxNumber+0x80>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
    2e6a:	89 89       	ldd	r24, Y+17	; 0x11
    2e6c:	88 2f       	mov	r24, r24
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	9c 01       	movw	r18, r24
    2e72:	21 50       	subi	r18, 0x01	; 1
    2e74:	31 09       	sbc	r19, r1
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	02 c0       	rjmp	.+4      	; 0x2e80 <UART_TxNumber+0x46>
    2e7c:	88 0f       	add	r24, r24
    2e7e:	99 1f       	adc	r25, r25
    2e80:	2a 95       	dec	r18
    2e82:	e2 f7       	brpl	.-8      	; 0x2e7c <UART_TxNumber+0x42>
    2e84:	9c 01       	movw	r18, r24
    2e86:	44 27       	eor	r20, r20
    2e88:	37 fd       	sbrc	r19, 7
    2e8a:	40 95       	com	r20
    2e8c:	54 2f       	mov	r21, r20
    2e8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e90:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e92:	af 85       	ldd	r26, Y+15	; 0x0f
    2e94:	b8 89       	ldd	r27, Y+16	; 0x10
    2e96:	82 23       	and	r24, r18
    2e98:	93 23       	and	r25, r19
    2e9a:	a4 23       	and	r26, r20
    2e9c:	b5 23       	and	r27, r21
    2e9e:	21 e0       	ldi	r18, 0x01	; 1
    2ea0:	00 97       	sbiw	r24, 0x00	; 0
    2ea2:	a1 05       	cpc	r26, r1
    2ea4:	b1 05       	cpc	r27, r1
    2ea6:	09 f4       	brne	.+2      	; 0x2eaa <UART_TxNumber+0x70>
    2ea8:	20 e0       	ldi	r18, 0x00	; 0
    2eaa:	29 83       	std	Y+1, r18	; 0x01
            UART_TxChar(util_Dec2Ascii(i));
    2eac:	89 81       	ldd	r24, Y+1	; 0x01
    2eae:	80 5d       	subi	r24, 0xD0	; 208
    2eb0:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
            v_numOfDigitsToTransmit_u8--;
    2eb4:	89 89       	ldd	r24, Y+17	; 0x11
    2eb6:	81 50       	subi	r24, 0x01	; 1
    2eb8:	89 8b       	std	Y+17, r24	; 0x11
{
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    2eba:	89 89       	ldd	r24, Y+17	; 0x11
    2ebc:	88 23       	and	r24, r24
    2ebe:	a9 f6       	brne	.-86     	; 0x2e6a <UART_TxNumber+0x30>
    2ec0:	9e c0       	rjmp	.+316    	; 0x2ffe <UART_TxNumber+0x1c4>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
            UART_TxChar(util_Dec2Ascii(i));
            v_numOfDigitsToTransmit_u8--;
        }    
    }     
    else if(v_number_u32==0)
    2ec2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ec4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ec6:	af 85       	ldd	r26, Y+15	; 0x0f
    2ec8:	b8 89       	ldd	r27, Y+16	; 0x10
    2eca:	00 97       	sbiw	r24, 0x00	; 0
    2ecc:	a1 05       	cpc	r26, r1
    2ece:	b1 05       	cpc	r27, r1
    2ed0:	89 f4       	brne	.+34     	; 0x2ef4 <UART_TxNumber+0xba>
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    2ed2:	19 82       	std	Y+1, r1	; 0x01
    2ed4:	06 c0       	rjmp	.+12     	; 0x2ee2 <UART_TxNumber+0xa8>
            UART_TxChar('0');
    2ed6:	80 e3       	ldi	r24, 0x30	; 48
    2ed8:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
        }    
    }     
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    2edc:	89 81       	ldd	r24, Y+1	; 0x01
    2ede:	8f 5f       	subi	r24, 0xFF	; 255
    2ee0:	89 83       	std	Y+1, r24	; 0x01
    2ee2:	99 81       	ldd	r25, Y+1	; 0x01
    2ee4:	89 89       	ldd	r24, Y+17	; 0x11
    2ee6:	98 17       	cp	r25, r24
    2ee8:	08 f0       	brcs	.+2      	; 0x2eec <UART_TxNumber+0xb2>
    2eea:	89 c0       	rjmp	.+274    	; 0x2ffe <UART_TxNumber+0x1c4>
    2eec:	89 81       	ldd	r24, Y+1	; 0x01
    2eee:	8a 30       	cpi	r24, 0x0A	; 10
    2ef0:	90 f3       	brcs	.-28     	; 0x2ed6 <UART_TxNumber+0x9c>
    2ef2:	85 c0       	rjmp	.+266    	; 0x2ffe <UART_TxNumber+0x1c4>
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    2ef4:	19 82       	std	Y+1, r1	; 0x01
    2ef6:	4f c0       	rjmp	.+158    	; 0x2f96 <UART_TxNumber+0x15c>
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToTransmit_u8 */
            if(v_number_u32!=0)
    2ef8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2efa:	9e 85       	ldd	r25, Y+14	; 0x0e
    2efc:	af 85       	ldd	r26, Y+15	; 0x0f
    2efe:	b8 89       	ldd	r27, Y+16	; 0x10
    2f00:	00 97       	sbiw	r24, 0x00	; 0
    2f02:	a1 05       	cpc	r26, r1
    2f04:	b1 05       	cpc	r27, r1
    2f06:	a1 f1       	breq	.+104    	; 0x2f70 <UART_TxNumber+0x136>
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    2f08:	89 81       	ldd	r24, Y+1	; 0x01
    2f0a:	08 2f       	mov	r16, r24
    2f0c:	10 e0       	ldi	r17, 0x00	; 0
    2f0e:	fd 84       	ldd	r15, Y+13	; 0x0d
    2f10:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f12:	28 2f       	mov	r18, r24
    2f14:	30 e0       	ldi	r19, 0x00	; 0
    2f16:	40 e0       	ldi	r20, 0x00	; 0
    2f18:	50 e0       	ldi	r21, 0x00	; 0
    2f1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f1e:	af 85       	ldd	r26, Y+15	; 0x0f
    2f20:	b8 89       	ldd	r27, Y+16	; 0x10
    2f22:	bc 01       	movw	r22, r24
    2f24:	cd 01       	movw	r24, r26
    2f26:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    2f2a:	da 01       	movw	r26, r20
    2f2c:	c9 01       	movw	r24, r18
    2f2e:	98 2f       	mov	r25, r24
    2f30:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f32:	98 9f       	mul	r25, r24
    2f34:	80 2d       	mov	r24, r0
    2f36:	11 24       	eor	r1, r1
    2f38:	2f 2d       	mov	r18, r15
    2f3a:	28 1b       	sub	r18, r24
    2f3c:	ce 01       	movw	r24, r28
    2f3e:	02 96       	adiw	r24, 0x02	; 2
    2f40:	80 0f       	add	r24, r16
    2f42:	91 1f       	adc	r25, r17
    2f44:	fc 01       	movw	r30, r24
    2f46:	20 83       	st	Z, r18
                v_number_u32=v_number_u32/v_numericSystem_u8;
    2f48:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f4a:	28 2f       	mov	r18, r24
    2f4c:	30 e0       	ldi	r19, 0x00	; 0
    2f4e:	40 e0       	ldi	r20, 0x00	; 0
    2f50:	50 e0       	ldi	r21, 0x00	; 0
    2f52:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f54:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f56:	af 85       	ldd	r26, Y+15	; 0x0f
    2f58:	b8 89       	ldd	r27, Y+16	; 0x10
    2f5a:	bc 01       	movw	r22, r24
    2f5c:	cd 01       	movw	r24, r26
    2f5e:	0e 94 25 1a 	call	0x344a	; 0x344a <__udivmodsi4>
    2f62:	da 01       	movw	r26, r20
    2f64:	c9 01       	movw	r24, r18
    2f66:	8d 87       	std	Y+13, r24	; 0x0d
    2f68:	9e 87       	std	Y+14, r25	; 0x0e
    2f6a:	af 87       	std	Y+15, r26	; 0x0f
    2f6c:	b8 8b       	std	Y+16, r27	; 0x10
    2f6e:	10 c0       	rjmp	.+32     	; 0x2f90 <UART_TxNumber+0x156>
            }
            else if( (v_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
    2f70:	89 89       	ldd	r24, Y+17	; 0x11
    2f72:	8f 3f       	cpi	r24, 0xFF	; 255
    2f74:	a9 f0       	breq	.+42     	; 0x2fa0 <UART_TxNumber+0x166>
    2f76:	89 89       	ldd	r24, Y+17	; 0x11
    2f78:	8b 30       	cpi	r24, 0x0B	; 11
    2f7a:	90 f4       	brcc	.+36     	; 0x2fa0 <UART_TxNumber+0x166>
            else
            {
                /*In case user expects more digits to be transmitted than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
    2f7c:	89 81       	ldd	r24, Y+1	; 0x01
    2f7e:	88 2f       	mov	r24, r24
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	9e 01       	movw	r18, r28
    2f84:	2e 5f       	subi	r18, 0xFE	; 254
    2f86:	3f 4f       	sbci	r19, 0xFF	; 255
    2f88:	82 0f       	add	r24, r18
    2f8a:	93 1f       	adc	r25, r19
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	10 82       	st	Z, r1
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
    2f92:	8f 5f       	subi	r24, 0xFF	; 255
    2f94:	89 83       	std	Y+1, r24	; 0x01
    2f96:	99 81       	ldd	r25, Y+1	; 0x01
    2f98:	89 89       	ldd	r24, Y+17	; 0x11
    2f9a:	98 17       	cp	r25, r24
    2f9c:	08 f4       	brcc	.+2      	; 0x2fa0 <UART_TxNumber+0x166>
    2f9e:	ac cf       	rjmp	.-168    	; 0x2ef8 <UART_TxNumber+0xbe>
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    2fa0:	2b c0       	rjmp	.+86     	; 0x2ff8 <UART_TxNumber+0x1be>
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(util_Hex2Ascii(a[i-1]));
    2fa2:	89 81       	ldd	r24, Y+1	; 0x01
    2fa4:	88 2f       	mov	r24, r24
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	01 97       	sbiw	r24, 0x01	; 1
    2faa:	9e 01       	movw	r18, r28
    2fac:	2e 5f       	subi	r18, 0xFE	; 254
    2fae:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb0:	82 0f       	add	r24, r18
    2fb2:	93 1f       	adc	r25, r19
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	80 81       	ld	r24, Z
    2fb8:	8a 30       	cpi	r24, 0x0A	; 10
    2fba:	68 f0       	brcs	.+26     	; 0x2fd6 <UART_TxNumber+0x19c>
    2fbc:	89 81       	ldd	r24, Y+1	; 0x01
    2fbe:	88 2f       	mov	r24, r24
    2fc0:	90 e0       	ldi	r25, 0x00	; 0
    2fc2:	01 97       	sbiw	r24, 0x01	; 1
    2fc4:	9e 01       	movw	r18, r28
    2fc6:	2e 5f       	subi	r18, 0xFE	; 254
    2fc8:	3f 4f       	sbci	r19, 0xFF	; 255
    2fca:	82 0f       	add	r24, r18
    2fcc:	93 1f       	adc	r25, r19
    2fce:	fc 01       	movw	r30, r24
    2fd0:	80 81       	ld	r24, Z
    2fd2:	89 5c       	subi	r24, 0xC9	; 201
    2fd4:	0c c0       	rjmp	.+24     	; 0x2fee <UART_TxNumber+0x1b4>
    2fd6:	89 81       	ldd	r24, Y+1	; 0x01
    2fd8:	88 2f       	mov	r24, r24
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	01 97       	sbiw	r24, 0x01	; 1
    2fde:	9e 01       	movw	r18, r28
    2fe0:	2e 5f       	subi	r18, 0xFE	; 254
    2fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe4:	82 0f       	add	r24, r18
    2fe6:	93 1f       	adc	r25, r19
    2fe8:	fc 01       	movw	r30, r24
    2fea:	80 81       	ld	r24, Z
    2fec:	80 5d       	subi	r24, 0xD0	; 208
    2fee:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
            i--;
    2ff2:	89 81       	ldd	r24, Y+1	; 0x01
    2ff4:	81 50       	subi	r24, 0x01	; 1
    2ff6:	89 83       	std	Y+1, r24	; 0x01
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    2ff8:	89 81       	ldd	r24, Y+1	; 0x01
    2ffa:	88 23       	and	r24, r24
    2ffc:	91 f6       	brne	.-92     	; 0x2fa2 <UART_TxNumber+0x168>
            i--;
        }
    }


}
    2ffe:	69 96       	adiw	r28, 0x19	; 25
    3000:	0f b6       	in	r0, 0x3f	; 63
    3002:	f8 94       	cli
    3004:	de bf       	out	0x3e, r29	; 62
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	cd bf       	out	0x3d, r28	; 61
    300a:	df 91       	pop	r29
    300c:	cf 91       	pop	r28
    300e:	1f 91       	pop	r17
    3010:	0f 91       	pop	r16
    3012:	ff 90       	pop	r15
    3014:	08 95       	ret

00003016 <UART_TxFloatNumber>:
         Float will be disabled by default as it takes huge controller resources
	     It can be enabled by changing value of Enable_UART_TxFloatNumber to 1 in uart.h	 
 ***************************************************************************************************/
#if (Enable_UART_TxFloatNumber==1)
void UART_TxFloatNumber(float v_floatNumber_f32)
{
    3016:	cf 93       	push	r28
    3018:	df 93       	push	r29
    301a:	cd b7       	in	r28, 0x3d	; 61
    301c:	de b7       	in	r29, 0x3e	; 62
    301e:	28 97       	sbiw	r28, 0x08	; 8
    3020:	0f b6       	in	r0, 0x3f	; 63
    3022:	f8 94       	cli
    3024:	de bf       	out	0x3e, r29	; 62
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	cd bf       	out	0x3d, r28	; 61
    302a:	6d 83       	std	Y+5, r22	; 0x05
    302c:	7e 83       	std	Y+6, r23	; 0x06
    302e:	8f 83       	std	Y+7, r24	; 0x07
    3030:	98 87       	std	Y+8, r25	; 0x08
      1.Type cast the number to int to get the integer part.
	  2.transmit the extracted integer part followed by a decimal point(.).
	  3.Later the integer part is made zero by subtracting with the extracted integer value.
	  4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

	v_tempNumber_u32 = (uint32_t) v_floatNumber_f32;
    3032:	6d 81       	ldd	r22, Y+5	; 0x05
    3034:	7e 81       	ldd	r23, Y+6	; 0x06
    3036:	8f 81       	ldd	r24, Y+7	; 0x07
    3038:	98 85       	ldd	r25, Y+8	; 0x08
    303a:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
    303e:	dc 01       	movw	r26, r24
    3040:	cb 01       	movw	r24, r22
    3042:	89 83       	std	Y+1, r24	; 0x01
    3044:	9a 83       	std	Y+2, r25	; 0x02
    3046:	ab 83       	std	Y+3, r26	; 0x03
    3048:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	9a 81       	ldd	r25, Y+2	; 0x02
    304e:	ab 81       	ldd	r26, Y+3	; 0x03
    3050:	bc 81       	ldd	r27, Y+4	; 0x04
    3052:	2f ef       	ldi	r18, 0xFF	; 255
    3054:	ac 01       	movw	r20, r24
    3056:	bd 01       	movw	r22, r26
    3058:	8a e0       	ldi	r24, 0x0A	; 10
    305a:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>

	UART_TxChar('.');
    305e:	8e e2       	ldi	r24, 0x2E	; 46
    3060:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>

	v_floatNumber_f32 = v_floatNumber_f32 - v_tempNumber_u32;
    3064:	69 81       	ldd	r22, Y+1	; 0x01
    3066:	7a 81       	ldd	r23, Y+2	; 0x02
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	9c 81       	ldd	r25, Y+4	; 0x04
    306c:	0e 94 4a 1b 	call	0x3694	; 0x3694 <__floatunsisf>
    3070:	dc 01       	movw	r26, r24
    3072:	cb 01       	movw	r24, r22
    3074:	9c 01       	movw	r18, r24
    3076:	ad 01       	movw	r20, r26
    3078:	6d 81       	ldd	r22, Y+5	; 0x05
    307a:	7e 81       	ldd	r23, Y+6	; 0x06
    307c:	8f 81       	ldd	r24, Y+7	; 0x07
    307e:	98 85       	ldd	r25, Y+8	; 0x08
    3080:	0e 94 4d 1a 	call	0x349a	; 0x349a <__subsf3>
    3084:	dc 01       	movw	r26, r24
    3086:	cb 01       	movw	r24, r22
    3088:	8d 83       	std	Y+5, r24	; 0x05
    308a:	9e 83       	std	Y+6, r25	; 0x06
    308c:	af 83       	std	Y+7, r26	; 0x07
    308e:	b8 87       	std	Y+8, r27	; 0x08
	v_tempNumber_u32 = v_floatNumber_f32 * 1000000;
    3090:	20 e0       	ldi	r18, 0x00	; 0
    3092:	34 e2       	ldi	r19, 0x24	; 36
    3094:	44 e7       	ldi	r20, 0x74	; 116
    3096:	59 e4       	ldi	r21, 0x49	; 73
    3098:	6d 81       	ldd	r22, Y+5	; 0x05
    309a:	7e 81       	ldd	r23, Y+6	; 0x06
    309c:	8f 81       	ldd	r24, Y+7	; 0x07
    309e:	98 85       	ldd	r25, Y+8	; 0x08
    30a0:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
    30a4:	dc 01       	movw	r26, r24
    30a6:	cb 01       	movw	r24, r22
    30a8:	bc 01       	movw	r22, r24
    30aa:	cd 01       	movw	r24, r26
    30ac:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
    30b0:	dc 01       	movw	r26, r24
    30b2:	cb 01       	movw	r24, r22
    30b4:	89 83       	std	Y+1, r24	; 0x01
    30b6:	9a 83       	std	Y+2, r25	; 0x02
    30b8:	ab 83       	std	Y+3, r26	; 0x03
    30ba:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	9a 81       	ldd	r25, Y+2	; 0x02
    30c0:	ab 81       	ldd	r26, Y+3	; 0x03
    30c2:	bc 81       	ldd	r27, Y+4	; 0x04
    30c4:	2f ef       	ldi	r18, 0xFF	; 255
    30c6:	ac 01       	movw	r20, r24
    30c8:	bd 01       	movw	r22, r26
    30ca:	8a e0       	ldi	r24, 0x0A	; 10
    30cc:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
}
    30d0:	28 96       	adiw	r28, 0x08	; 8
    30d2:	0f b6       	in	r0, 0x3f	; 63
    30d4:	f8 94       	cli
    30d6:	de bf       	out	0x3e, r29	; 62
    30d8:	0f be       	out	0x3f, r0	; 63
    30da:	cd bf       	out	0x3d, r28	; 61
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	08 95       	ret

000030e2 <UART_Printf>:
        uint8_t v_Num_u8;
		UART_Printf("num1:%u",(uint16_t)v_Num_u8); 		 
***************************************************************************************************/
#if ( Enable_UART_Printf   == 1 ) 
void UART_Printf(const char *argList, ...)
{
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	68 97       	sbiw	r28, 0x18	; 24
    30ec:	0f b6       	in	r0, 0x3f	; 63
    30ee:	f8 94       	cli
    30f0:	de bf       	out	0x3e, r29	; 62
    30f2:	0f be       	out	0x3f, r0	; 63
    30f4:	cd bf       	out	0x3d, r28	; 61
#if (Enable_UART_TxFloatNumber==1)
	double v_floatNum_f32;
#endif	


	va_start(argp, argList);
    30f6:	ce 01       	movw	r24, r28
    30f8:	4f 96       	adiw	r24, 0x1f	; 31
    30fa:	98 8f       	std	Y+24, r25	; 0x18
    30fc:	8f 8b       	std	Y+23, r24	; 0x17

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    30fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3100:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3102:	9a 83       	std	Y+2, r25	; 0x02
    3104:	89 83       	std	Y+1, r24	; 0x01
    3106:	91 c1       	rjmp	.+802    	; 0x342a <UART_Printf+0x348>
	{

		ch= *ptr;
    3108:	89 81       	ldd	r24, Y+1	; 0x01
    310a:	9a 81       	ldd	r25, Y+2	; 0x02
    310c:	fc 01       	movw	r30, r24
    310e:	80 81       	ld	r24, Z
    3110:	89 87       	std	Y+9, r24	; 0x09
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    3112:	89 85       	ldd	r24, Y+9	; 0x09
    3114:	85 32       	cpi	r24, 0x25	; 37
    3116:	09 f0       	breq	.+2      	; 0x311a <UART_Printf+0x38>
    3118:	80 c1       	rjmp	.+768    	; 0x341a <UART_Printf+0x338>
		{
		    ptr++;
    311a:	89 81       	ldd	r24, Y+1	; 0x01
    311c:	9a 81       	ldd	r25, Y+2	; 0x02
    311e:	01 96       	adiw	r24, 0x01	; 1
    3120:	9a 83       	std	Y+2, r25	; 0x02
    3122:	89 83       	std	Y+1, r24	; 0x01
		    ch = *ptr;
    3124:	89 81       	ldd	r24, Y+1	; 0x01
    3126:	9a 81       	ldd	r25, Y+2	; 0x02
    3128:	fc 01       	movw	r30, r24
    312a:	80 81       	ld	r24, Z
    312c:	89 87       	std	Y+9, r24	; 0x09
		   if((ch>=0x30) && (ch<=0x39))
    312e:	89 85       	ldd	r24, Y+9	; 0x09
    3130:	80 33       	cpi	r24, 0x30	; 48
    3132:	00 f1       	brcs	.+64     	; 0x3174 <UART_Printf+0x92>
    3134:	89 85       	ldd	r24, Y+9	; 0x09
    3136:	8a 33       	cpi	r24, 0x3A	; 58
    3138:	e8 f4       	brcc	.+58     	; 0x3174 <UART_Printf+0x92>
			{
			   v_numOfDigitsToTransmit_u8 = 0;
    313a:	1a 86       	std	Y+10, r1	; 0x0a
			   while((ch>=0x30) && (ch<=0x39))
    313c:	14 c0       	rjmp	.+40     	; 0x3166 <UART_Printf+0x84>
			    {
				   v_numOfDigitsToTransmit_u8 = (v_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
    313e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3140:	88 0f       	add	r24, r24
    3142:	98 2f       	mov	r25, r24
    3144:	99 0f       	add	r25, r25
    3146:	99 0f       	add	r25, r25
    3148:	98 0f       	add	r25, r24
    314a:	89 85       	ldd	r24, Y+9	; 0x09
    314c:	89 0f       	add	r24, r25
    314e:	80 53       	subi	r24, 0x30	; 48
    3150:	8a 87       	std	Y+10, r24	; 0x0a
				   ptr++;
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	9a 81       	ldd	r25, Y+2	; 0x02
    3156:	01 96       	adiw	r24, 0x01	; 1
    3158:	9a 83       	std	Y+2, r25	; 0x02
    315a:	89 83       	std	Y+1, r24	; 0x01
				   ch = *ptr;
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	9a 81       	ldd	r25, Y+2	; 0x02
    3160:	fc 01       	movw	r30, r24
    3162:	80 81       	ld	r24, Z
    3164:	89 87       	std	Y+9, r24	; 0x09
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   v_numOfDigitsToTransmit_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
    3166:	89 85       	ldd	r24, Y+9	; 0x09
    3168:	80 33       	cpi	r24, 0x30	; 48
    316a:	18 f0       	brcs	.+6      	; 0x3172 <UART_Printf+0x90>
    316c:	89 85       	ldd	r24, Y+9	; 0x09
    316e:	8a 33       	cpi	r24, 0x3A	; 58
    3170:	30 f3       	brcs	.-52     	; 0x313e <UART_Printf+0x5c>
		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
		{
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
    3172:	02 c0       	rjmp	.+4      	; 0x3178 <UART_Printf+0x96>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    3174:	8f ef       	ldi	r24, 0xFF	; 255
    3176:	8a 87       	std	Y+10, r24	; 0x0a
			}				


			switch(ch)       /* Decode the type of the argument */
    3178:	89 85       	ldd	r24, Y+9	; 0x09
    317a:	88 2f       	mov	r24, r24
    317c:	90 e0       	ldi	r25, 0x00	; 0
    317e:	aa 27       	eor	r26, r26
    3180:	97 fd       	sbrc	r25, 7
    3182:	a0 95       	com	r26
    3184:	ba 2f       	mov	r27, r26
    3186:	45 e2       	ldi	r20, 0x25	; 37
    3188:	50 e0       	ldi	r21, 0x00	; 0
    318a:	23 e5       	ldi	r18, 0x53	; 83
    318c:	30 e0       	ldi	r19, 0x00	; 0
    318e:	84 1b       	sub	r24, r20
    3190:	95 0b       	sbc	r25, r21
    3192:	28 17       	cp	r18, r24
    3194:	39 07       	cpc	r19, r25
    3196:	08 f4       	brcc	.+2      	; 0x319a <UART_Printf+0xb8>
    3198:	43 c1       	rjmp	.+646    	; 0x3420 <UART_Printf+0x33e>
    319a:	8b 5c       	subi	r24, 0xCB	; 203
    319c:	9e 4f       	sbci	r25, 0xFE	; 254
    319e:	fc 01       	movw	r30, r24
    31a0:	0c 94 47 1a 	jmp	0x348e	; 0x348e <__tablejump2__>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    31a4:	8f 89       	ldd	r24, Y+23	; 0x17
    31a6:	98 8d       	ldd	r25, Y+24	; 0x18
    31a8:	9c 01       	movw	r18, r24
    31aa:	2e 5f       	subi	r18, 0xFE	; 254
    31ac:	3f 4f       	sbci	r19, 0xFF	; 255
    31ae:	38 8f       	std	Y+24, r19	; 0x18
    31b0:	2f 8b       	std	Y+23, r18	; 0x17
    31b2:	fc 01       	movw	r30, r24
    31b4:	80 81       	ld	r24, Z
    31b6:	91 81       	ldd	r25, Z+1	; 0x01
    31b8:	89 87       	std	Y+9, r24	; 0x09
				UART_TxChar(ch);
    31ba:	89 85       	ldd	r24, Y+9	; 0x09
    31bc:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
				break;
    31c0:	2b c1       	rjmp	.+598    	; 0x3418 <UART_Printf+0x336>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, sint16_t);
    31c2:	8f 89       	ldd	r24, Y+23	; 0x17
    31c4:	98 8d       	ldd	r25, Y+24	; 0x18
    31c6:	9c 01       	movw	r18, r24
    31c8:	2e 5f       	subi	r18, 0xFE	; 254
    31ca:	3f 4f       	sbci	r19, 0xFF	; 255
    31cc:	38 8f       	std	Y+24, r19	; 0x18
    31ce:	2f 8b       	std	Y+23, r18	; 0x17
    31d0:	fc 01       	movw	r30, r24
    31d2:	80 81       	ld	r24, Z
    31d4:	91 81       	ldd	r25, Z+1	; 0x01
    31d6:	9c 83       	std	Y+4, r25	; 0x04
    31d8:	8b 83       	std	Y+3, r24	; 0x03
				if(v_num_s16<0)
    31da:	8b 81       	ldd	r24, Y+3	; 0x03
    31dc:	9c 81       	ldd	r25, Y+4	; 0x04
    31de:	99 23       	and	r25, r25
    31e0:	54 f4       	brge	.+20     	; 0x31f6 <UART_Printf+0x114>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   v_num_s16 = -v_num_s16;
    31e2:	8b 81       	ldd	r24, Y+3	; 0x03
    31e4:	9c 81       	ldd	r25, Y+4	; 0x04
    31e6:	91 95       	neg	r25
    31e8:	81 95       	neg	r24
    31ea:	91 09       	sbc	r25, r1
    31ec:	9c 83       	std	Y+4, r25	; 0x04
    31ee:	8b 83       	std	Y+3, r24	; 0x03
				   UART_TxChar('-');
    31f0:	8d e2       	ldi	r24, 0x2D	; 45
    31f2:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
    31f6:	8b 81       	ldd	r24, Y+3	; 0x03
    31f8:	9c 81       	ldd	r25, Y+4	; 0x04
    31fa:	aa 27       	eor	r26, r26
    31fc:	97 fd       	sbrc	r25, 7
    31fe:	a0 95       	com	r26
    3200:	ba 2f       	mov	r27, r26
    3202:	2a 85       	ldd	r18, Y+10	; 0x0a
    3204:	ac 01       	movw	r20, r24
    3206:	bd 01       	movw	r22, r26
    3208:	8a e0       	ldi	r24, 0x0A	; 10
    320a:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    320e:	04 c1       	rjmp	.+520    	; 0x3418 <UART_Printf+0x336>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);				
    3210:	8f 89       	ldd	r24, Y+23	; 0x17
    3212:	98 8d       	ldd	r25, Y+24	; 0x18
    3214:	9c 01       	movw	r18, r24
    3216:	2c 5f       	subi	r18, 0xFC	; 252
    3218:	3f 4f       	sbci	r19, 0xFF	; 255
    321a:	38 8f       	std	Y+24, r19	; 0x18
    321c:	2f 8b       	std	Y+23, r18	; 0x17
    321e:	fc 01       	movw	r30, r24
    3220:	80 81       	ld	r24, Z
    3222:	91 81       	ldd	r25, Z+1	; 0x01
    3224:	a2 81       	ldd	r26, Z+2	; 0x02
    3226:	b3 81       	ldd	r27, Z+3	; 0x03
    3228:	8d 83       	std	Y+5, r24	; 0x05
    322a:	9e 83       	std	Y+6, r25	; 0x06
    322c:	af 83       	std	Y+7, r26	; 0x07
    322e:	b8 87       	std	Y+8, r27	; 0x08
				if(v_num_s32<0)
    3230:	8d 81       	ldd	r24, Y+5	; 0x05
    3232:	9e 81       	ldd	r25, Y+6	; 0x06
    3234:	af 81       	ldd	r26, Y+7	; 0x07
    3236:	b8 85       	ldd	r27, Y+8	; 0x08
    3238:	bb 23       	and	r27, r27
    323a:	94 f4       	brge	.+36     	; 0x3260 <UART_Printf+0x17e>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   v_num_s32 = -v_num_s32;
    323c:	8d 81       	ldd	r24, Y+5	; 0x05
    323e:	9e 81       	ldd	r25, Y+6	; 0x06
    3240:	af 81       	ldd	r26, Y+7	; 0x07
    3242:	b8 85       	ldd	r27, Y+8	; 0x08
    3244:	b0 95       	com	r27
    3246:	a0 95       	com	r26
    3248:	90 95       	com	r25
    324a:	81 95       	neg	r24
    324c:	9f 4f       	sbci	r25, 0xFF	; 255
    324e:	af 4f       	sbci	r26, 0xFF	; 255
    3250:	bf 4f       	sbci	r27, 0xFF	; 255
    3252:	8d 83       	std	Y+5, r24	; 0x05
    3254:	9e 83       	std	Y+6, r25	; 0x06
    3256:	af 83       	std	Y+7, r26	; 0x07
    3258:	b8 87       	std	Y+8, r27	; 0x08
				   UART_TxChar('-');
    325a:	8d e2       	ldi	r24, 0x2D	; 45
    325c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToTransmit_u8);			
    3260:	8d 81       	ldd	r24, Y+5	; 0x05
    3262:	9e 81       	ldd	r25, Y+6	; 0x06
    3264:	af 81       	ldd	r26, Y+7	; 0x07
    3266:	b8 85       	ldd	r27, Y+8	; 0x08
    3268:	2a 85       	ldd	r18, Y+10	; 0x0a
    326a:	ac 01       	movw	r20, r24
    326c:	bd 01       	movw	r22, r26
    326e:	8a e0       	ldi	r24, 0x0A	; 10
    3270:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;	
    3274:	d1 c0       	rjmp	.+418    	; 0x3418 <UART_Printf+0x336>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, uint16_t);			
    3276:	8f 89       	ldd	r24, Y+23	; 0x17
    3278:	98 8d       	ldd	r25, Y+24	; 0x18
    327a:	9c 01       	movw	r18, r24
    327c:	2e 5f       	subi	r18, 0xFE	; 254
    327e:	3f 4f       	sbci	r19, 0xFF	; 255
    3280:	38 8f       	std	Y+24, r19	; 0x18
    3282:	2f 8b       	std	Y+23, r18	; 0x17
    3284:	fc 01       	movw	r30, r24
    3286:	80 81       	ld	r24, Z
    3288:	91 81       	ldd	r25, Z+1	; 0x01
    328a:	9c 87       	std	Y+12, r25	; 0x0c
    328c:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);				
    328e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3290:	9c 85       	ldd	r25, Y+12	; 0x0c
    3292:	cc 01       	movw	r24, r24
    3294:	a0 e0       	ldi	r26, 0x00	; 0
    3296:	b0 e0       	ldi	r27, 0x00	; 0
    3298:	2a 85       	ldd	r18, Y+10	; 0x0a
    329a:	ac 01       	movw	r20, r24
    329c:	bd 01       	movw	r22, r26
    329e:	8a e0       	ldi	r24, 0x0A	; 10
    32a0:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    32a4:	b9 c0       	rjmp	.+370    	; 0x3418 <UART_Printf+0x336>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);			
    32a6:	8f 89       	ldd	r24, Y+23	; 0x17
    32a8:	98 8d       	ldd	r25, Y+24	; 0x18
    32aa:	9c 01       	movw	r18, r24
    32ac:	2c 5f       	subi	r18, 0xFC	; 252
    32ae:	3f 4f       	sbci	r19, 0xFF	; 255
    32b0:	38 8f       	std	Y+24, r19	; 0x18
    32b2:	2f 8b       	std	Y+23, r18	; 0x17
    32b4:	fc 01       	movw	r30, r24
    32b6:	80 81       	ld	r24, Z
    32b8:	91 81       	ldd	r25, Z+1	; 0x01
    32ba:	a2 81       	ldd	r26, Z+2	; 0x02
    32bc:	b3 81       	ldd	r27, Z+3	; 0x03
    32be:	8d 87       	std	Y+13, r24	; 0x0d
    32c0:	9e 87       	std	Y+14, r25	; 0x0e
    32c2:	af 87       	std	Y+15, r26	; 0x0f
    32c4:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    32c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    32c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    32ca:	af 85       	ldd	r26, Y+15	; 0x0f
    32cc:	b8 89       	ldd	r27, Y+16	; 0x10
    32ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    32d0:	ac 01       	movw	r20, r24
    32d2:	bd 01       	movw	r22, r26
    32d4:	8a e0       	ldi	r24, 0x0A	; 10
    32d6:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;			
    32da:	9e c0       	rjmp	.+316    	; 0x3418 <UART_Printf+0x336>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, uint16_t);				
    32dc:	8f 89       	ldd	r24, Y+23	; 0x17
    32de:	98 8d       	ldd	r25, Y+24	; 0x18
    32e0:	9c 01       	movw	r18, r24
    32e2:	2e 5f       	subi	r18, 0xFE	; 254
    32e4:	3f 4f       	sbci	r19, 0xFF	; 255
    32e6:	38 8f       	std	Y+24, r19	; 0x18
    32e8:	2f 8b       	std	Y+23, r18	; 0x17
    32ea:	fc 01       	movw	r30, r24
    32ec:	80 81       	ld	r24, Z
    32ee:	91 81       	ldd	r25, Z+1	; 0x01
    32f0:	9c 87       	std	Y+12, r25	; 0x0c
    32f2:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    32f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    32f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    32f8:	cc 01       	movw	r24, r24
    32fa:	a0 e0       	ldi	r26, 0x00	; 0
    32fc:	b0 e0       	ldi	r27, 0x00	; 0
    32fe:	2a 85       	ldd	r18, Y+10	; 0x0a
    3300:	ac 01       	movw	r20, r24
    3302:	bd 01       	movw	r22, r26
    3304:	80 e1       	ldi	r24, 0x10	; 16
    3306:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    330a:	86 c0       	rjmp	.+268    	; 0x3418 <UART_Printf+0x336>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);						
    330c:	8f 89       	ldd	r24, Y+23	; 0x17
    330e:	98 8d       	ldd	r25, Y+24	; 0x18
    3310:	9c 01       	movw	r18, r24
    3312:	2c 5f       	subi	r18, 0xFC	; 252
    3314:	3f 4f       	sbci	r19, 0xFF	; 255
    3316:	38 8f       	std	Y+24, r19	; 0x18
    3318:	2f 8b       	std	Y+23, r18	; 0x17
    331a:	fc 01       	movw	r30, r24
    331c:	80 81       	ld	r24, Z
    331e:	91 81       	ldd	r25, Z+1	; 0x01
    3320:	a2 81       	ldd	r26, Z+2	; 0x02
    3322:	b3 81       	ldd	r27, Z+3	; 0x03
    3324:	8d 87       	std	Y+13, r24	; 0x0d
    3326:	9e 87       	std	Y+14, r25	; 0x0e
    3328:	af 87       	std	Y+15, r26	; 0x0f
    332a:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    332c:	8d 85       	ldd	r24, Y+13	; 0x0d
    332e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3330:	af 85       	ldd	r26, Y+15	; 0x0f
    3332:	b8 89       	ldd	r27, Y+16	; 0x10
    3334:	2a 85       	ldd	r18, Y+10	; 0x0a
    3336:	ac 01       	movw	r20, r24
    3338:	bd 01       	movw	r22, r26
    333a:	80 e1       	ldi	r24, 0x10	; 16
    333c:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    3340:	6b c0       	rjmp	.+214    	; 0x3418 <UART_Printf+0x336>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, uint16_t);		
    3342:	8f 89       	ldd	r24, Y+23	; 0x17
    3344:	98 8d       	ldd	r25, Y+24	; 0x18
    3346:	9c 01       	movw	r18, r24
    3348:	2e 5f       	subi	r18, 0xFE	; 254
    334a:	3f 4f       	sbci	r19, 0xFF	; 255
    334c:	38 8f       	std	Y+24, r19	; 0x18
    334e:	2f 8b       	std	Y+23, r18	; 0x17
    3350:	fc 01       	movw	r30, r24
    3352:	80 81       	ld	r24, Z
    3354:	91 81       	ldd	r25, Z+1	; 0x01
    3356:	9c 87       	std	Y+12, r25	; 0x0c
    3358:	8b 87       	std	Y+11, r24	; 0x0b
				
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    335a:	8a 85       	ldd	r24, Y+10	; 0x0a
    335c:	8f 3f       	cpi	r24, 0xFF	; 255
    335e:	11 f4       	brne	.+4      	; 0x3364 <UART_Printf+0x282>
				   v_numOfDigitsToTransmit_u8 = 16;
    3360:	80 e1       	ldi	r24, 0x10	; 16
    3362:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    3364:	8b 85       	ldd	r24, Y+11	; 0x0b
    3366:	9c 85       	ldd	r25, Y+12	; 0x0c
    3368:	cc 01       	movw	r24, r24
    336a:	a0 e0       	ldi	r26, 0x00	; 0
    336c:	b0 e0       	ldi	r27, 0x00	; 0
    336e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3370:	ac 01       	movw	r20, r24
    3372:	bd 01       	movw	r22, r26
    3374:	82 e0       	ldi	r24, 0x02	; 2
    3376:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    337a:	4e c0       	rjmp	.+156    	; 0x3418 <UART_Printf+0x336>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);			
    337c:	8f 89       	ldd	r24, Y+23	; 0x17
    337e:	98 8d       	ldd	r25, Y+24	; 0x18
    3380:	9c 01       	movw	r18, r24
    3382:	2c 5f       	subi	r18, 0xFC	; 252
    3384:	3f 4f       	sbci	r19, 0xFF	; 255
    3386:	38 8f       	std	Y+24, r19	; 0x18
    3388:	2f 8b       	std	Y+23, r18	; 0x17
    338a:	fc 01       	movw	r30, r24
    338c:	80 81       	ld	r24, Z
    338e:	91 81       	ldd	r25, Z+1	; 0x01
    3390:	a2 81       	ldd	r26, Z+2	; 0x02
    3392:	b3 81       	ldd	r27, Z+3	; 0x03
    3394:	8d 87       	std	Y+13, r24	; 0x0d
    3396:	9e 87       	std	Y+14, r25	; 0x0e
    3398:	af 87       	std	Y+15, r26	; 0x0f
    339a:	b8 8b       	std	Y+16, r27	; 0x10
                
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    339c:	8a 85       	ldd	r24, Y+10	; 0x0a
    339e:	8f 3f       	cpi	r24, 0xFF	; 255
    33a0:	11 f4       	brne	.+4      	; 0x33a6 <UART_Printf+0x2c4>
				   v_numOfDigitsToTransmit_u8 = 32;		
    33a2:	80 e2       	ldi	r24, 0x20	; 32
    33a4:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    33a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    33a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    33aa:	af 85       	ldd	r26, Y+15	; 0x0f
    33ac:	b8 89       	ldd	r27, Y+16	; 0x10
    33ae:	2a 85       	ldd	r18, Y+10	; 0x0a
    33b0:	ac 01       	movw	r20, r24
    33b2:	bd 01       	movw	r22, r26
    33b4:	82 e0       	ldi	r24, 0x02	; 2
    33b6:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <UART_TxNumber>
				break;
    33ba:	2e c0       	rjmp	.+92     	; 0x3418 <UART_Printf+0x336>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_UART_TxFloatNumber==1)				
				v_floatNum_f32 = va_arg(argp, double);				
    33bc:	8f 89       	ldd	r24, Y+23	; 0x17
    33be:	98 8d       	ldd	r25, Y+24	; 0x18
    33c0:	9c 01       	movw	r18, r24
    33c2:	2c 5f       	subi	r18, 0xFC	; 252
    33c4:	3f 4f       	sbci	r19, 0xFF	; 255
    33c6:	38 8f       	std	Y+24, r19	; 0x18
    33c8:	2f 8b       	std	Y+23, r18	; 0x17
    33ca:	fc 01       	movw	r30, r24
    33cc:	80 81       	ld	r24, Z
    33ce:	91 81       	ldd	r25, Z+1	; 0x01
    33d0:	a2 81       	ldd	r26, Z+2	; 0x02
    33d2:	b3 81       	ldd	r27, Z+3	; 0x03
    33d4:	89 8b       	std	Y+17, r24	; 0x11
    33d6:	9a 8b       	std	Y+18, r25	; 0x12
    33d8:	ab 8b       	std	Y+19, r26	; 0x13
    33da:	bc 8b       	std	Y+20, r27	; 0x14
				UART_TxFloatNumber(v_floatNum_f32);
    33dc:	89 89       	ldd	r24, Y+17	; 0x11
    33de:	9a 89       	ldd	r25, Y+18	; 0x12
    33e0:	ab 89       	ldd	r26, Y+19	; 0x13
    33e2:	bc 89       	ldd	r27, Y+20	; 0x14
    33e4:	bc 01       	movw	r22, r24
    33e6:	cd 01       	movw	r24, r26
    33e8:	0e 94 0b 18 	call	0x3016	; 0x3016 <UART_TxFloatNumber>
#endif            
				break;                
    33ec:	15 c0       	rjmp	.+42     	; 0x3418 <UART_Printf+0x336>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
    33ee:	8f 89       	ldd	r24, Y+23	; 0x17
    33f0:	98 8d       	ldd	r25, Y+24	; 0x18
    33f2:	9c 01       	movw	r18, r24
    33f4:	2e 5f       	subi	r18, 0xFE	; 254
    33f6:	3f 4f       	sbci	r19, 0xFF	; 255
    33f8:	38 8f       	std	Y+24, r19	; 0x18
    33fa:	2f 8b       	std	Y+23, r18	; 0x17
    33fc:	fc 01       	movw	r30, r24
    33fe:	80 81       	ld	r24, Z
    3400:	91 81       	ldd	r25, Z+1	; 0x01
    3402:	9e 8b       	std	Y+22, r25	; 0x16
    3404:	8d 8b       	std	Y+21, r24	; 0x15
				UART_TxString(str);			
    3406:	8d 89       	ldd	r24, Y+21	; 0x15
    3408:	9e 89       	ldd	r25, Y+22	; 0x16
    340a:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <UART_TxString>
				break;
    340e:	04 c0       	rjmp	.+8      	; 0x3418 <UART_Printf+0x336>

			case '%':
				UART_TxChar('%');
    3410:	85 e2       	ldi	r24, 0x25	; 37
    3412:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>
				break;
    3416:	00 00       	nop
    3418:	03 c0       	rjmp	.+6      	; 0x3420 <UART_Printf+0x33e>
			}
		}
		else
		{
			/* As '%' is not detected transmit the char passed */
			UART_TxChar(ch);
    341a:	89 85       	ldd	r24, Y+9	; 0x09
    341c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <UART_TxChar>


	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    3420:	89 81       	ldd	r24, Y+1	; 0x01
    3422:	9a 81       	ldd	r25, Y+2	; 0x02
    3424:	01 96       	adiw	r24, 0x01	; 1
    3426:	9a 83       	std	Y+2, r25	; 0x02
    3428:	89 83       	std	Y+1, r24	; 0x01
    342a:	89 81       	ldd	r24, Y+1	; 0x01
    342c:	9a 81       	ldd	r25, Y+2	; 0x02
    342e:	fc 01       	movw	r30, r24
    3430:	80 81       	ld	r24, Z
    3432:	88 23       	and	r24, r24
    3434:	09 f0       	breq	.+2      	; 0x3438 <UART_Printf+0x356>
    3436:	68 ce       	rjmp	.-816    	; 0x3108 <UART_Printf+0x26>
			UART_TxChar(ch);
		}
	}

	va_end(argp);
}
    3438:	68 96       	adiw	r28, 0x18	; 24
    343a:	0f b6       	in	r0, 0x3f	; 63
    343c:	f8 94       	cli
    343e:	de bf       	out	0x3e, r29	; 62
    3440:	0f be       	out	0x3f, r0	; 63
    3442:	cd bf       	out	0x3d, r28	; 61
    3444:	df 91       	pop	r29
    3446:	cf 91       	pop	r28
    3448:	08 95       	ret

0000344a <__udivmodsi4>:
    344a:	a1 e2       	ldi	r26, 0x21	; 33
    344c:	1a 2e       	mov	r1, r26
    344e:	aa 1b       	sub	r26, r26
    3450:	bb 1b       	sub	r27, r27
    3452:	fd 01       	movw	r30, r26
    3454:	0d c0       	rjmp	.+26     	; 0x3470 <__udivmodsi4_ep>

00003456 <__udivmodsi4_loop>:
    3456:	aa 1f       	adc	r26, r26
    3458:	bb 1f       	adc	r27, r27
    345a:	ee 1f       	adc	r30, r30
    345c:	ff 1f       	adc	r31, r31
    345e:	a2 17       	cp	r26, r18
    3460:	b3 07       	cpc	r27, r19
    3462:	e4 07       	cpc	r30, r20
    3464:	f5 07       	cpc	r31, r21
    3466:	20 f0       	brcs	.+8      	; 0x3470 <__udivmodsi4_ep>
    3468:	a2 1b       	sub	r26, r18
    346a:	b3 0b       	sbc	r27, r19
    346c:	e4 0b       	sbc	r30, r20
    346e:	f5 0b       	sbc	r31, r21

00003470 <__udivmodsi4_ep>:
    3470:	66 1f       	adc	r22, r22
    3472:	77 1f       	adc	r23, r23
    3474:	88 1f       	adc	r24, r24
    3476:	99 1f       	adc	r25, r25
    3478:	1a 94       	dec	r1
    347a:	69 f7       	brne	.-38     	; 0x3456 <__udivmodsi4_loop>
    347c:	60 95       	com	r22
    347e:	70 95       	com	r23
    3480:	80 95       	com	r24
    3482:	90 95       	com	r25
    3484:	9b 01       	movw	r18, r22
    3486:	ac 01       	movw	r20, r24
    3488:	bd 01       	movw	r22, r26
    348a:	cf 01       	movw	r24, r30
    348c:	08 95       	ret

0000348e <__tablejump2__>:
    348e:	ee 0f       	add	r30, r30
    3490:	ff 1f       	adc	r31, r31

00003492 <__tablejump__>:
    3492:	05 90       	lpm	r0, Z+
    3494:	f4 91       	lpm	r31, Z
    3496:	e0 2d       	mov	r30, r0
    3498:	09 94       	ijmp

0000349a <__subsf3>:
    349a:	50 58       	subi	r21, 0x80	; 128

0000349c <__addsf3>:
    349c:	bb 27       	eor	r27, r27
    349e:	aa 27       	eor	r26, r26
    34a0:	0e d0       	rcall	.+28     	; 0x34be <__addsf3x>
    34a2:	70 c1       	rjmp	.+736    	; 0x3784 <__fp_round>
    34a4:	61 d1       	rcall	.+706    	; 0x3768 <__fp_pscA>
    34a6:	30 f0       	brcs	.+12     	; 0x34b4 <__addsf3+0x18>
    34a8:	66 d1       	rcall	.+716    	; 0x3776 <__fp_pscB>
    34aa:	20 f0       	brcs	.+8      	; 0x34b4 <__addsf3+0x18>
    34ac:	31 f4       	brne	.+12     	; 0x34ba <__addsf3+0x1e>
    34ae:	9f 3f       	cpi	r25, 0xFF	; 255
    34b0:	11 f4       	brne	.+4      	; 0x34b6 <__addsf3+0x1a>
    34b2:	1e f4       	brtc	.+6      	; 0x34ba <__addsf3+0x1e>
    34b4:	56 c1       	rjmp	.+684    	; 0x3762 <__fp_nan>
    34b6:	0e f4       	brtc	.+2      	; 0x34ba <__addsf3+0x1e>
    34b8:	e0 95       	com	r30
    34ba:	e7 fb       	bst	r30, 7
    34bc:	4c c1       	rjmp	.+664    	; 0x3756 <__fp_inf>

000034be <__addsf3x>:
    34be:	e9 2f       	mov	r30, r25
    34c0:	72 d1       	rcall	.+740    	; 0x37a6 <__fp_split3>
    34c2:	80 f3       	brcs	.-32     	; 0x34a4 <__addsf3+0x8>
    34c4:	ba 17       	cp	r27, r26
    34c6:	62 07       	cpc	r22, r18
    34c8:	73 07       	cpc	r23, r19
    34ca:	84 07       	cpc	r24, r20
    34cc:	95 07       	cpc	r25, r21
    34ce:	18 f0       	brcs	.+6      	; 0x34d6 <__addsf3x+0x18>
    34d0:	71 f4       	brne	.+28     	; 0x34ee <__addsf3x+0x30>
    34d2:	9e f5       	brtc	.+102    	; 0x353a <__addsf3x+0x7c>
    34d4:	8a c1       	rjmp	.+788    	; 0x37ea <__fp_zero>
    34d6:	0e f4       	brtc	.+2      	; 0x34da <__addsf3x+0x1c>
    34d8:	e0 95       	com	r30
    34da:	0b 2e       	mov	r0, r27
    34dc:	ba 2f       	mov	r27, r26
    34de:	a0 2d       	mov	r26, r0
    34e0:	0b 01       	movw	r0, r22
    34e2:	b9 01       	movw	r22, r18
    34e4:	90 01       	movw	r18, r0
    34e6:	0c 01       	movw	r0, r24
    34e8:	ca 01       	movw	r24, r20
    34ea:	a0 01       	movw	r20, r0
    34ec:	11 24       	eor	r1, r1
    34ee:	ff 27       	eor	r31, r31
    34f0:	59 1b       	sub	r21, r25
    34f2:	99 f0       	breq	.+38     	; 0x351a <__addsf3x+0x5c>
    34f4:	59 3f       	cpi	r21, 0xF9	; 249
    34f6:	50 f4       	brcc	.+20     	; 0x350c <__addsf3x+0x4e>
    34f8:	50 3e       	cpi	r21, 0xE0	; 224
    34fa:	68 f1       	brcs	.+90     	; 0x3556 <__addsf3x+0x98>
    34fc:	1a 16       	cp	r1, r26
    34fe:	f0 40       	sbci	r31, 0x00	; 0
    3500:	a2 2f       	mov	r26, r18
    3502:	23 2f       	mov	r18, r19
    3504:	34 2f       	mov	r19, r20
    3506:	44 27       	eor	r20, r20
    3508:	58 5f       	subi	r21, 0xF8	; 248
    350a:	f3 cf       	rjmp	.-26     	; 0x34f2 <__addsf3x+0x34>
    350c:	46 95       	lsr	r20
    350e:	37 95       	ror	r19
    3510:	27 95       	ror	r18
    3512:	a7 95       	ror	r26
    3514:	f0 40       	sbci	r31, 0x00	; 0
    3516:	53 95       	inc	r21
    3518:	c9 f7       	brne	.-14     	; 0x350c <__addsf3x+0x4e>
    351a:	7e f4       	brtc	.+30     	; 0x353a <__addsf3x+0x7c>
    351c:	1f 16       	cp	r1, r31
    351e:	ba 0b       	sbc	r27, r26
    3520:	62 0b       	sbc	r22, r18
    3522:	73 0b       	sbc	r23, r19
    3524:	84 0b       	sbc	r24, r20
    3526:	ba f0       	brmi	.+46     	; 0x3556 <__addsf3x+0x98>
    3528:	91 50       	subi	r25, 0x01	; 1
    352a:	a1 f0       	breq	.+40     	; 0x3554 <__addsf3x+0x96>
    352c:	ff 0f       	add	r31, r31
    352e:	bb 1f       	adc	r27, r27
    3530:	66 1f       	adc	r22, r22
    3532:	77 1f       	adc	r23, r23
    3534:	88 1f       	adc	r24, r24
    3536:	c2 f7       	brpl	.-16     	; 0x3528 <__addsf3x+0x6a>
    3538:	0e c0       	rjmp	.+28     	; 0x3556 <__addsf3x+0x98>
    353a:	ba 0f       	add	r27, r26
    353c:	62 1f       	adc	r22, r18
    353e:	73 1f       	adc	r23, r19
    3540:	84 1f       	adc	r24, r20
    3542:	48 f4       	brcc	.+18     	; 0x3556 <__addsf3x+0x98>
    3544:	87 95       	ror	r24
    3546:	77 95       	ror	r23
    3548:	67 95       	ror	r22
    354a:	b7 95       	ror	r27
    354c:	f7 95       	ror	r31
    354e:	9e 3f       	cpi	r25, 0xFE	; 254
    3550:	08 f0       	brcs	.+2      	; 0x3554 <__addsf3x+0x96>
    3552:	b3 cf       	rjmp	.-154    	; 0x34ba <__addsf3+0x1e>
    3554:	93 95       	inc	r25
    3556:	88 0f       	add	r24, r24
    3558:	08 f0       	brcs	.+2      	; 0x355c <__addsf3x+0x9e>
    355a:	99 27       	eor	r25, r25
    355c:	ee 0f       	add	r30, r30
    355e:	97 95       	ror	r25
    3560:	87 95       	ror	r24
    3562:	08 95       	ret

00003564 <__cmpsf2>:
    3564:	d4 d0       	rcall	.+424    	; 0x370e <__fp_cmp>
    3566:	08 f4       	brcc	.+2      	; 0x356a <__cmpsf2+0x6>
    3568:	81 e0       	ldi	r24, 0x01	; 1
    356a:	08 95       	ret

0000356c <__divsf3>:
    356c:	0c d0       	rcall	.+24     	; 0x3586 <__divsf3x>
    356e:	0a c1       	rjmp	.+532    	; 0x3784 <__fp_round>
    3570:	02 d1       	rcall	.+516    	; 0x3776 <__fp_pscB>
    3572:	40 f0       	brcs	.+16     	; 0x3584 <__divsf3+0x18>
    3574:	f9 d0       	rcall	.+498    	; 0x3768 <__fp_pscA>
    3576:	30 f0       	brcs	.+12     	; 0x3584 <__divsf3+0x18>
    3578:	21 f4       	brne	.+8      	; 0x3582 <__divsf3+0x16>
    357a:	5f 3f       	cpi	r21, 0xFF	; 255
    357c:	19 f0       	breq	.+6      	; 0x3584 <__divsf3+0x18>
    357e:	eb c0       	rjmp	.+470    	; 0x3756 <__fp_inf>
    3580:	51 11       	cpse	r21, r1
    3582:	34 c1       	rjmp	.+616    	; 0x37ec <__fp_szero>
    3584:	ee c0       	rjmp	.+476    	; 0x3762 <__fp_nan>

00003586 <__divsf3x>:
    3586:	0f d1       	rcall	.+542    	; 0x37a6 <__fp_split3>
    3588:	98 f3       	brcs	.-26     	; 0x3570 <__divsf3+0x4>

0000358a <__divsf3_pse>:
    358a:	99 23       	and	r25, r25
    358c:	c9 f3       	breq	.-14     	; 0x3580 <__divsf3+0x14>
    358e:	55 23       	and	r21, r21
    3590:	b1 f3       	breq	.-20     	; 0x357e <__divsf3+0x12>
    3592:	95 1b       	sub	r25, r21
    3594:	55 0b       	sbc	r21, r21
    3596:	bb 27       	eor	r27, r27
    3598:	aa 27       	eor	r26, r26
    359a:	62 17       	cp	r22, r18
    359c:	73 07       	cpc	r23, r19
    359e:	84 07       	cpc	r24, r20
    35a0:	38 f0       	brcs	.+14     	; 0x35b0 <__divsf3_pse+0x26>
    35a2:	9f 5f       	subi	r25, 0xFF	; 255
    35a4:	5f 4f       	sbci	r21, 0xFF	; 255
    35a6:	22 0f       	add	r18, r18
    35a8:	33 1f       	adc	r19, r19
    35aa:	44 1f       	adc	r20, r20
    35ac:	aa 1f       	adc	r26, r26
    35ae:	a9 f3       	breq	.-22     	; 0x359a <__divsf3_pse+0x10>
    35b0:	33 d0       	rcall	.+102    	; 0x3618 <__divsf3_pse+0x8e>
    35b2:	0e 2e       	mov	r0, r30
    35b4:	3a f0       	brmi	.+14     	; 0x35c4 <__divsf3_pse+0x3a>
    35b6:	e0 e8       	ldi	r30, 0x80	; 128
    35b8:	30 d0       	rcall	.+96     	; 0x361a <__divsf3_pse+0x90>
    35ba:	91 50       	subi	r25, 0x01	; 1
    35bc:	50 40       	sbci	r21, 0x00	; 0
    35be:	e6 95       	lsr	r30
    35c0:	00 1c       	adc	r0, r0
    35c2:	ca f7       	brpl	.-14     	; 0x35b6 <__divsf3_pse+0x2c>
    35c4:	29 d0       	rcall	.+82     	; 0x3618 <__divsf3_pse+0x8e>
    35c6:	fe 2f       	mov	r31, r30
    35c8:	27 d0       	rcall	.+78     	; 0x3618 <__divsf3_pse+0x8e>
    35ca:	66 0f       	add	r22, r22
    35cc:	77 1f       	adc	r23, r23
    35ce:	88 1f       	adc	r24, r24
    35d0:	bb 1f       	adc	r27, r27
    35d2:	26 17       	cp	r18, r22
    35d4:	37 07       	cpc	r19, r23
    35d6:	48 07       	cpc	r20, r24
    35d8:	ab 07       	cpc	r26, r27
    35da:	b0 e8       	ldi	r27, 0x80	; 128
    35dc:	09 f0       	breq	.+2      	; 0x35e0 <__divsf3_pse+0x56>
    35de:	bb 0b       	sbc	r27, r27
    35e0:	80 2d       	mov	r24, r0
    35e2:	bf 01       	movw	r22, r30
    35e4:	ff 27       	eor	r31, r31
    35e6:	93 58       	subi	r25, 0x83	; 131
    35e8:	5f 4f       	sbci	r21, 0xFF	; 255
    35ea:	2a f0       	brmi	.+10     	; 0x35f6 <__divsf3_pse+0x6c>
    35ec:	9e 3f       	cpi	r25, 0xFE	; 254
    35ee:	51 05       	cpc	r21, r1
    35f0:	68 f0       	brcs	.+26     	; 0x360c <__divsf3_pse+0x82>
    35f2:	b1 c0       	rjmp	.+354    	; 0x3756 <__fp_inf>
    35f4:	fb c0       	rjmp	.+502    	; 0x37ec <__fp_szero>
    35f6:	5f 3f       	cpi	r21, 0xFF	; 255
    35f8:	ec f3       	brlt	.-6      	; 0x35f4 <__divsf3_pse+0x6a>
    35fa:	98 3e       	cpi	r25, 0xE8	; 232
    35fc:	dc f3       	brlt	.-10     	; 0x35f4 <__divsf3_pse+0x6a>
    35fe:	86 95       	lsr	r24
    3600:	77 95       	ror	r23
    3602:	67 95       	ror	r22
    3604:	b7 95       	ror	r27
    3606:	f7 95       	ror	r31
    3608:	9f 5f       	subi	r25, 0xFF	; 255
    360a:	c9 f7       	brne	.-14     	; 0x35fe <__divsf3_pse+0x74>
    360c:	88 0f       	add	r24, r24
    360e:	91 1d       	adc	r25, r1
    3610:	96 95       	lsr	r25
    3612:	87 95       	ror	r24
    3614:	97 f9       	bld	r25, 7
    3616:	08 95       	ret
    3618:	e1 e0       	ldi	r30, 0x01	; 1
    361a:	66 0f       	add	r22, r22
    361c:	77 1f       	adc	r23, r23
    361e:	88 1f       	adc	r24, r24
    3620:	bb 1f       	adc	r27, r27
    3622:	62 17       	cp	r22, r18
    3624:	73 07       	cpc	r23, r19
    3626:	84 07       	cpc	r24, r20
    3628:	ba 07       	cpc	r27, r26
    362a:	20 f0       	brcs	.+8      	; 0x3634 <__divsf3_pse+0xaa>
    362c:	62 1b       	sub	r22, r18
    362e:	73 0b       	sbc	r23, r19
    3630:	84 0b       	sbc	r24, r20
    3632:	ba 0b       	sbc	r27, r26
    3634:	ee 1f       	adc	r30, r30
    3636:	88 f7       	brcc	.-30     	; 0x361a <__divsf3_pse+0x90>
    3638:	e0 95       	com	r30
    363a:	08 95       	ret

0000363c <__fixunssfsi>:
    363c:	bc d0       	rcall	.+376    	; 0x37b6 <__fp_splitA>
    363e:	88 f0       	brcs	.+34     	; 0x3662 <__fixunssfsi+0x26>
    3640:	9f 57       	subi	r25, 0x7F	; 127
    3642:	90 f0       	brcs	.+36     	; 0x3668 <__fixunssfsi+0x2c>
    3644:	b9 2f       	mov	r27, r25
    3646:	99 27       	eor	r25, r25
    3648:	b7 51       	subi	r27, 0x17	; 23
    364a:	a0 f0       	brcs	.+40     	; 0x3674 <__fixunssfsi+0x38>
    364c:	d1 f0       	breq	.+52     	; 0x3682 <__fixunssfsi+0x46>
    364e:	66 0f       	add	r22, r22
    3650:	77 1f       	adc	r23, r23
    3652:	88 1f       	adc	r24, r24
    3654:	99 1f       	adc	r25, r25
    3656:	1a f0       	brmi	.+6      	; 0x365e <__fixunssfsi+0x22>
    3658:	ba 95       	dec	r27
    365a:	c9 f7       	brne	.-14     	; 0x364e <__fixunssfsi+0x12>
    365c:	12 c0       	rjmp	.+36     	; 0x3682 <__fixunssfsi+0x46>
    365e:	b1 30       	cpi	r27, 0x01	; 1
    3660:	81 f0       	breq	.+32     	; 0x3682 <__fixunssfsi+0x46>
    3662:	c3 d0       	rcall	.+390    	; 0x37ea <__fp_zero>
    3664:	b1 e0       	ldi	r27, 0x01	; 1
    3666:	08 95       	ret
    3668:	c0 c0       	rjmp	.+384    	; 0x37ea <__fp_zero>
    366a:	67 2f       	mov	r22, r23
    366c:	78 2f       	mov	r23, r24
    366e:	88 27       	eor	r24, r24
    3670:	b8 5f       	subi	r27, 0xF8	; 248
    3672:	39 f0       	breq	.+14     	; 0x3682 <__fixunssfsi+0x46>
    3674:	b9 3f       	cpi	r27, 0xF9	; 249
    3676:	cc f3       	brlt	.-14     	; 0x366a <__fixunssfsi+0x2e>
    3678:	86 95       	lsr	r24
    367a:	77 95       	ror	r23
    367c:	67 95       	ror	r22
    367e:	b3 95       	inc	r27
    3680:	d9 f7       	brne	.-10     	; 0x3678 <__fixunssfsi+0x3c>
    3682:	3e f4       	brtc	.+14     	; 0x3692 <__fixunssfsi+0x56>
    3684:	90 95       	com	r25
    3686:	80 95       	com	r24
    3688:	70 95       	com	r23
    368a:	61 95       	neg	r22
    368c:	7f 4f       	sbci	r23, 0xFF	; 255
    368e:	8f 4f       	sbci	r24, 0xFF	; 255
    3690:	9f 4f       	sbci	r25, 0xFF	; 255
    3692:	08 95       	ret

00003694 <__floatunsisf>:
    3694:	e8 94       	clt
    3696:	09 c0       	rjmp	.+18     	; 0x36aa <__floatsisf+0x12>

00003698 <__floatsisf>:
    3698:	97 fb       	bst	r25, 7
    369a:	3e f4       	brtc	.+14     	; 0x36aa <__floatsisf+0x12>
    369c:	90 95       	com	r25
    369e:	80 95       	com	r24
    36a0:	70 95       	com	r23
    36a2:	61 95       	neg	r22
    36a4:	7f 4f       	sbci	r23, 0xFF	; 255
    36a6:	8f 4f       	sbci	r24, 0xFF	; 255
    36a8:	9f 4f       	sbci	r25, 0xFF	; 255
    36aa:	99 23       	and	r25, r25
    36ac:	a9 f0       	breq	.+42     	; 0x36d8 <__floatsisf+0x40>
    36ae:	f9 2f       	mov	r31, r25
    36b0:	96 e9       	ldi	r25, 0x96	; 150
    36b2:	bb 27       	eor	r27, r27
    36b4:	93 95       	inc	r25
    36b6:	f6 95       	lsr	r31
    36b8:	87 95       	ror	r24
    36ba:	77 95       	ror	r23
    36bc:	67 95       	ror	r22
    36be:	b7 95       	ror	r27
    36c0:	f1 11       	cpse	r31, r1
    36c2:	f8 cf       	rjmp	.-16     	; 0x36b4 <__floatsisf+0x1c>
    36c4:	fa f4       	brpl	.+62     	; 0x3704 <__floatsisf+0x6c>
    36c6:	bb 0f       	add	r27, r27
    36c8:	11 f4       	brne	.+4      	; 0x36ce <__floatsisf+0x36>
    36ca:	60 ff       	sbrs	r22, 0
    36cc:	1b c0       	rjmp	.+54     	; 0x3704 <__floatsisf+0x6c>
    36ce:	6f 5f       	subi	r22, 0xFF	; 255
    36d0:	7f 4f       	sbci	r23, 0xFF	; 255
    36d2:	8f 4f       	sbci	r24, 0xFF	; 255
    36d4:	9f 4f       	sbci	r25, 0xFF	; 255
    36d6:	16 c0       	rjmp	.+44     	; 0x3704 <__floatsisf+0x6c>
    36d8:	88 23       	and	r24, r24
    36da:	11 f0       	breq	.+4      	; 0x36e0 <__floatsisf+0x48>
    36dc:	96 e9       	ldi	r25, 0x96	; 150
    36de:	11 c0       	rjmp	.+34     	; 0x3702 <__floatsisf+0x6a>
    36e0:	77 23       	and	r23, r23
    36e2:	21 f0       	breq	.+8      	; 0x36ec <__floatsisf+0x54>
    36e4:	9e e8       	ldi	r25, 0x8E	; 142
    36e6:	87 2f       	mov	r24, r23
    36e8:	76 2f       	mov	r23, r22
    36ea:	05 c0       	rjmp	.+10     	; 0x36f6 <__floatsisf+0x5e>
    36ec:	66 23       	and	r22, r22
    36ee:	71 f0       	breq	.+28     	; 0x370c <__floatsisf+0x74>
    36f0:	96 e8       	ldi	r25, 0x86	; 134
    36f2:	86 2f       	mov	r24, r22
    36f4:	70 e0       	ldi	r23, 0x00	; 0
    36f6:	60 e0       	ldi	r22, 0x00	; 0
    36f8:	2a f0       	brmi	.+10     	; 0x3704 <__floatsisf+0x6c>
    36fa:	9a 95       	dec	r25
    36fc:	66 0f       	add	r22, r22
    36fe:	77 1f       	adc	r23, r23
    3700:	88 1f       	adc	r24, r24
    3702:	da f7       	brpl	.-10     	; 0x36fa <__floatsisf+0x62>
    3704:	88 0f       	add	r24, r24
    3706:	96 95       	lsr	r25
    3708:	87 95       	ror	r24
    370a:	97 f9       	bld	r25, 7
    370c:	08 95       	ret

0000370e <__fp_cmp>:
    370e:	99 0f       	add	r25, r25
    3710:	00 08       	sbc	r0, r0
    3712:	55 0f       	add	r21, r21
    3714:	aa 0b       	sbc	r26, r26
    3716:	e0 e8       	ldi	r30, 0x80	; 128
    3718:	fe ef       	ldi	r31, 0xFE	; 254
    371a:	16 16       	cp	r1, r22
    371c:	17 06       	cpc	r1, r23
    371e:	e8 07       	cpc	r30, r24
    3720:	f9 07       	cpc	r31, r25
    3722:	c0 f0       	brcs	.+48     	; 0x3754 <__fp_cmp+0x46>
    3724:	12 16       	cp	r1, r18
    3726:	13 06       	cpc	r1, r19
    3728:	e4 07       	cpc	r30, r20
    372a:	f5 07       	cpc	r31, r21
    372c:	98 f0       	brcs	.+38     	; 0x3754 <__fp_cmp+0x46>
    372e:	62 1b       	sub	r22, r18
    3730:	73 0b       	sbc	r23, r19
    3732:	84 0b       	sbc	r24, r20
    3734:	95 0b       	sbc	r25, r21
    3736:	39 f4       	brne	.+14     	; 0x3746 <__fp_cmp+0x38>
    3738:	0a 26       	eor	r0, r26
    373a:	61 f0       	breq	.+24     	; 0x3754 <__fp_cmp+0x46>
    373c:	23 2b       	or	r18, r19
    373e:	24 2b       	or	r18, r20
    3740:	25 2b       	or	r18, r21
    3742:	21 f4       	brne	.+8      	; 0x374c <__fp_cmp+0x3e>
    3744:	08 95       	ret
    3746:	0a 26       	eor	r0, r26
    3748:	09 f4       	brne	.+2      	; 0x374c <__fp_cmp+0x3e>
    374a:	a1 40       	sbci	r26, 0x01	; 1
    374c:	a6 95       	lsr	r26
    374e:	8f ef       	ldi	r24, 0xFF	; 255
    3750:	81 1d       	adc	r24, r1
    3752:	81 1d       	adc	r24, r1
    3754:	08 95       	ret

00003756 <__fp_inf>:
    3756:	97 f9       	bld	r25, 7
    3758:	9f 67       	ori	r25, 0x7F	; 127
    375a:	80 e8       	ldi	r24, 0x80	; 128
    375c:	70 e0       	ldi	r23, 0x00	; 0
    375e:	60 e0       	ldi	r22, 0x00	; 0
    3760:	08 95       	ret

00003762 <__fp_nan>:
    3762:	9f ef       	ldi	r25, 0xFF	; 255
    3764:	80 ec       	ldi	r24, 0xC0	; 192
    3766:	08 95       	ret

00003768 <__fp_pscA>:
    3768:	00 24       	eor	r0, r0
    376a:	0a 94       	dec	r0
    376c:	16 16       	cp	r1, r22
    376e:	17 06       	cpc	r1, r23
    3770:	18 06       	cpc	r1, r24
    3772:	09 06       	cpc	r0, r25
    3774:	08 95       	ret

00003776 <__fp_pscB>:
    3776:	00 24       	eor	r0, r0
    3778:	0a 94       	dec	r0
    377a:	12 16       	cp	r1, r18
    377c:	13 06       	cpc	r1, r19
    377e:	14 06       	cpc	r1, r20
    3780:	05 06       	cpc	r0, r21
    3782:	08 95       	ret

00003784 <__fp_round>:
    3784:	09 2e       	mov	r0, r25
    3786:	03 94       	inc	r0
    3788:	00 0c       	add	r0, r0
    378a:	11 f4       	brne	.+4      	; 0x3790 <__fp_round+0xc>
    378c:	88 23       	and	r24, r24
    378e:	52 f0       	brmi	.+20     	; 0x37a4 <__fp_round+0x20>
    3790:	bb 0f       	add	r27, r27
    3792:	40 f4       	brcc	.+16     	; 0x37a4 <__fp_round+0x20>
    3794:	bf 2b       	or	r27, r31
    3796:	11 f4       	brne	.+4      	; 0x379c <__fp_round+0x18>
    3798:	60 ff       	sbrs	r22, 0
    379a:	04 c0       	rjmp	.+8      	; 0x37a4 <__fp_round+0x20>
    379c:	6f 5f       	subi	r22, 0xFF	; 255
    379e:	7f 4f       	sbci	r23, 0xFF	; 255
    37a0:	8f 4f       	sbci	r24, 0xFF	; 255
    37a2:	9f 4f       	sbci	r25, 0xFF	; 255
    37a4:	08 95       	ret

000037a6 <__fp_split3>:
    37a6:	57 fd       	sbrc	r21, 7
    37a8:	90 58       	subi	r25, 0x80	; 128
    37aa:	44 0f       	add	r20, r20
    37ac:	55 1f       	adc	r21, r21
    37ae:	59 f0       	breq	.+22     	; 0x37c6 <__fp_splitA+0x10>
    37b0:	5f 3f       	cpi	r21, 0xFF	; 255
    37b2:	71 f0       	breq	.+28     	; 0x37d0 <__fp_splitA+0x1a>
    37b4:	47 95       	ror	r20

000037b6 <__fp_splitA>:
    37b6:	88 0f       	add	r24, r24
    37b8:	97 fb       	bst	r25, 7
    37ba:	99 1f       	adc	r25, r25
    37bc:	61 f0       	breq	.+24     	; 0x37d6 <__fp_splitA+0x20>
    37be:	9f 3f       	cpi	r25, 0xFF	; 255
    37c0:	79 f0       	breq	.+30     	; 0x37e0 <__fp_splitA+0x2a>
    37c2:	87 95       	ror	r24
    37c4:	08 95       	ret
    37c6:	12 16       	cp	r1, r18
    37c8:	13 06       	cpc	r1, r19
    37ca:	14 06       	cpc	r1, r20
    37cc:	55 1f       	adc	r21, r21
    37ce:	f2 cf       	rjmp	.-28     	; 0x37b4 <__fp_split3+0xe>
    37d0:	46 95       	lsr	r20
    37d2:	f1 df       	rcall	.-30     	; 0x37b6 <__fp_splitA>
    37d4:	08 c0       	rjmp	.+16     	; 0x37e6 <__fp_splitA+0x30>
    37d6:	16 16       	cp	r1, r22
    37d8:	17 06       	cpc	r1, r23
    37da:	18 06       	cpc	r1, r24
    37dc:	99 1f       	adc	r25, r25
    37de:	f1 cf       	rjmp	.-30     	; 0x37c2 <__fp_splitA+0xc>
    37e0:	86 95       	lsr	r24
    37e2:	71 05       	cpc	r23, r1
    37e4:	61 05       	cpc	r22, r1
    37e6:	08 94       	sec
    37e8:	08 95       	ret

000037ea <__fp_zero>:
    37ea:	e8 94       	clt

000037ec <__fp_szero>:
    37ec:	bb 27       	eor	r27, r27
    37ee:	66 27       	eor	r22, r22
    37f0:	77 27       	eor	r23, r23
    37f2:	cb 01       	movw	r24, r22
    37f4:	97 f9       	bld	r25, 7
    37f6:	08 95       	ret

000037f8 <__gesf2>:
    37f8:	8a df       	rcall	.-236    	; 0x370e <__fp_cmp>
    37fa:	08 f4       	brcc	.+2      	; 0x37fe <__gesf2+0x6>
    37fc:	8f ef       	ldi	r24, 0xFF	; 255
    37fe:	08 95       	ret

00003800 <__mulsf3>:
    3800:	0b d0       	rcall	.+22     	; 0x3818 <__mulsf3x>
    3802:	c0 cf       	rjmp	.-128    	; 0x3784 <__fp_round>
    3804:	b1 df       	rcall	.-158    	; 0x3768 <__fp_pscA>
    3806:	28 f0       	brcs	.+10     	; 0x3812 <__mulsf3+0x12>
    3808:	b6 df       	rcall	.-148    	; 0x3776 <__fp_pscB>
    380a:	18 f0       	brcs	.+6      	; 0x3812 <__mulsf3+0x12>
    380c:	95 23       	and	r25, r21
    380e:	09 f0       	breq	.+2      	; 0x3812 <__mulsf3+0x12>
    3810:	a2 cf       	rjmp	.-188    	; 0x3756 <__fp_inf>
    3812:	a7 cf       	rjmp	.-178    	; 0x3762 <__fp_nan>
    3814:	11 24       	eor	r1, r1
    3816:	ea cf       	rjmp	.-44     	; 0x37ec <__fp_szero>

00003818 <__mulsf3x>:
    3818:	c6 df       	rcall	.-116    	; 0x37a6 <__fp_split3>
    381a:	a0 f3       	brcs	.-24     	; 0x3804 <__mulsf3+0x4>

0000381c <__mulsf3_pse>:
    381c:	95 9f       	mul	r25, r21
    381e:	d1 f3       	breq	.-12     	; 0x3814 <__mulsf3+0x14>
    3820:	95 0f       	add	r25, r21
    3822:	50 e0       	ldi	r21, 0x00	; 0
    3824:	55 1f       	adc	r21, r21
    3826:	62 9f       	mul	r22, r18
    3828:	f0 01       	movw	r30, r0
    382a:	72 9f       	mul	r23, r18
    382c:	bb 27       	eor	r27, r27
    382e:	f0 0d       	add	r31, r0
    3830:	b1 1d       	adc	r27, r1
    3832:	63 9f       	mul	r22, r19
    3834:	aa 27       	eor	r26, r26
    3836:	f0 0d       	add	r31, r0
    3838:	b1 1d       	adc	r27, r1
    383a:	aa 1f       	adc	r26, r26
    383c:	64 9f       	mul	r22, r20
    383e:	66 27       	eor	r22, r22
    3840:	b0 0d       	add	r27, r0
    3842:	a1 1d       	adc	r26, r1
    3844:	66 1f       	adc	r22, r22
    3846:	82 9f       	mul	r24, r18
    3848:	22 27       	eor	r18, r18
    384a:	b0 0d       	add	r27, r0
    384c:	a1 1d       	adc	r26, r1
    384e:	62 1f       	adc	r22, r18
    3850:	73 9f       	mul	r23, r19
    3852:	b0 0d       	add	r27, r0
    3854:	a1 1d       	adc	r26, r1
    3856:	62 1f       	adc	r22, r18
    3858:	83 9f       	mul	r24, r19
    385a:	a0 0d       	add	r26, r0
    385c:	61 1d       	adc	r22, r1
    385e:	22 1f       	adc	r18, r18
    3860:	74 9f       	mul	r23, r20
    3862:	33 27       	eor	r19, r19
    3864:	a0 0d       	add	r26, r0
    3866:	61 1d       	adc	r22, r1
    3868:	23 1f       	adc	r18, r19
    386a:	84 9f       	mul	r24, r20
    386c:	60 0d       	add	r22, r0
    386e:	21 1d       	adc	r18, r1
    3870:	82 2f       	mov	r24, r18
    3872:	76 2f       	mov	r23, r22
    3874:	6a 2f       	mov	r22, r26
    3876:	11 24       	eor	r1, r1
    3878:	9f 57       	subi	r25, 0x7F	; 127
    387a:	50 40       	sbci	r21, 0x00	; 0
    387c:	8a f0       	brmi	.+34     	; 0x38a0 <__mulsf3_pse+0x84>
    387e:	e1 f0       	breq	.+56     	; 0x38b8 <__mulsf3_pse+0x9c>
    3880:	88 23       	and	r24, r24
    3882:	4a f0       	brmi	.+18     	; 0x3896 <__mulsf3_pse+0x7a>
    3884:	ee 0f       	add	r30, r30
    3886:	ff 1f       	adc	r31, r31
    3888:	bb 1f       	adc	r27, r27
    388a:	66 1f       	adc	r22, r22
    388c:	77 1f       	adc	r23, r23
    388e:	88 1f       	adc	r24, r24
    3890:	91 50       	subi	r25, 0x01	; 1
    3892:	50 40       	sbci	r21, 0x00	; 0
    3894:	a9 f7       	brne	.-22     	; 0x3880 <__mulsf3_pse+0x64>
    3896:	9e 3f       	cpi	r25, 0xFE	; 254
    3898:	51 05       	cpc	r21, r1
    389a:	70 f0       	brcs	.+28     	; 0x38b8 <__mulsf3_pse+0x9c>
    389c:	5c cf       	rjmp	.-328    	; 0x3756 <__fp_inf>
    389e:	a6 cf       	rjmp	.-180    	; 0x37ec <__fp_szero>
    38a0:	5f 3f       	cpi	r21, 0xFF	; 255
    38a2:	ec f3       	brlt	.-6      	; 0x389e <__mulsf3_pse+0x82>
    38a4:	98 3e       	cpi	r25, 0xE8	; 232
    38a6:	dc f3       	brlt	.-10     	; 0x389e <__mulsf3_pse+0x82>
    38a8:	86 95       	lsr	r24
    38aa:	77 95       	ror	r23
    38ac:	67 95       	ror	r22
    38ae:	b7 95       	ror	r27
    38b0:	f7 95       	ror	r31
    38b2:	e7 95       	ror	r30
    38b4:	9f 5f       	subi	r25, 0xFF	; 255
    38b6:	c1 f7       	brne	.-16     	; 0x38a8 <__mulsf3_pse+0x8c>
    38b8:	fe 2b       	or	r31, r30
    38ba:	88 0f       	add	r24, r24
    38bc:	91 1d       	adc	r25, r1
    38be:	96 95       	lsr	r25
    38c0:	87 95       	ror	r24
    38c2:	97 f9       	bld	r25, 7
    38c4:	08 95       	ret

000038c6 <_exit>:
    38c6:	f8 94       	cli

000038c8 <__stop_program>:
    38c8:	ff cf       	rjmp	.-2      	; 0x38c8 <__stop_program>
